\section{Introduction}
\label{sec:intro}
Driven by the increasing power of automated theorem provers,
fully automated program verification has seen a surge of interest
in recent years \needcite. \iffalse For example, automated program \emph{verification}
has been applied in the fields ... \needcite\fi
In particular, refinement type systems have been shown to be a practical
approach for program verification which is amenable
to automatic inference, an extremely desirable property
for program verification \needcite[liquid haskell, liquid types, ...].
However, even state of the art automated program verifiers (including
refinement type systems) struggle in settings with mutable, aliased references
and heaps of unbounded size. Most such type systems Given the wide deployment
of systems written in languages where such code is common, such as Java, C++, Ruby, etc.
this limitation of existing verification techniques prevents their
application to a wide range of systems where program safety is extremely
important.

One of the primary challenges posed by language with mutable aliased
references is the need to support \emph{strong updates}.
Unlike purely functional languages, the invariants that
hold on a memory location may evolve and change as the program
mutates that memory location. To accurately model the \emph{evolving, changing state}
common in languages with mutability, automated program verifiers must update
invariants on program values in ways that are incompatible with previous invariants.

Unfortunately, such updates are difficult to soundly effect in a setting
with aliasing. Due to aliasing relationships between memory locations, a write may
not only affect the invariants of the static name of the updated memory location
(e.g., the name of the pointer being updated) but the invariants on other pieces
of program state.
Handling such updates would be straightforward given perfect aliasing information, but it is
undecidable whether two pointers must- or may-alias \needcite. As a compromise,
static verifiers often resort to over-approximate aliasing information,
and \emph{weakly update} the invariants of all memory locations that may-alias according
to the approximation. Weak updates adversely affect precision, as the automated verifier
cannot tell whether the old or new invariant holds at the weakly updated location.

A related approach employed by some static verifiers/analyses \needcite[Jayhorn, Ltll]
is to model the heap explicitly and bound the size heap size
by employing \emph{summary locations} to represent many possible
concrete memory locations. However, as summary locations do not correspond
to a single location in memory, strong updates can \emph{never} used to model
the effects of mutation on static program names with summary locations. Given that
many programs in settings with mutability and aliasing frequently have unbounded
memory allocations, this restriction can also have a significantly adverse
on precision.

This paper presents \name (CONtext Sensitive Ownership Refinement Types):
a novel type system for the automated verification
of imperative languages with mutability and aliasing.  Critically,
\name does not make the tradeoffs described above, and
supports strong updates of mutable memory even in the presence of aliasing.
Our type system is supports these strong updates via the synthesis of
refinement types \needcite and fractional ownership types
\cite{suenaga2009fractional,suenaga2012type}.  Fractional ownership
types attach an \emph{ownership} in the range $[0,1]$
to every reference type constructor. These ownerships represent
the read/write capabilities of the reference;
only references with exclusive ownership $1$ may modify
reference contents.  The ownership type systems of
\cite{suenaga2009fractional,suenaga2012type} also maintain a critical
invariant exploited by our type system: at most one reference with
exclusive ownership may exist for a given location at any time. Further,
the ownership of all references that alias with an exclusive ownership pointer
are given the empty ownership $0$.

Our type system detects these empty ownerships and discards refinement
information on such references as they have mutable aliases.
\name may thus strongly update refinement
information under a reference type with exclusive ownership
\emph{without} needing to update or invalidate refinements on
aliased references as all refinement information on such aliases
must have been discarded in place of the $[[Top]]$ refinement.
\name may later propagate (potentially updated) refinement information
from a mutable reference to its aliases, provided the mutable reference
also divides its exclusive ownership with those aliases. Much
like mutable borrows in languages like Rust, ownerships
behave linearly, and programs are forbidden from synthesizing ownership
information ``from thin air'', protecting our critical invariant.
However, unlike Rust and other languages that use region based ownership or
borrow information \needcite[cyclone et al.], \name supports
\emph{fine-grained, per-statement} tracking of aliases. In particular,
references may gain and lose mutability throughout their lifetime. This
feature is particularly critical for the verification of programs
where memory is mutated through multiple, live references.

\begin{figure}[t]
  \begin{lstlisting}[numbers=left, numbersep=3pt, numberstyle=\tiny\color{black}]
    get(p) {
      return *p
    }
    main() {
      let p = mkref 0 in
      let v2 = get(p) in$\label{line:get1}$
      p := v + 1;
      let v1 = get(p) in$\label{line:get2}$
      assert(v1 = 1)
    }
  \end{lstlisting}
  \caption{Running example}
  \label{fig:running-example}
\end{figure}

\name is also \emph{context-sensitive}, and can thus precisely
summarize the different behaviors a function may exhibit when called
from different points in the program. Consider the simple example in
\cref{fig:running-example}. The function \imp{get} is called in two
locations, lines \labelcref{line:get1,line:get2}. To precise verify
this program, an automated reasoning tool cannot use a monolithic
summary of \imp{get}'s behavior. On line \labelcref{line:get1}
\imp{get} must be typed as a function that takes a reference whose
contents are exactly equal to 0 and then returns 0. Similarly, on line
\labelcref{line:get2}, \imp{get} must be typed as a function that
takes a reference to the integer 1, and which then returns 1. \name can
infer a type for \imp{get} that distinguish between these two calling
contexts and type \imp{get} differently at the different call-sites in
this program.

We have formalized \name as a type system for a small imperative calculus
and proved the system sound: i.e., well-typed program never encounter assertion
failures during execution. \JT{perhaps we should make it clear earlier that our
  goal is ensuring program safety (and not, e.g., liveness)} We have
implemented a prototype type inference tool for targeting this
imperative language and found it can verify several interesting,
complex programs, including sorted lists and an array list data structure.

The rest of this paper is organized as follows. \cref{sec:prelim} defines the
imperative language targeted by \name and defines its semantics. \cref{sec:typesystem}
provides a brief overview on the ownership type system of \cref{suenaga2009fractional},
defines our type system, and provdes our soundness statement. \cref{sec:infr} outlines
the inference process used by our inference tool and its current limitations.
\cref{sec:eval} describes an initial evaluation of our prototype, \cref{sec:rw} outlines
related work, and \cref{sec:concl} concludes.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
