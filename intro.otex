\section{Introduction}
\label{sec:intro}
Driven by the increasing power of automated theorem provers and
recent high-profile, expensive software failures,
fully automated program verification has seen a surge of interest
in recent years \needcite.
In particular, refinement types
\cite{flanagan2006hybrid,xi1999dependent,freeman1991refinement,bengtson2011refinement},
which refine base types with logical predicates, have been shown to be a practical
approach for program verification that are amenable to
(sometimes full) automation \cite{rondon2008liquid,vazou2014refinement,vazou2013abstract,unno2009dependent}.
However, despite promising advances \needcite,
the sound and precise application of refinement types (and program
verification in general) in settings with mutability and aliasing
(e.g., Java, C++, Ruby, etc.) remains difficult.

One of the primary challenges in this setting
is how to support \emph{strong updates}.
Unlike purely functional languages, the invariants that
hold on a memory location may evolve and change as the program
mutates that memory location. To accurately model the
\emph{evolving, changing state}
common in languages with mutability, automated program verifiers must update
invariants on memory locations in ways that are incompatible with previous invariants.

Unfortunately, such updates are difficult to soundly effect in a setting
with aliasing. Consider the (contrived) example program in
\Cref{fig:strong-update-example} written in an ML-like language
with mutable references; references are updated with \imp{:=} and
created with \imp{mkref}. \imp{p} can initially be given the type
$[[ {nu:int|nu = 3}]]\TREF$, indicating \imp{p} is a reference to an integer that
is exactly 3. Similarly, \imp{q} can be given the type
$([[ {nu:int|nu = 5}]] \TREF) \TREF$. As is common, we
are representing the invariants on memory locations with
types on the static program names that point to those locations,
i.e., \imp{p} and \imp{q}.

Let us first consider the write to \imp{p} on \cref{line:first-p-write}.
As we are mutating memory through the name \imp{p},
it is clearly sound to \emph{strongly} update \imp{p}'s
type to $[[ {nu:int|nu=4}]]\TREF$, i.e., the memory cell pointed
to by \imp{p} must hold the value 4.
What about the refinement on \imp{*q}? \imp{p} and \imp{*q}
do not alias on \cref{line:first-p-write} and it is thus correct to
retain \imp{q}'s original type. However, suppose we made the conservative
assumption that all references allocated at the same syntactic program point
(i.e., \cref{line:mk} in \imp{mk}) may alias (such assumptions are common, e.g., as in
\cite{rondon2010low,kahsai2017quantified});
we would have to update the refinement on \imp{q}.
However, given the uncertainty about whether \imp{p} and \imp{*q} alias,
we could only \emph{weakly} update \imp{q}'s type to be
$([[{nu:int|nu = 5 \/ nu = 4}]] \TREF) \TREF$, i.e., \imp{**q} may be
5 \emph{or} 4. Although this choice is sound it becomes
impossible to prove the assertion statement on
\cref{line:assert-statement}.

Further complicating matters, aliasing relationships may change
during program execution;
after \cref{line:q-alias-start} \imp{p} and \imp{**q} now \emph{must}
alias. Thus, it is sound to strongly update the invariants on both
\imp{p} and \imp{*q}. However, under the conservative assumption
described above, we would be forced once again to settle
for a \emph{weak} update of \imp{p}'s refinement.

\begin{figure}[t]
  \begin{minipage}[t]{0.45\textwidth}
  \begin{lstlisting}[numbers=left, numbersep=3pt, numberstyle=\tiny\color{black},numberblanklines=false]
mk(n) { mkref n }$\label{line:mk}$

let p = mk 3 in$\label{line:main-start}$
let q = mkref (mk 5) in
p := 1 + *p;$\label{line:first-p-write}$
assert(*p + 1 = **q);$\label{line:assert-statement}$
q := p;$\label{line:q-alias-start}$
*q := (**q) + 1;$\label{line:q-incr}$
  \end{lstlisting}
  \caption{Example demonstrating the difficulty of effecting strong updates in the presence of aliasing. The function \imp{mk} is
    bound in the program from \crefrange{line:main-start}{line:q-incr}; its body is given within the braces. \imp{:=} indicates destructive update.}
  \label{fig:strong-update-example}
\end{minipage}
\hfill
\begin{minipage}[t]{0.45\textwidth}
  \begin{lstlisting}[numbers=left,numbersep=3pt,numberstyle=\tiny\color{black},numberblanklines=false]
get(p) { *p }

let p = mkref 3 in
let q = mkref (mkref 5) in
p <- 1 + get(*p);$\label{line:get1}$
assert(*p + 1 = **q);
q <- p;
*q <- 1 + get(*q);$\label{line:get2}$
assert(**q = 5);
  \end{lstlisting}
  \caption{Running example}
  \label{fig:running-example}
\end{minipage}
\end{figure}

This paper presents \name (CONtext Sensitive Ownership Refinement Types),
a type system for the automated verification
of program safety for imperative languages with mutability and aliasing.
\name is built upon the novel combination of refinement types and
fractional ownership types \cite{suenaga2009fractional,suenaga2012type}.
Fractional ownership types are used to flow-sensitively and precisely
determine when a reference has a mutable alias; our type system
ensures that only the trivial refinement $[[Top]]$ is used within the
type of such references. As a consequence, at memory mutations
it is sufficient for our
type system to strongly update \emph{only} the refinements associated with the
static program name used to mutate memory.
From the soundness of ownership types and the above condition
enforced by \name, the types of any aliases must exclusively use the
refinement $[[Top]]$, and thus already soundly describe all possible contents.\footnote{This
  assumption holds only if updates do not change simple types, a condition our type-system enforces.}

Ownership types track mutable aliases by attaching a rational number
in the range $[0,1]$ (called an ownership) to each
reference type constructor.
An ownership of $0$ indicates that an immutable reference
that may have a mutable alias; \name therefore requires
that only the $[[Top]]$ refinement may appear within the type.
Ownership $1$ indicates a that reference
is mutable, \emph{and} that the types of aliases must have ownership $0$.
References with an ownership between these extremes may have any number of
\emph{immutable} aliases and may contain non-trivial refinements.

Ownerships behave linearly; they cannot be duplicated only \emph{split}
when aliases are created. Thus, when copying
a mutable pointer, the new alias may have non-trivial refinement information
only if the mutable pointer loses mutability.
Unlike systems which treat aliasing at the level of lexical regions
\cite{grossman2002region,jim2002cyclone,matsakis2014rust,tofte1994implementation},
\name supports \emph{fine-grained, per-statement} ownership tracking.
In particular, references may gain and lose mutability at any point
during program execution. For example, the ownership of
a mutable reference may be distributed among
many aliases, and then later collected into a single (potentially different)
reference, restoring mutability.
This feature is particularly critical for the verification of programs
where memory is mutated through multiple, live references.

To demonstrate the interplay of ownership and mutability, consider again the example
in \Cref{fig:strong-update-example}. \imp{p} and \imp{q} are both references
with no aliases, and can be given types
$[[ {nu:int|nu=3} ref 1 ]]$ and $[[ ({nu:int|nu = 5} ref 1) ref 1 ]]$ respectively.
From the invariants maintained by our type system,
it is sound to strongly update
\imp{p}'s type on \cref{line:first-p-write} without regard for any other pointers in the program;
as \imp{p} has ownership 1, all aliases must already have types consistent with the new contents.
At the pointer assignment on \cref{line:q-alias-start}, our type system must \emph{split}
the ownership of \imp{p} between \imp{*q} and \imp{p}.
As \imp{*q} is later used for mutation, our type system transfers \emph{all} ownership from
\imp{p} to \imp{*q} (recall that only references with ownership $1$ may be mutated).
Thus, after the assignment, \imp{q} has type  $[[ ({nu:int|nu=4} ref 1) ref 1 ]]$ and \imp{p} is
given type $[[ {nu:int|Top} ref 0 ]]$.
The type system may now soundly update \imp{*q}'s type on \cref{line:q-incr}
despite the existence of alias \imp{p}. Our type system can later
use static aliasing information to propagate the updated refinement in
\imp{*q} back to \imp{p} if necessary. \JT{This is maybe too detailed for
  the introduction}

\name is also \emph{context-sensitive}, and can thus precisely
summarize the different behaviors a function may exhibit when called
from different points in the program. Consider the example in
\Cref{fig:running-example}, which is a variant of the example in
\Cref{fig:strong-update-example}. The function \imp{get} simply reads
the contents of a pointer, and is called in two
locations, \cref{line:get1,line:get2}. To precise verify
this program, on line \labelcref{line:get1}
\imp{get} must be typed as a function that takes a reference that
contains 3 and returns 3. Similarly, on line
\labelcref{line:get2}, \imp{get} must be typed as a function that
takes a reference to 4 and returns 4. Our type system can
give \imp{get} a function type that distinguishes between these two calling
contexts and selects the appropriate summary of \imp{get}'s behavior.

We have formalized \name as a type system for a small imperative calculus
and proved the system sound: i.e., well-typed program never encounter assertion
failures during execution. We have
implemented a prototype type inference tool targeting this
imperative language and found it can verify several interesting,
complex programs, including sorted lists and an array list data structure.

The rest of this paper is organized as follows. \Cref{sec:prelim} defines the
imperative language targeted by \name and defines its semantics. \Cref{sec:typesystem}
provides a brief overview on the ownership type system of \cite{suenaga2009fractional},
defines our type system, and provides our soundness statement. \Cref{sec:infr} outlines
the inference process used by our inference tool and its current limitations.
\Cref{sec:eval} describes an initial evaluation of our prototype, \Cref{sec:rw} outlines
related work, and \Cref{sec:concl} concludes.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:

%  LocalWords:  provers verifiers verifier CONtext ownerships mkref
%  LocalWords:  mk
