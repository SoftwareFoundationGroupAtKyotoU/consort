\section{Introduction}
\label{sec:intro}
Driven by the increasing power of automated theorem provers and
recent high-profile, expensive software failures,
fully automated program verification has seen a surge of interest
in recent years \cite{leino2010dafny,cousot2005astree,ball2011decade,zave2012using,hawblitzel2015ironfleet,bhargavan2017everest}.
In particular, \emph{refinement types}
\cite{flanagan2006hybrid,xi1999dependent,freeman1991refinement,bengtson2011refinement},
which refine base types with logical predicates, have been shown to be a practical
approach for program verification that are amenable to
(sometimes full) automation \cite{rondon2008liquid,vazou2014refinement,vazou2013abstract,unno2009dependent}.
However, despite promising advances \cite{rondon2010low,kahsai2017quantified,gordon2013rely},
the sound and precise application of refinement types (and program
verification in general) in settings with mutability and aliasing
(e.g., Java, Ruby, etc.) remains difficult.

One of the primary challenges in this setting
is how to support \emph{strong updates}.
Unlike purely functional languages, the invariants that
hold on a memory location may evolve and change as the program
mutates that memory location. To accurately model this
evolving, changing state, automated program verifiers must be able
to update invariants on memory locations in ways that are incompatible with previous invariants.

Such updates are difficult to soundly effect in a setting
with aliasing. Consider the (contrived) example program in
\Cref{fig:strong-update-example} written in an ML-like language
with mutable references; references are updated with \imp{:=} and
created with \imp{mkref}. \imp{p} can initially be given the type
$[[ {nu:int|nu = 3}]]\TREF$, indicating \imp{p} is a reference to an integer that
is exactly 3. Similarly, \imp{q} can be given the type
$[[ {nu:int|nu = 5}]] \TREF$. \iffalse As is common, we
are representing the invariants on memory locations with
types on the static program names that point to those locations,
i.e., \imp{p} and \imp{q}.\fi

Let us now consider the write to \imp{p} on \cref{line:first-p-write}.
As we are mutating memory through the name \imp{p},
it is clearly sound to \emph{strongly} update \imp{p}'s
type to $[[ {nu:int|nu=4}]]\TREF$, i.e., the memory cell pointed
to by \imp{p} must hold the value 4.
What about the refinement on \imp{q}? \imp{p} and \imp{q}
do not alias on \cref{line:first-p-write} and it is thus correct to
retain \imp{q}'s original type. However, suppose we made the conservative
assumption that all references allocated at the same syntactic program point
(i.e., \cref{line:mk} in \imp{mk}) may alias (such assumptions are common as in, e.g.,
\cite{rondon2010low,kahsai2017quantified}). Under this assumption,
we would have to update the refinement on \imp{q}.
However, given the uncertainty about whether \imp{p} and \imp{q} alias,
we could only \emph{weakly} update \imp{q}'s type to be
$([[{nu:int|nu = 5 \/ nu = 4}]] \TREF$, i.e., the contents of \imp{q} may be
5 \emph{or} 4. Although sound, this choices makes it
impossible to prove the assertion on \cref{line:rq-eq-assert} succeeds.

Further complicating matters, aliasing relationships may change
during program execution; after \cref{line:r-alias}, \imp{p} and \imp{r} \emph{must}
alias. Thus, at the write to \imp{r} on \cref{line:r-write}
it is sound to strongly update the invariants on both
\imp{p} \emph{and} \imp{r}. However, under the conservative assumption
described above, we would be forced to settle
for a \emph{weak} update of \imp{p}'s refinement.

\begin{figure}[t]
  \begin{minipage}[t]{0.45\textwidth}
  \begin{lstlisting}[numbers=left, numbersep=3pt, numberstyle=\tiny\color{black},numberblanklines=false]
mk(n) { mkref n }$\label{line:mk}$

let p = mk(3) in$\label{line:main-start}$
let q = mk(5) in
p := *p + 1;$\label{line:first-p-write}$
let r = p in$\label{line:r-alias}$
r := *r + 1;$\label{line:r-write}$
assert(*r = *q);$\label{line:rq-eq-assert}$
  \end{lstlisting}
  \caption{Example demonstrating the difficulty of effecting strong updates in the presence of aliasing. The function \imp{mk} is
    bound in the program from \crefrange{line:main-start}{line:rq-eq-assert}; its body is given within the braces.}
  \label{fig:strong-update-example}
\end{minipage}
\hfill
\begin{minipage}[t]{0.45\textwidth}
  \begin{lstlisting}[numbers=left,numbersep=3pt,numberstyle=\tiny\color{black},numberblanklines=false]
get(p) { *p }

let p = mkref 3 in
let q = mkref 5 in
p := get(p) + 1;$\label{line:get1}$
let r = p in
r := get(r) + 1;$\label{line:get2}$
assert(*r = *q);
  \end{lstlisting}
  \caption{Running example}
  \label{fig:running-example}
\end{minipage}
\end{figure}

This paper presents \name (CONtext Sensitive Ownership Refinement Types),
a type system for the automated verification
of program safety for imperative languages with mutability and aliasing.
\name is built upon the novel combination of refinement types and
fractional ownership types \cite{suenaga2009fractional,suenaga2012type}.
Fractional ownership types extend pointer types with a number in the range $[0,1]$.
These ownerships encapsulate the permission of the reference; only
references with ownership $1$ may be used for mutation. Fractional ownership
types also obey the following key invariant: any references with a mutable
alias must have ownership 0,\footnote{As a consequence, only one distinguished
  mutable reference for every memory cell may exist at any point during program
  execution.} i.e., any reference with $0$ ownership may have a mutable alias.

\name ensures that only the trivial refinement $[[Top]]$ is used within the
type of references with $0$ ownership. Thus, when
memory is mutated through a reference with ownership $1$,
\name simply updates the refinements on the updated reference.
From the soundness of ownership types and the above condition
enforced by \name, the types of any aliases must exclusively use the
refinement $[[Top]]$, and thus already soundly describe all possible contents.\footnote{This
  assumption holds only if updates do not change simple types, a condition our type-system enforces.}

Ownerships behave linearly; they cannot be duplicated, only \emph{split}
when aliases are created. Thus, when copying
a mutable pointer, the new alias may have non-trivial refinement information
only if the mutable pointer loses mutability.
Unlike systems which treat aliasing at the level of lexical regions
\cite{grossman2002region,jim2002cyclone,matsakis2014rust,tofte1994implementation},
\name supports \emph{fine-grained, per-statement} ownership tracking.
In particular, references may gain and lose mutability at any point
during program execution. For example, the mutable ownership $1$ of
some reference may be distributed among
many aliases, and then later collected into a different
reference, restoring mutability.
This feature is particularly critical for the verification of programs
where memory is mutated through multiple, live references.


To demonstrate the interplay of ownership and mutability, consider again the example
in \Cref{fig:strong-update-example}. \imp{p} and \imp{q} are both references
with no aliases, and can be given types
$[[ {nu:int|nu=3} ref 1 ]]$ and $[[ {nu:int|nu = 5} ref 1 ]]$ respectively.
From the invariants maintained by our type system,
it is sound to strongly update
\imp{p}'s type on \cref{line:first-p-write} without regard for any other pointers in the program;
as \imp{p} has ownership 1, all aliases must already have types consistent with the new contents.
At alias creation on \cref{line:r-alias}, our type system must \emph{split}
the ownership of \imp{p} between \imp{p} and \imp{r}.
As \imp{r} is later used for mutation, our type system transfers \emph{all} ownership from
\imp{p} to \imp{r} (recall that only references with ownership $1$ may be mutated).
Thus, after the binding, \imp{r} has type  $[[ {nu:int|nu=4} ref 1 ]]$ and \imp{p} is
given type $[[ {nu:int|Top} ref 0 ]]$.
The type system may now soundly update \imp{r}'s type on \cref{line:r-write}
despite the existence of alias \imp{p}. Our type system can later
use static aliasing information to propagate the updated refinement in
\imp{r} back to \imp{p} before any reads through \imp{p}. \JT{This is maybe too detailed for
  the introduction}

\name is also \emph{context-sensitive}, and can
use different summaries of function behavior
at different points in the program. Consider the example in
\Cref{fig:running-example}, which is a variant of \Cref{fig:strong-update-example}.
The function \imp{get} returns the contents of its argument,
and is called on \cref{line:get1,line:get2}. To precisely verify
this program, at \cref{line:get1}
\imp{get} must be typed as a function that takes a reference that
contains 3 and returns 3. Similarly, on \cref{line:get2}
\imp{get} must be typed as a function that
takes a reference to 4 and returns 4. Our type system can
give \imp{get} a function type that distinguishes between these two calling
contexts and selects the appropriate summary of \imp{get}'s behavior.

We have formalized \name as a type system for a small imperative calculus
and proved the system sound: i.e., well-typed program never encounter assertion
failures during execution. We have
implemented a prototype type inference tool targeting this
imperative language and found it can automatically verify several
non-trivial programs, including sorted lists and an array list data structure.

The rest of this paper is organized as follows. \Cref{sec:prelim} defines the
imperative language targeted by \name and its semantics. \Cref{sec:typesystem}
provides a brief overview of fractional ownership type systems,
defines our type system, and states our soundness theorem. \Cref{sec:infr} outlines
the inference algorithm used by our implementaton and its current limitations.
\Cref{sec:eval} describes an initial evaluation of our prototype, \Cref{sec:rw} outlines
related work, and \Cref{sec:concl} concludes.\looseness=-1

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:

%  LocalWords:  provers verifiers verifier CONtext ownerships mkref
%  LocalWords:  mk
