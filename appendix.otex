\appendix

\begin{figure}
  \leavevmode
  \infrule[TE-Seq]{
    [[ Th | [] : T => G | B |-e E : T' => G' ]] \andalso
    [[ Th | G' | B |- e : T'' => G'' ]]
  }{
    [[ Th | [] : T => G | B |-e E; e : T'' => G'' ]]
  }
  \infrule[TE-Hole]{}{
    [[ Th | [] : T => G | B |-e [] : T => G ]]
  }
  \infrule[TE-Stack]{
    [[ Th | [] : T' => G' | B |-e E : T'' => G'']] \\
    [[ Th | G, x : T | B |- e : T' => G' ]] \\
`    [[ x not in dom G' ]] \andalso [[ B |- T' => G' ]]
  }{
    [[ Th | [] : T => G | B |-e E[let x = [] l in e] : T'' => G'' ]]
  }

  \begin{align*}
    [[ (E; e)[e'] ]] & = [[ E[e']; e ]] \\
    [[ [][e'] ]] & = e' \\
    [[ E[let y = [] l in e][x] ]] & = [[ E[let y = x in e] ]]
  \end{align*}
\caption{Context typing and substitution}
\label{fig:context-typing}
\end{figure}

\begin{figure}
  \leavevmode
  \infrule[Obsolete?]{
    [[ll = Trace(Es)]] \andalso [[ Th |- D ]] \andalso \forall j \in \set{0..n-1}.\seq{\ell_j} = tail^{n-j+1}([[ll]]) \\
    [[ Cons(H, R, G) ]] \andalso
    \forall i\in\set{1..n}.[[ Th | [] : Ti => Gi | lli-1 |-e Ei-1 : Ti-1 => Gi-1 ]] \\
    [[ Th | [] : T => G' | ll |-e En : Tn => Gn ]] \\
    [[ Th | G | ll |- e : T => G' ]] \andalso [[ ll |- G ]]
  }{
    [[ |- D <H,R,Es,En[e]> ]]
  }

  \infrule[Simplified]{
    [[ll = Trace(Es)]] \andalso [[ Th |- D ]] \andalso \forall j \in \set{1..n}.\seq{\ell_j} = tail^{n-j+1}([[ll]]) \\
    [[ Cons(H, R, G) ]] \andalso
    \forall i\in\set{1..n}.[[ Th | [] : Ti => Gi | lli |-e CEi : Ti-1 => Gi-1 ]] \\
    [[ Es ]] = [[CEn]] : \cdots : [[CE1]] : \cdot \andalso
    [[ Th | G | ll |- e : Tn => Gn ]] \andalso [[ ll |- G ]]
  }{
    [[ |- D <H,R,Es,e> ]]
  }

  \infax[]{
    [[ |- D AliasFail ]]
  }

  \begin{align*}
    [[Trace(.) = .]] && [[Trace(E[let x = [] l in e] : Es) = l : Trace(Es)]]
  \end{align*}
\caption{Machine state typing}
\label{fig:state-typing}
\end{figure}
\begin{figure}
  \begin{align*}
    [[Cons(H,R,G)]] = & [[SAT(H,R,G)]] \wedge [[forall a in H.Own(H,R,G)(a)]] \leq 1 \\
    [[SAT(H,R,G)]] = & [[ forall x in G.x in R /\ SATv(H,R,R(x),G(x)) ]] \\
    [[SATv(H,R,Rv,T)]] = & \begin{cases}
      [[Rv is INT /\ [R][Rv / nu]ph ]] & [[ T = {nu:int|ph} ]] \\
      [[a in H /\ SATv(H,R,H(a),T')]] & [[ T = T' ref r /\ Rv = a ]]
    \end{cases} \\
    [[ [empty]ph ]] & = [[ ph ]] \\
    [[ [R { y |-> nn }]ph ]] & =  [[  [R][nn/y]ph ]] \\
    [[ [R { y |-> a }]ph ]] & =  [[ [R]ph ]] \\
    [[Own(H,R,G)]] & =   [[ |< { x in dom G } own(H,R(x),G(x))]] \\
    [[own(H,v,T)]] & = \begin{cases}
      [[ { a |-> r } + own(H,H(a),T') ]] & [[v = a /\ a in H /\ T = T' ref r ]] \\
      [[ empty ]] & o.w.
    \end{cases} \\
  \end{align*}
  \caption{State consistency}
  \label{fig:consistency}
\end{figure}

\section{Proof of Type Soundness (\Cref{thm:soundness})}
We first define a typing relation for machine configurations $[[ < H, R, Es, e>]]$ as show in
\Cref{fig:state-typing}. The critical component of this typing relation is the consistency relation $[[Cons]]$.
Intuitively, $[[Cons]]$ expresses that the current heap and registers are consistent with the ownership
and refinement information implied by $[[G]]$. We say triple $( [[H]],[[R]],[[G]] )$ is \emph{consistent},
and write $[[Cons(H,R,G)]]$; the definition of this relation is shown in \Cref{fig:consistency}.
In the definitions for $[[own]]$ we write $[[ { a |-> r } ]]$ to denote a function $\textbf{Addr} \rightarrow [0,1]$
which returns $[[r]]$ for $[[a]]$, and $0$ otherwise. We write $[[empty]]$ to denote a constant
function $\textbf{Addr} \rightarrow [0,1]$ which always returns $0$. We define the addition between
two functions $[[O1]], [[O2]]: \textbf{Addr} \rightarrow [0,1]$ as: $[[ (O1 + O2)(a) = O1(a) + O2(a) ]]$.
Finally, if a summation $[[|<]]$ has no summands, we take its result to be $[[empty]]$.

The proof of \Cref{thm:soundness} requires the following three key lemmas. These lemmas are stated
with respect to some well-typed program $[[<D,e>]]$, i.e. $[[ |- <D, e> ]]$.
\begin{lemma}
  \label{lem:initial}
  $[[ |- D <empty,empty,.,e> ]]$
\end{lemma}
\begin{proof}
  Trivial, taking $[[G = empty]]$ and by inversion on $[[ |- <D,e> ]]$.
\end{proof}

\begin{lemma}
  \label{lem:assertfail}
  $[[ |- D C ]]$ implies $[[ C != AssertFail ]]$
\end{lemma}
\begin{proof}
  Simple proof by contradiction, as the $[[AssertFail]]$ is not well-typed.
\end{proof}
  
\begin{lemma}
  \label{lem:preservation}
  If $[[ |- D <H,R,Es,e> ]]$ and $[[ <H,R,Es,e> --> D C ]]$, then $[[ |- D C ]]$
\end{lemma}
\Cref{lem:preservation} is the heart of proof effort, give its proof in \Cref{sec:preservation-proof}.

We can now prove \Cref{thm:soundness} with a simple inductive argument.
\begin{proof}[\Cref{thm:soundness}: Soundness]
  From \Cref{lem:initial,lem:preservation} and an inductive argument, any configuration
  reachable from the initial state must be well-typed. Then, by \Cref{lem:assertfail} every
  configuration reachable from the initial state cannot be $[[ AssertFail ]]$, i.e., a well-typed
  program never experiences an assertion failure.
\end{proof}

The remainder of this appendix proves \Cref{lem:preservation}. We introduce some auxiliary definitions and
lemmas in \Cref{sec:aux-defn-lem} and give the proof of \Cref{lem:preservation} in \Cref{sec:preservation-proof}.

\section{Auxiliary Lemmas and Definitions}
\label{sec:aux-defn-lem}
% roughly
% * Execution Context properties
% * context substitution properties
% * variable subsitution
% * variable removal
% * subtype properties
% * homomorphisms
% * updates
% * call, return, and inversion move to the following

\input{wf_rules}

The well-formedness rules omitted from the main paper are found in \cref{fig:type-wf}.

We first prove that the subtyping relations are transitive.

\begin{lemma} % L15
  \label{lem:subtype-transitive}
  \leavevmode
  \begin{enumerate}
  \item \label{part:sub-env-impl} If $[[ G <: G' ]]$ then $[[ |= [G] ==> [G'] ]]$. \JT{RE: metalevel, I think here we actually want it to be at the type system level, but the point is well taken}
  \item \label{part:single-env-trans} If $[[ G |- T1 <: T2 ]]$ and $[[ G |- T2 <: T3 ]]$, then $[[ G |- T1 <: T3 ]]$
  \item \label{part:env-sup-subtype} If $[[ G <: G' ]]$ and $[[ G' |- T1 <: T2 ]]$, then $[[ G |- T1 <: T2 ]]$
  \item \label{part:env-sub-trans} If $[[ G <: G' ]]$,  $[[ G |- T1 <: T2 ]]$, and $[[ G' |- T2 <: T3 ]]$, then $[[ G |- T1 <: T3 ]]$.
  \item If $[[ G <: G' ]]$ and $[[ G' <: G'' ]]$, then $[[ G <: G'' ]]$.
  \end{enumerate}
\end{lemma}
\begin{proof}
  \leavevmode
  \begin{enumerate}
  \item It suffices to show that $[[ |= [G] ==> [x/nu]ph']]$ for any $[[x in dom G']]$ where $[[G'(x) = {nu:int|ph'}]]$.
    From $[[ G <: G' ]]$ we have $[[ |= [G] /\ ph ==> ph' ]]$ where $[[ G(x) = {nu:int|ph}]]$.
    We must then have $[[ |= [G] /\ [x/nu]ph ==> [x/nu]ph' ]]$. From the definition of $[[ [G] ]]$ we have $[[ [G] /\ [x/nu]ph <=> [G] ]]$, giving the desired result.
  \item By induction on $[[ G |- T1 <: T2 ]]$. We only consider the case where $[[ T1 = {nu:int|ph1} ]]$ and $[[ T2 = { nu:int|ph2} ]]$,
    the case for reference types follows from the induction hypothesis.
    By inversion on $[[ G |- T2 <: T3 ]]$ we therefore have:
    
    \begin{bcpcasearray}
      [[ T3 = { nu:int|ph3}]] & \\
      [[ |= [G] /\ ph1 ==> ph2 ]] & [[ |= [G] /\ ph2 ==> ph3 ]]
    \end{bcpcasearray}
    
    From which it is immediate that we must have $[[ |= [G] /\ ph1 ==> ph3 ]]$, whereby by \rn{Sub-Int} we can derive $[[ G |- T1 <: T3 ]]$.
  \item By induction on $[[ G |- T1 <: T2 ]]$. The case for reference types is immediate from the inductive hypothesis, we focus
    on the base case where $[[ T1 = {nu:int|ph1} ]]$ and $[[ T2 = {nu:int|ph2 } ]]$, and where $[[ |= [G'] /\ ph1 ==> ph2 ]]$.
    From $[[ G <: G' ]]$ and \Cref{part:sub-env-impl} above, we have $[[ |= [G] ==> [G'] ]]$ from which we can derive $[[ [G] /\ ph1 ==> ph2 ]]$, i.e.,
    $[[ G |- T1 <: T2 ]]$.
  \item Immediate from \Cref{part:single-env-trans,part:env-sup-subtype}.
  \item Immediate corollary of \Cref{part:env-sub-trans}.
  \end{enumerate}
\end{proof}

\begin{definition}
  A value $[[Rv]]$ reaches an integer with $[[nn]]$ dereferences in heap $[[H]]$ when it is in the relation  $[[ H |- Rv ~> nn ]]$
  defined as the smallest relation closed under the following rules:
  \begin{enumerate}
  \item If $[[ Rv is INT ]]$ then $[[ H |- Rv ~> 0 ]]$
  \item If $[[ H |- Rv ~> nn ]]$ and $[[ H(a) = Rv ]]$ then $[[ H |- a ~> nn + 1 ]]$
  \end{enumerate}
  We will write $[[ H |- Rv ~> |T| ]]$ to indicate a value $[[Rv]]$ is shape consistent with $[[T]]$ in heap $[[H]]$, where
  $[[|T|]]$ is the number of reference constructors in the type $[[T]]$.
\end{definition}

We also prove a standard inversion lemma to
handle the fact our typing rules are not syntax directed.


\begin{lemma} % L29
  \label{lem:type-result-wf}
  If $[[ B |- G ]]$ and $[[ Th | G | B |- e : T => G' ]]$ then $[[ B |- T => G' ]]$.
\end{lemma}
\begin{proof}
  By induction on the typing derivation of $[[e]]$, that well-formed types split with $+$ remain well-formed,
  and that the strengthening operation preserves well-formedness.
\end{proof}

\begin{lemma}[Inversion] % L14
  \label{lem:inversion}
  If $[[ B |- G ]]$, and $[[ Th | G | B |- e0 : T => G' ]]$,
  then there exists some $[[Gp]]$, $[[Tp]]$, and $[[Gp']]$
  such that $[[G <: Gp]]$, $[[ B |- Gp ]]$, $[[Gp',Tp <: G',T]]$,
  $[[ B |- T => G']]$, where:
  \begin{enumerate}
  \item If $[[e0 = x]]$ then $[[ Gp(x) = Tp + T']]$ and $[[Gp' = Gp[x <- T'] ]]$.
  \item If $[[e0 = let x = y in e]]$, then
    $[[ Th | Gp [ y <- T1 /\ y y = T1 x ], x : (T2 /\ x x = T2 y) | B|- e : Tp => Gp']]$, $[[ B |- Tp => Gp' ]]$,
    and $[[ x not in dom Gp' ]]$ where $[[Gp(y) = T1 + T2]]$.
  \item If $[[ e0 = let x = nn in e]]$ then $[[ Th | Gp, x : {nu: int | nu = nn } | B |- e : Tp => Gp' ]]$, $[[ B |- Tp => Gp' ]]$, and $[[ x not in dom Gp' ]]$.
  \item If $[[e0 = ifz x then e1 else e2 ]]$ then:
    \begin{itemize}
    \item $[[ Gp(x) = { nu : int | ph } ]]$
    \item $[[ Th | Gp[ x <- {nu:int| ph /\ nu = 0}] | B |- e1 : Tp => Gp' ]]$
    \item $[[ Th | Gp[ x <- {nu:int| ph /\ nu != 0}] | B |- e2 : Tp => Gp' ]]$
    \end{itemize}
  \item If $[[ e0 = let x = mkref y in e ]]$, then $[[ Gp(y) = T1 + T2 /\ Th | G[y <- T1],x : (T2 /\ x x = T2 y) ref 1 | B |- e : T => Gp']]$, $[[ B |- Tp => Gp' ]]$,  and $[[ x not in dom Gp' ]]$
  \item If $[[ e0 = let x = *y in e ]]$, then:
    \begin{itemize}
    \item $[[Gp(y) = T1 + T2 ref r]]$
    \item $[[Th | Gp[y <- T'' ref r], x : T2 | B |- e : Tp => Gp']]$
    \item $[[ B |- Tp => Gp' ]]$, 
    \item $[[ x not in Gp' ]]$
    \item \[
        [[T'' ]] = \begin{cases}
          [[(T1 /\ y y = T1 x)]] & [[ r > 0 ]] \\
          [[T1]] & [[r = 0]]
        \end{cases}
      \]
    \end{itemize}
  \item If $[[ e0 = let x = f l (y1,,yn) in e]]$ then:
    \begin{itemize}
    \item $[[ Gp(yi) = csub vsub Ti ]]$ for each $i \in \set{1,\ldots,n}$
    \item $[[ Th | Gp[yi <- csub vsub Ti'], x : csub vsub T | B |- e : Tp => Gp' ]]$
    \item $[[ Th(f) = A < x1 : T1 ,, xn : Tn > -> <x1: T1' ,, xn : Tn' | T > ]]$
    \item $[[csub = [l:B/A] ]]$
    \item $[[ vsub = [y1/x1] ,, [yn/xn] ]]$
    \item $[[ x not in dom Gp' ]]$
    \item $[[ B |- Tp => Gp' ]]$, 
    \end{itemize}
  \item If $[[ e0 = y := x; e ]]$ then:
    \begin{itemize}
    \item $[[ Gp(x) = T1 + T2 ]]$
    \item $[[ Gp(y) = T' ref 1 ]]$
    \item $[[ Th | Gp[x <- T1][y <- (T2 /\ y y = T2 x) ref 1] | B |- e : Tp => Gp' ]]$
    \item The shapes of $[[T']]$ and $[[T2]]$ are similar, i.e, $[[|T'| = |T2|]]$.
    \end{itemize}
  \item If $[[ e0 = alias(x = y); e ]]$ then there exist some $[[T1]], [[T2]], [[T1']], [[T2']], [[r1]], [[r2]], [[r1']], [[r2']]$ such that:
    \begin{itemize}
    \item $[[ T1 ref r1 + T2 ref r2 ~ T1' ref r1' + T2' ref r2' ]]$
    \item $[[ Gp(x) = T1 ref r1 ]]$ and $[[Gp(y) = T2 ref r2 ]]$
    \item $[[ Th | G[x <- T1' ref r1'][y <- T2' ref r2'] | B |- e : Tp => Gp' ]]$
    \end{itemize}
  \item If $[[ e0 = alias(x = *y); e ]]$ then there exist some $[[T1]], [[T2]], [[T1']], [[T2']], [[r1]], [[r2]], [[r1']], [[r2']], [[r]]$, such that:
    \begin{itemize}
    \item $[[ T1 ref r1 + T2 ref r2 ~ T1' ref r1' + T2' ref r2' ]]$
    \item $[[Gp(x) = T1 ref r1]]$ and $[[Gp(y) = (T2 ref r2) ref r]]$
    \item $[[ Th | G[x <- T1' ref r1'][y <- (T2' ref r2') ref r] | B |- e : Tp => Gp' ]]$
    \end{itemize}
  \item If $[[ e0 = e1; e2 ]]$ then $[[ Th | Gp | B |- e1 : T1 => G1 ]]$ and $[[ Th | G1 | B |- e2 : Tp => Gp' ]]$
  \item If $[[ e0 = x; e' ]]$ then $[[ Th | Gp[x: T' + T0] | B |- x : T1 => Gp[x <- T0] ]]$ and $[[ Th | Gp[x <- T0] | B |- e' : Tp => Gp' ]]$
  \item If $[[ e0 = assert(ph); e ]]$ then $[[ Gp |= ph ]]$ and $[[ Th | Gp | B |- e : Tp => Gp' ]]$
  \end{enumerate}
\end{lemma}
\begin{proof}
  By straightforward induction on the typing relation, \Cref{lem:type-result-wf}, and
  the transitivity of the subtyping relation \Cref{lem:subtype-transitive}.

  The only case of note is the case for $[[ e0 = x; e2 ]]$. If the subderivation for $[[x]]$
  has applications of \rn{T-Sub} then the subtypings on the output environment can be pushed
  into application subtyping on input environments when typing $[[e']]$. Similarly,
  any input subtypings on the input environment of the derivation of $[[x]]$ can be pushed
  into \rn{T-Sub} rules such that $[[G <: Gp[x : T' + T0] ]]$.
\end{proof}

\Cref{lem:stack_var,lem:ectxt-sub-well-typed} prove some standard properties of execution contexts:
any decomposition of a well-typed expression into a execution context and redex can be well-typed,
substituting a well-typed expression matching a context's hole type yields a well-typed expression

\begin{lemma} % L26
  \label{lem:stack_var}
  For any $[[E]]$ and $[[e']]$ such that $[[E[e'] = e]]$ where
  $[[Th | G | B |- e : T => G']]$ there exists some $[[T0]]$, $[[G0]]$ such that
  $[[Th | []: T0 => G0 | B |-e E : T => G' ]]$ and
  $[[Th | G | B |- e' : T0 => G0]]$.
\end{lemma}
\begin{proof}
  By induction on the structure of $[[E]]$.
  \begin{rncase}{TE-Hole}
    Trivial, by taking $[[T0 = T]]$ and $[[G0 = G']]$.
  \end{rncase}
  \begin{rncase}{TE-Seq}
    Then $[[E = E'; e'']]$ and $[[E[e'] = E'[e']; e'' = e]]$. By
    \Cref{lem:inversion} we have
    $[[ Th | Gp | B |- E'[e'] : T1 => G1]]$,
    $[[Th | G1 | B |- e'': Tp => Gp']]$,
    $[[G <: Gp]]$,
    $[[ B |- Gp ]]$,
    $[[ B |- T => G' ]]$,
    $[[Gp', Tp <: G', T]]$ for some
    $[[Gp]]$, $[[Gp']]$, and $[[Tp]]$.
    
    By the induction hypothesis
    we then have $[[ Th | Gp | B |- e' : T0 => G0 ]]$ and
    $[[ Th | []: T0 => G0 | B |-e E' : T1 => G1 ]]$.
    
    Next, as $[[ Gp', Tp <: G', T]]$ and $[[ B |- T => G' ]]$,
    by an application of \rn{T-Sub}, we have
    $[[ Th | G1 | B |- e'' : T => G' ]]$. By \rn{TE-Seq}, we therefore
    have: $[[ Th | [] : T0 => G0 | B |-e E'; e'' : T => G' ]]$.

    Finally, from $[[ G <: Gp ]]$, $[[ B |- Gp ]]$, $ [[ Th | Gp | B |- e' : T0 => G0 ]]$,
    and application of \rn{T-Sub}, we have $[[ Th | G | B |- e' : T0 => G0 ]]$.
  \end{rncase}
\end{proof}

\begin{lemma} % L24
  \label{lem:ectxt-sub-well-typed}
  If, for some $[[G]]$,
  $[[ Th | [] : T => G' | B |-e E : T'' => G'']]$ and $[[Th | G | B |- e : T => G' ]]$
  then
  $[[ Th | G | B |- E[e] : T'' => G'' ]]$.
\end{lemma}
\begin{proof}
  By induction on the typing derivation of $[[E]]$.
  \begin{rneqncase}{TE-Seq}{
      [[ E ]] = [[ E'; e' ]] \\ [[ E[e] = E'[e]; e' ]] \\
      [[ Th | [] : T => G' | B |-e E' : T0 => G0 ]] \\ [[ Th | G0 | B |- e' : T''' => G''' ]] \\
      [[ G''', T''' <: G'', T'']] \\
      [[ B |- T'' => G'']]
    }
    By the induction hypothesis we have $[[ Th | G | B |- E'[e] : T0 => G0 ]]$. Combined
    with the assumptions $[[ Th | G0 | B |- e' : T''' => G''' ]]$
    and $[[ G''', T''' <: G'', T'']]$ the result holds
    via application of the proof rules \rn{T-Seq} and \rn{T-Sub}.
  \end{rneqncase}
  \begin{rncase}{TE-Hole}
    Trivial, as $[[T = T'']]$ and $[[G' = G'']]$ and $[[E[e] = e]]$.
  \end{rncase}
\end{proof}

%% CONTEXT SUBSTITUTION

\def\subref#1#2{\Cref{#1} (part \labelcref{#2})}

\begin{lemma}[Context Variable Substitution]\label{lem:ctxt-substitution}
  \leavevmode
  \begin{enumerate}
  \item \label{itm:ctxt-sub-distribute} If $[[ T3 = T1 + T2 ]]$ then $[[ [B/A]T3 = [B/A]T1 + [B/A]T2]]$
  \item \label{itm:ctxt-sub-wf}For any $[[ ll ]]$:
    \begin{enumerate}
    \item If $[[ A |- G ]]$ then $[[ ll |- [ll / A]G]]$
    \item If $[[ G | A |- T ]]$ then $[[ [ll/A]G | ll |- [ll/A]T]]$
    \item If $[[ A |- T => G ]]$ then $[[ ll |- [ll/A] T => [ll/A]G ]]$
    \end{enumerate}
  \item \label{itm:ctxt-sub-subtype} For any $[[G]]$, $[[T1]]$, $[[T2]]$, $[[A]]$ and $[[ll]]$, If $[[ G |- T1 <: T2 ]]$, then $[[ [ll/A]G |- [ll/A]T1 <: [ll/A]T2 ]]$
  \item \label{itm:ctxt-subst-well-typed} If $[[ Th | G | A |- e : T => G' ]]$ then $[[ Th | [ ll / A ] G | ll |- e : [ ll / A ] T => [ ll / A ] G' ]]$
  \end{enumerate}
\end{lemma}
\begin{proof}\leavevmode
  \begin{enumerate}
  \item By straightforward case analysis on the definition of $[[ T1 + T2 ]]$.
  \item Observe that for any substitution $[[ [ll/A] ]]$, $[[ST([ll/A]G) = ST(G)]]$,
    so it suffices to show that $[[ FPCV ( [ll/A]ph ) ]] \subseteq [[CV(ll)]] = \emptyset$
    for any refinement $[[ph]]$ appearing in $[[T]]$ or a type in $[[G]]$.
    n
    By the assumed well-formedness of $[[T]]$ with respect to context
    variable $[[A]]$ (resp. $[[G]]$), after substitution all free
    context variables in $[[T]]$ (resp. the types in $[[G]]$) will be
    replaced with $[[ll]]$. Thus, post-substitution no free context
    variables appear in the refinement of $[[ [ll/A] T]]$ (resp. refinements of
    types in $[[ [ll/A] G]]$), trivially satisfying our requirements.
  \item If $[[A]]$ does not appear free in $[[T1]]$, $[[T2]]$ or $[[G]]$, then the result trivially holds. Let us then assume
    $[[A]]$ appears free. We prove the result by induction on the subtyping derivation.

    \begin{rneqncase}{Sub-Ref}{
        [[ T1 = T1' ref r1 ]] & [[ T2 = T2' ref r2 ]] \\
        [[ [ll/A] T1 = ([ll/A]T1') ref r1 ]] & [[ [ll/A]T2 = ([ll/A]T2') ref r2 ]] \\
        [[  G |- T1' <: T2' ]] & [[ r2 <= r1 ]]
      }
      We must show that $[[ [ll/A]G |- [ll/A]T1' <: [ll/A]T2' ]]$
      which holds immediately from the induction hypothesis.
    \end{rneqncase}

    \begin{rneqncase}{Sub-Int}{
        [[ T1 = {nu:int|ph1} ]] & [[ T2 = {nu:int|ph2} ]] \\
        [[ [ll/A]T1 = {nu:int|[ll/A]ph1 } ]] & [[ [ll/A]T2 = {nu:int|[ll/A]ph2 } ]] \\
        [[ G |= ph1 ==> ph2 ]]
      }
      We must show that $[[ [ll/A]G |= [ll/A]ph1 ==> [ll/A]ph2 ]]$, i.e. $[[ |= [ [ll/A]G ] /\ [ll/A]ph1 ==> [ll/A]ph2 ]]$.
      From our assumption that $[[ G |= ph1 ==> ph2 ]]$ we have that $[[ |= [ G ] /\ ph1 ==> ph2 ]]$ is valid,
      whereby the formula $[[ [ G ] /\ ph1 ==> ph2 ]]$ is true for any possible concrete valuation of the free context
      variable $[[A]]$. Thus the formula $[[ [ [ll/A]G ] /\ [ll/A]ph1 ==> [ll/A]ph2 ]]$ must also be valid.
    \end{rneqncase}
  \item By induction on the typing derivation $[[ Th | G | A |- e : T => G' ]]$.
    \begin{rneqncase}{T-Var}{
        [[e = x]] & [[T = T2]] \\
        [[G = G0[x : T1 + T2] ]] & [[ G' = G0[x <- T2] ]]
      }
      By application of \Cref{itm:ctxt-sub-distribute}.
    \end{rneqncase}
    \begin{rneqncase}{T-LetInt}{
        [[e = let x = nn in e']] & [[ Th | G, x:{nu:int|nu = nn} | A |- e' : T => G' ]] \\
        [[ x not in dom G']] &
      }
      The induction hypothesis gives
      \[
        [[ Th | [ll/A]G, x:{nu:int|nu=nn} | ll |- e : [ll/A]T => [ll/A]G'' ]]
      \]
      \Cref{itm:ctxt-sub-wf} gives $[[ ll |- [ll/A]T => [ll/A]G'' ]]$, from which we
      conclude $[[ Th | [ll/A]G | ll |- let x = nn in e : [ll/A]T => [ll/A]G'' ]]$
      as required.
    \end{rneqncase}

    \begin{rneqncase}{T-Let}{
        & [[e = let x = y in e']] & [[ x not in dom G' ]] \\
        & [[ Th | G1 | A |- e' : T => G' ]] & [[ G1 = G[y <- (T1 /\ y y = T1 x)], x:(T2 /\ x x = T2 y)]] \\
        & [[ G = G0[y: T1 + T2]  ]]
      }
      By \Cref{itm:ctxt-sub-distribute},
      $[[ ([ll/A]G)(y) = [ll/A](T1 + T2) = ([ll/A]T1 + [ll/A]T2) ]]$. We must then
      show that $[[ Th | G1' | ll |- e' : [ll/A]T => [ll/A]G'' ]]$
      where
      \[
        [[ G1' = ([ll/A]G)[y <- [ll/A]T1 /\ y y = x ],x:([ll/A]T2 /\ x x = y) ]]
      \]
      As $[[G1' = [ll/A]G1]]$ the induction hypothesis gives the required typing judgment.
      That $[[ll |- [ll/A]T => [ll/A]G'' ]]$ follows from \Cref{itm:ctxt-sub-wf} as in the \rn{T-LetInt}
      case.
    \end{rneqncase}

    \begin{rncase}{T-If,T-Seq}
      By trivial application of the inductive hypothesis.
    \end{rncase}

    \begin{rncase}{T-MkRef,T-Deref}
      By reasoning similar to \rn{T-Let}.
    \end{rncase}

    \begin{rneqncase}{T-Call}{
        [[ e = let x = f l (y1,,yn) in e']] \\
        [[ vsub = [y1/x1] ,, [yn/xn] ]] \\
        [[ csub = [l:A/A'] ]] \\
        [[ Th | G1 | A |- e' : T => G' ]] \\
        [[ A |- T => G' ]] & [[y not in dom G' ]]\\
        [[ Th(f) = A' < x1 : T1 ,, xn : Tn > -> <x1: T1' ,, xn : Tn' | T' > ]]  \\
        [[ G1 = G[yi <- csub vsub Ti'], x : csub vsub T' ]]
      }
      We must first show that for $[[ csub' = [l:ll/A'] ]]$:
      \[
        [[  Th | G3 | ll |- e' : [ll/A]T => [ll/A]G2 ]]
      \]
      where $[[ G3 = ([ll/A]G)[yi <- csub' vsub Ti'], x: csub' vsub T']]$.

      We first observe that $[[ G3 = [ll/A]G1 ]]$ (this follows from the
      equivalence of $[[ [ll/A][l:A/A'] ]]$ and
      $[[ [l:ll / A'] ]]$) whereby the induction hypothesis
      gives the required typing derivation.

      We must also show that
      $\forall i \in \set{1..n}.[[([l:ll/A]G)(yi) = csub' vsub Ti]]$.
      From the assumed well-typing of the term under $[[A]]$ we have
      that $\forall i \in\set{1..n}.[[G(yi) = csub vsub Ti]]$. Recall
      that $[[csub']]$ is equivalent to $[[ [ll/A] csub ]]$, whereby we have
      $[[ [ll/A] G(yi) = [ll/A] csub vsub Ti = csub' vsub Ti]]$ for any $[[i]]$ as
      equality is preserved by consistent substitution.

      That $[[ ll |- [ll/A]T => [ll/A]G' ]]$ holds from application of
      \Cref{itm:ctxt-sub-wf}.
    \end{rneqncase}

    \begin{rncase}{T-Assign,T-Alias}
      By the inductive hypothesis and application of \Cref{itm:ctxt-sub-distribute}.
    \end{rncase}

    \begin{rneqncase}{T-Sub}{
        [[ Th | G1 | A |- e : T1 => G2 ]] & [[ G <: G1 ]] \\
        [[ G2,T1 <: G',T ]] & [[ A |- G1 ]] \\
        [[ A |- T => G' ]] & 
      }
      By the induction hypothesis we have that: $[[ Th | [ll/A]G1 | ll |- e : [ll/A]T1 => [ll/A]G2 ]]$.
      If we show that $[[ [ll/A]G <: [ll/A]G1 ]]$ and $[[ [ll/A]G2,[ll/A]T1 <: [ll/A]G',[ll/A]T ]]$
      we will have the required result. To show the first requirement, for any $[[ x in G ]]$ we have that
      $[[ [ll/A]G |- [ll/A]G(x) <: [ll/A]G1(x) ]]$ from \Cref{itm:ctxt-sub-subtype} so we have $[[ [ll/A]G <: [ll/A]G1 ]]$.
      To show the latter requirement, we observe that $[[ [ll/A]G2,[ll/A]T1 <: [ll/A]G',[ll/A]T ]]$ is equivalent to showing
      $[[ [ll/A](G2, x : T1) <: [ll/A](G', x: T) ]]$ for some $[[x not in dom G2 ]]$,
      whereby we have the required subtyping relationship from the application of \Cref{itm:ctxt-sub-subtype}.
      Finally, that $[[ ll |- [ll/A]T => [ll/A]G' ]]$ and $[[ ll |- [ll/A]G1 ]]$ follows from \Cref{itm:ctxt-sub-wf}.
    \end{rneqncase}
  \end{enumerate}
\end{proof}

%% VARIABLE SUBSTITUTION

\begin{lemma}[Substitution] % L19
  \label{lem:substitution}
  If $[[ Th | G | B |- e : T => G' ]]$ and $[[ x' not in G ]]$, then
  $[[ Th | [x'/x]G | B |- e : [x'/x]T => [x'/x]G']]$.
\end{lemma}
\begin{proof}
  By straightforward induction of typing rules.
\end{proof}

We now prove that if every variable satisfies its refinement in a type environment $[[ G ]]$,
we must have $[[ |= [R][G] ]]$.

\begin{lemma}
  \label{lem:sat-implies-gamma}
  If $[[ SAT(H, R, G) ]]$ then $[[ |= [R][G] ]]$.
\end{lemma}
\begin{proof}
  To show $[[ |= [R][G] ]]$, it suffices to show that for any $[[ x in dom G ]]$ where $[[ G(x) = { nu:int|ph } ]]$
  $[[ |= [R] [x/nu]ph ]]$ holds. From $[[ SAT(H, R, G) ]]$, we must have $[[ SATv(H, R, R(x), G(x)) ]]$, whereby
  we have $[[ R(x) is INT ]]$ and $[[ [R][R(x)/nu]ph ]]$. As $[[ [R][x/nu]ph ]]$ is equivalent to $[[ [R][R(x)/nu]ph ]]$,
  and we have the desired result.
\end{proof}

% PROPERTIES OF SUBTYPING

We prove that subtyping preserves the consistency relation in the following sense.

\begin{lemma} % L18
  \label{lem:subtyp-preserves-cons}
  If $[[ G <: G' ]]$ and $[[ Cons(H,R,G)]]$ then:
  \begin{enumerate}
  \item For any $[[x in dom G']]$, $[[ own(H,R(x),G(x))(a) <= own(H,R(x),G'(x))(a) ]]$
  \item $[[forall a in H.Own(H,R,G')(a) <= 1]]$
  \item If $[[ G |- T <: T']]$ and $[[SATv(H,R,v,T)]]$ then $[[SATv(H,R,v,T')]]$
  \item $[[SAT(H,R,G')]]$
  \item $[[Cons(H,R,G')]]$
  \end{enumerate}
\end{lemma}
\begin{proof}
  \leavevmode
  \begin{enumerate}
  \item By induction on $[[G |- G(x) <: G'(x)]]$.
  \item Direct consequence of 1.
  \item From $[[Cons(H,R,G)]]$ we have $[[SAT(H,R,G)]]$ which by \Cref{lem:sat-implies-gamma} we have $[[ |= [R][G] ]]$.
    We now proceed by induction on $[[G |- T <: T']]$.
    \begin{eqncase}{
        [[T = {nu:int |ph}]] & [[T' = {nu:int|ph'}]] \\
        [[|= [G] /\ ph ==> ph']]
      }
      From $[[ SAT(H, R, G) ]]$ we have $[[ SATv(H, R, R(x), T) ]]$, in particular we must have
      $[[ |= [R][v/nu]ph ]]$. We must show that $[[ |= [R][v/nu]ph' ]]$.
      From $[[ |= [G] /\ ph ==> ph' ]]$ we must have
      $[[ |= [R][G] /\ [R][v/nu]ph ==> [R][v/nu]ph' ]]$, whereby the result is immediate.
    \end{eqncase}
    
    \begin{eqncase}{
        [[T = Tp ref r1]] & [[T' = Tp' ref r2]] \\
        [[ r2 <= r1 ]]
      }
      Immediate from the induction hypothesis.
    \end{eqncase}
  \item Immediate consequence of 3 and that
    $[[ G <: G' ]]$ implies that $[[G |- G(x) <: G'(x)]]$ for any $[[x in G']]$.
  \item Immediate from 2 and 4.
  \end{enumerate}
\end{proof}

To show consistency is preserved during evaluation, \Cref{lem:sattosat,lem:ownequiv-preserv}
show types equivalent according to $[[~]]$ are equivalent for the purposes
of $[[own]]$ and $[[SATv]]$. Then \Cref{lem:ownadd,lem:satadd} show that the
type addition operator $+$ ``distributes'' over $[[SATv]]$ and $[[own]]$.

\begin{lemma}[Type Equivalence Preserves Satisfiability] % L10
  \label{lem:sattosat}
  If $[[T1 ~ T2]]$, then $[[SATv(H,R,v,T1) <=> SATv(H,R,v,T2)]]$.
\end{lemma}
\begin{proof}
  We prove the forward case by induction on $[[ empty |- T1 <: T2 ]]$ as implied by
  $[[ T1 ~ T2 ]]$. The inductive case follows from the IH, and the base case
  where $[[ T1 = {nu:int|ph1} ]]$ and $[[ T2 = {nu:int|ph2}]]$ follows
  from $[[ ph1 ==> ph2 ]]$ holding under any valuation of variables.

  The backwards case follows similar reasoning by induction on $[[ empty |- T2 <: T1 ]]$.
\end{proof}

\begin{lemma} % L12
  \label{lem:ownequiv-preserv}
  If $[[ T1 ~ T2]]$, then $[[ own(H,v,T1) = own(H,v,T2)]]$.
\end{lemma}
\begin{proof}
  By reasoning similar to that in \Cref{lem:sattosat}.
\end{proof}

\begin{lemma} % L11
  \label{lem:ownadd}
  If $[[ Tp = T1 + T2 ]]$, then $[[own(H,v,Tp) = own(H,v,T1)+own(H,v,T2)]]$.
\end{lemma}
\begin{proof}
  By induction on the rules used to derive $[[ T1 + T2 = Tp]]$.
  \begin{rncase}{Tadd-Int}
    We have $[[own(H,v,Tp)=own(H,v,T1 + T2)]]$, where $[[ T1 + T2 = {nu:int | ph1/\ph2} ]]$,
    $[[own(H,v,T1)]]$ and $[[own(H,v,T2)]]$, where $[[ T1= {nu:int | ph1} ]], [[ T2 = {nu:int | ph2} ]]$.
  
    From the definition of ownership, we have $[[own(H,v,Tp)=own(H,v,T1)=own(H,v,T2)=empty]]$.
    It is thus trivial that $[[own(H,v,Tp) = own(H,v,T1) + own(H,v,T2)]]$.
  \end{rncase}

  \begin{rncase}{Tadd-Ref}
    We have $[[own(H,v,Tp)=own(H,v,T1 + T1)]]$, where $[[ T1 + T2 = (T1' + T2') ref r1+r2 ]]$,
    and  $[[ T1 = T1' ref r1 ]]$, $[[ T2 = T2' ref r2 ]]$.
    
    From the definition of ownership, we have $[[own(H,v,Tp)={a |-> r1+r2 } + own(H,H(v),T1' + T2')]]$ and:
    \begin{align*}
      [[own(H,v,T1) + own(H,v,T2)]] & = [[{a |-> r1}+own(H,H(v),T1') + {a |-> r2}+own(H,H(v),T2') ]] \\
                                    & = [[{ a |-> r1 + r2 } + own(H,H(v),T1') + own(H,H(v),T2')]]
    \end{align*}
    By the induction hypothesis, have that $[[own(H,H(v),T1' + T2') = own(H,H(v),T1') + own(H,H(v),T2')]]$ and can conclude that $[[own(H,v,Tp) = own(H,v,T1) + own(H,v,T2)]]$.
  \end{rncase}
\end{proof}

\begin{lemma} % L13
  \label{lem:satadd}
  If $[[ Tp =  T1+T2 ]]$, we have
    $[[ SATv(H, R, Rv, Tp) ]]$ iff. $[[ SATv(H, R, Rv, T1) /\ SATv(H, R, Rv, T2) ]]$
\end{lemma}
\begin{proof}
  By induction on the rules used to derive $[[ T1 + T2 ]]$. In the following
  we only prove the forward direction of the implication; the backwards
  direction is symmetric.
  \begin{rncase}{Tadd-Int}
    We have $[[ SATv(H, R, Rv, T1+T2) ]]$, where $[[ T1 + T2 = {nu:int | ph1/\ph2} ]]$,
    we must show $[[ SATv(H, R, Rv, T1) ]]$ and $[[ SATv(H, R, Rv, T2) ]]$,
    where $[[ T1= {nu:int | ph1} ]], [[ T2 = {nu:int | ph2} ]]$.

    From the definition of $[[SATv]]$, we must then show $[[ SATv(H, R, Rv, T1) ]]$ and in particular $[[ [R][Rv/nu]ph1 ]]$
    and similarly $[[ [R][v/nu]ph2 ]]$.
    From $[[ SATv(H, R, Rv, T1+T2) ]]$ we have $[[ [R][v/x](ph1 /\ ph2) ]]$.
    It is immediate that for any value $v$ such that $[[ [R][v/nu](ph1 /\ ph2) ]]$, we must have $[[ [R][v / nu]ph1 ]]$ and $[[ [R][v / nu]ph2 ]]$.
    We then conclude $[[ SATv(H, R, Rv, T1+T2) ]]$ implies $[[ SATv(H, R, Rv, T1) /\ SATv(H, R, Rv, T2) ]]$.
  \end{rncase}

  \begin{rncase}{Tadd-Ref}
    Immediate from the definition of $[[SATv]]$ and the inductive hypothesis.
  \end{rncase}
\end{proof}

%% UPDATES AND EXTENSION

\begin{definition}
  The valid substitution relation, written $[[R |- T ]]$ is the smallest relation closed
  under the following rules:
  \infrule[]{
    [[ forall x in FPV(ph) \ { nu }.exists nn.R(x) = nn ]]
  }{
    [[R |- {nu:int|ph}]]
  }
  \infrule[]{
    [[ R |- T ]]
  }{
   [[ R |- T ref r ]]
 }
 \AI{Using $\sigma$, which is a metavariable, as a subscript may suggest that
 the judgment is parameterized by $\sigma$, which is not the case here.}
\end{definition}

\begin{lemma} % L4
  \label{lem:r-valid-subst}
  If $[[ ll |- G]]$ and $[[ Cons(H,R,G) ]]$, then $[[forall x in dom G.R |- G(x) ]]$.
\end{lemma}
\begin{proof}
  By $[[ Cons(H,R,G) ]]$, all integer variables in $[[G]]$ must be in
  the domain of $[[R]]$ and must be an integer. From $[[ ll |- G ]]$, any free variables
  in any refinement of any type in $[[G]]$ must be an integer valued variable in $[[G]]$,
  which gives the required result.
\end{proof}

\begin{definition}
  We will write $[[R < R']]$ to denote two register files such that:
  \begin{enumerate}
  \item $[[ dom R]] \subseteq [[ dom R' ]]$, and
  \item $[[ forall x in R.R(x) = R'(x) ]]$
  \end{enumerate}
\end{definition}

\begin{definition}
  Two heaps $[[H]]$ and $[[H']]$ are \emph{equivalent modulo $[[a]]$}, written $[[H ~ a H']]$ if:
  \begin{enumerate}
  \item $[[dom H = dom H']]$
  \item $[[forall a' in dom H.a' != a ==> H(a) = H(a')]]$
  \item For any $[[nn]]$, $[[ H |- a ~> nn]]$ iff $[[H' |- a ~> nn ]]$
  \end{enumerate}
\end{definition}

\begin{lemma}
  \label{lem:top-type-empty-omap}
  For any type $[[ T = topn ]]$, $[[H]], [[v]]$, $[[own(H, v, topn) = empty ]]$.
\end{lemma}
\begin{proof}
  By induction on $[[T]]$. In the base case, the result is trivial.
  Then consider the case where $[[ T = topn-1 ref 0]]$. If $[[ v not in Addr ]]$,
  or if $[[ v = a ]]$ and $[[ a not in dom H ]]$, then the result trivially holds.
  Otherwise the result holds from the inductive hypothesis, the definition of $+$ and $[[{ a |-> 0 }]]$.
\end{proof}

\begin{lemma}[Heap Update Ownership Preservation] % L6
  \label{lem:heapop}
  If $[[H ~ a H']]$ and $[[own(H,v,T)(a) = 0]]$, then
  $[[own(H,v,T) = own(H',v,T)]]$.
\end{lemma}
\begin{proof}
  By induction on the shape of $[[T]]$. If $[[T = {nu:int |ph}]]$ then
  the result trivially holds. Otherwise, $[[T = T' ref r]]$. We assume
  that $[[v = a'']]$ and $[[a'' in H]]$ (otherwise the result
  trivially holds, as $[[ dom H = dom H' ]]$ by $[[ H ~ a H']]$).
  Consider the case where $[[a'' = a]]$. By definition
  $[[own(H,a,T) = {a |-> r} + own(H,H(a),T')]]$, and by the
  assumption that $[[own(H,a,T)(a) = 0]]$ we must have that
  $[[r = 0]]$. Further, by the ownership well-formedness of types,
  we must have $[[ T' = topn ]]$ for some $n$, thus by \Cref{lem:top-type-empty-omap}
  we have $[[own(H,v,T) = empty = { a |-> 0 } + own(H',H'(a), topn) = own(H',v,T)]]$.

  Finally, consider the case where $[[a'' != a]]$. Then from the
  definition of $[[own(H,a'',T)]]$ and our assumption that
  $[[own(H,a'',T)(a) = 0]]$, we have $[[own(H,H(a''),T')(a) = 0]]$,
  and the result holds from the inductive hypothesis.
\end{proof}

\begin{lemma}
  \label{lem:sat-implies-shape-cons}
  For any $[[H]]$, $[[R]]$, $[[v]]$, and $[[T]]$, if $[[ SATv(H, R, v, T) ]]$ then $[[ H |- v ~> |T| ]]$
\end{lemma}
\begin{proof}
  By induction on $[[T]]$ and the definition of $[[SATv]]$.
\end{proof}

\begin{lemma} % L7
  \label{lem:top-type-sat-all}
  For any $[[nn]]$, if $[[H |- Rv ~> nn]]$ then for any $[[R]]$, $[[ SATv(H,R,v,topn) ]]$.
\end{lemma}
\begin{proof}
  By induction on $[[nn]]$. In the base case, by inversion on $[[ H |- v ~> 0]]$ we have
  $[[v is INT]]$ and as $[[ [R][v/nu]Top ==> Top ]]$, we conclude $[[ SATv(H,R,v,top0) ]]$.

  For $[[ nn ]] > 0$, by inversion on $[[ H |- Rv ~> nn ]]$ we have that
  $[[v = a]]$, $[[ a in dom H]]$, and $[[ H |- H(a) ~> nn-1]]$,
  whereby the result holds from the inductive hypothesis.
\end{proof}
  
\begin{lemma}[Heap Update Consistency Preservation] % L8
  \label{lem:heapfor0}
  If $[[H ~ a H']]$ and $[[own(H,v,T)(a) = 0]]$ and $[[SATv(H,R,v,T)]]$, then $[[SATv(H',R,v,T)]]$.
\end{lemma}
\begin{proof}
  By induction on the shape of $[[T]]$. The base case where
  $[[T = {nu:int|ph}]]$ is trivial. We therefore consider the case
  where $[[v = a']]$ and $[[T = T' ref r]]$.

  We first consider the case where $[[a' = a]]$, then by
  our assumption that $[[own(H,a,T)(a) = 0]]$, we must have that
  $[[ T = T' ref 0 ]]$, whereby the $[[ T = topn ]]$ for some $[[n]]$.
  From $[[SATv(H,R,a,T)]]$ and \Cref{lem:sat-implies-shape-cons}, we must have that
  $[[ H |- a ~> |T|]]$,
  and from $[[H ~ a H']]$, we therefore have that $[[ H' |- a ~> |T|]]$
  whereby the result holds from \Cref{lem:top-type-sat-all}.

  Otherwise, we have that $[[a' != a]]$, and by definition we must have that
  $[[own(H,H(a),T')(a) = 0]]$ and $[[H'(a) = H(a)]]$ hence the result follows
  from the inductive hypothesis.
\end{proof}

\begin{lemma}[Register Weakening] % L5 
  \label{lem:register}
  If $[[ SATv(H, R, Rv, T) ]]$ and $[[R |- T]]$,
  then for any $[[R']]$ such that $[[ R < R' ]]$, $[[ SATv(H, R', Rv, T)]]$.
\end{lemma}
\begin{proof}
  By induction on the shape of $[[T]]$. If $[[ T = T' ref r ]]$, then
  the result follows from the inductive hypothesis.
  We therefore consider the case where
  $[[ T = {nu: int | ph} ]]$. Without loss of generality, we consider
  the case where $[[ dom R' ]] \setminus [[ dom R ]] = \set{x}$,
  and $[[R'(x) = nn]]$. (If $[[R'(x) = a]]$, the extra binding
  also has no effect, and the case where more than one binding is
  added follows from $n$ applications of the following argument.)

  From $[[SATv(H,R,Rv,T)]]$, we conclude that $[[Rv is INT]]$ and that
  $[[ [R][Rv/nu]ph ]]$. If $[[x not in FPV(ph)]]$ then $[[ [R][Rv/nu]ph <=> [R'][Rv/nu]ph ]]$
  and the result holds trivially. Otherwise, if $[[x in FPV(ph)]]$ and $[[x not in R]]$
  then $[[R]]$ is not a valid substitution, violating our assumption.
\end{proof}

\begin{lemma}[Heap Extension Consistency Preservation] % L9
  \label{lem:newaddheap}
  If we have heap $H$, such that $[[ SATv(H,R,v,T) ]]$. For any heap $H'$,
  $[[ H' = H{a |-> v'}]], [[a not in H]]$, then we have $[[ SATv(H', R, v, T) ]]$.
\end{lemma}
\begin{proof}
  By induction on the shape of $[[ T ]]$.
  The base case where $[[T = {nu:int|ph}]]$ is trivial.
  Next, we consider the case where $[[T = T' ref r]]$.
  We must show that $[[v in dom H' /\ SATv(H',R, H'(v),T') ]]$.
  The first condition is immeidately satisfied by inversion on $[[ SATv(H,R,v,T') ]]$,
  and from $[[a not in H]]$, we have $v\neq a$, which gives that $H'(v)=H(v)$.
  That is we must show $[[ SATv(H',R, H(v),T') ]]$, which is follows from
  the induction hypothesis.
\end{proof}

\begin{lemma}[Heap Extension Ownership Preservation]
  \label{lem:ownaddheap}
  If $[[ SATv(H, R, v, T) ]]$, then for any $[[ a not in dom H ]]$
  $[[ own(H, v, T) = own(H { a |-> v' }, v, T) ]]$ for any value $[[ v' ]]$.
\end{lemma}
\begin{proof}
  By induction on $[[ T ]]$. The base case is trivial as $[[ own(H, v, {nu:int|ph}) = empty = own(H { a |-> v }, v, {nu:int|ph}) ]]$.
  We therefore consider the case where $[[ T = T' ref r ]]$.

  From $[[ SATv(H, R, v, T) ]]$ we must have that $[[ v = a' ]]$ and
  $[[ a' in dom H ]]$ (and by extension $[[ a' in dom H { a |-> v' } ]]$).
  From the definition of the ownership function, we have that $[[ own(H, v, T) = own(H, H(a), T') + { a' |-> r } ]]$.
  and $[[ own(H { a |-> v' }, v, T) = own(H { a |-> v' }, H { a |-> v' }(a'), T') + { a' |-> r } ]]$
  Then from our requirement that  $[[ a not in dom H ]]$, we have $[[ a != a' ]]$ and therefore
  $[[ H(a') = H{ a |-> v' } (a') ]]$, whereby the result holds from the inductive hypothesis.
\end{proof}

\begin{lemma}[Environment Weakening] % L27
  \label{lem:tyenv-weaken}
  \AI{Haven't really checked the proof (yet).  The statement is similar to
  \Cref{lem:subtype-transitive}; I'm wondering if we can merge...}
  Define the partial operation $[[G1 + G2]]$ for two environments such $[[dom G1 /\ dom G2 = null]]$:
  \[
    [[(G1 + G2)(x)]] = \begin{cases}
      [[G1(x)]] & [[ x in dom G1 ]] \\
      [[G2(x)]] & [[ x in dom G2 ]] \\
      \textit{undef} & o.w.
    \end{cases}
  \]
  
  Then, for any $[[G]]$ and $[[ G'' ]]$ where $[[ dom G /\ dom G'' = null ]]$:
  \begin{enumerate}
  \item $[[ G |- T1 <: T2]]$ implies $[[ G + G'' |- T1 <: T2 ]]$
  \item $[[G <: G']]$ implies $[[ G + G'' <: G' + G'']]$
  \item If $[[ Th | G | B |- e : T => G' ]]$, $[[ B |- G + G' ]]$ and $[[ B |- G' + G'']]$, then $[[ Th | G + G'' | B |- e : T => G'' + G]]$
  \end{enumerate}
\end{lemma}
\begin{proof}
  \leavevmode
  \begin{enumerate}
  \item As in the proof of \subref{lem:ctxt-substitution}{itm:ctxt-sub-subtype}, at the root of
    the subtyping derivation is a logical judgment of the form
    $[[ |= [ G ] /\ ph1 ==> ph2 ]]$ which can be shown to be valid. We
    must then show that $[[ |= [ G + G'' ] /\ ph1 ==> ph2 ]]$ is valid. As
    $[[ [ G'' + G] /\ ph1 = [G''] /\ [G] /\ ph ]]$ only strengthens the pre-condition
    $[[ [ G ] /\ ph1 ]]$, $[[ |= [ G''  + G] /\ ph1 ==> ph2 ]]$ must
    also be valid.
  \item It suffices to show that $[[G + G'' |- (G + G'')(x) <: (G' + G'')(x)]]$ for
    any arbitrary $[[x in dom G' + G'' ]]$. If $[[x in G']]$ then by we must have
    $[[ G |- G(x) <: G'(x) ]]$ by inversion on $[[ G <: G' ]]$,
    whereby $[[ G + G'' |- (G + G'')(x) = G(x) <: G' + G''(x) = G'(x) ]]$ from part 1.

    If $[[ x not in G' ]]$, then we must show $[[(G + G'') |- G''(x) <: G''(x)]]$, which trivially holds.
  \item By straightforward induction on the typing derivation of
    $[[ Th | G | B |- e : T => G' ]]$. We assume that the variables bound in
    any let expressions that appear within $[[e]]$ are not in the domain
    of $[[G'']]$; this requirement can be easily enforced with
    consistent renaming. The only interesting cases are
    \rn{T-Sub} and \rn{T-Assert} and the let bindings;
    the other cases follow from the induction hypothesis.
    
    We now prove the relevant cases.

    \begin{rneqncase}{T-Let}{
        [[ Th | G | B |- let x = y in e : T => G' ]] \\
        [[ Th | G[y <- T1 /\ y y = T1 x],x: T2 /\ x x = T2 y | B |- e : T => G' ]] \\
        [[ G(y) = T1 + T2 ]] \andalso [[ x not in dom G' ]] \andalso [[ B |- T => G' ]]
      }
      We assume that the variable $[[x]]$ is not in the domain of $[[ G'' ]]$,
      this requirement can be enforced with consistent renaming if necessary.

      Let $[[ G''' = G'' + G[y <- T1 /\ y y = T1 x],x: T2 /\ x x = T2 y ]]$.
      To use the inductive hypothesis, we must show that
      $[[ B |- G''' ]]$ and $[[ B |- G' + G'' ]]$. The latter follows from the
      assumed well-formedness of $[[ B |- G' + G'' ]]$. To show the former, it suffices
      to show $[[ G''' | B |- T1 /\ y y = T1 x ]]$ and $[[ G''' | B |- T2 /\ x x = T2 y ]]$.
      From the assumed well-formedness $[[ B |- G + G'' ]]$, we must have $[[ G + G'' | B |- T1 + T2 ]]$,
      and in particular $[[ G + G'' | B |- T1 ]]$ and $[[ G + G'' | B |- T2 ]]$. From this
      we conclude both conditions hold. To show the well-typing of the overall let expression,
      we must show $[[ x not in dom G' + G'']]$, which follows from our assumption and $[[ x not in dom G' ]]$.
      Finally, we must also show that $[[ G' + G'' | B |- T]]$. From $[[ G' | B |- T ]]$
      and the fact that$[[ forall x in dom G'.ST(G')(x) = ST(G' + G'')(x) ]]$, we must have
      $[[ G' + G'' | B  |- T ]]$. 
    \end{rneqncase}
    \begin{namedcase}{\casefont{Cases \rn{T-LetInt}, \rn{T-Mkref}, \rn{T-Mkref}, \rn{T-Deref}, \rn{T-Call}: }}
      Similar to the reasoning in \rn{T-Let}.
    \end{namedcase}

    \begin{rneqncase}{T-Sub}{
        [[ G <: G3 ]] & [[ Th | G3 | B |- e : T2 => G4 ]] \\
        [[ G4,T2 <: G',T ]] & [[ B |- G3 ]] \\
        [[ B |- T => G' ]]
      }
      From the rules for subtyping, we must have
      $[[ dom G3 <= dom G ]]$ and $[[ dom G' <= dom G4 ]]$. A simple inductive argument
      gives that $[[ dom G4 <= dom G3 ]]$, therefore we have $[[ dom G' <= dom G3 ]]$.
      Let $\mathcal{LV}$ be the set of free variables in the refinements of $[[G'']]$
      that are not in the domain of $[[G'']]$. From the assumed well-formedness of
      $[[ B |- G' + G'' ]]$, we must have that
      $\forall x \in \mathcal{LV}.[[x in dom G' /\ [S G'(x) ] = int ]]$. Thus,
      $\mathcal{LV} \subseteq [[G3]]$ and $\mathcal{LV} \subseteq [[G4]]$. Further, by definition,
    for any $[[ Gp <: Gq ]]$, then $[[forall x in dom Gp. [S Gp(x)] = [S Gq(x)] ]]$.
    We conclude that $[[ B |- G3 + G'' ]]$ and
      $[[ B |- G4 + G'']]$, whereby the inductive hypothesis gives
      $[[ Th | G3 + G'' | B |- e : T2 => G4 + G'' ]]$. To prove the overall result, we must
      show that $[[ G + G'' <: G3 + G'' ]]$ and $[[ G4 + G'',T2 <: G' + G'',T ]]$
      which follow from parts 1 and 2 above.
    \end{rneqncase}
    \begin{rncase}{T-Assert}
      We must show that $[[ |= [G'' + G] ==> ph ]]$ which is equivalent to
      $[[ |= [G''] /\ [G] ==> ph ]]$. As the source term was well typed,
      $[[ |= [G] ==> ph ]]$ is valid, we must then have $[[ |= [G''] /\ [G] ==> ph ]]$
      whereby the inductive hypothesis gives the required result.
    \end{rncase}
  \end{enumerate}
\end{proof}

\section{Proof of \Cref{lem:preservation}}
\label{sec:preservation-proof}

We first prove two additional lemmas. 
\Cref{lem:stack-well-typed,lem:callfunc} give key facts used in the return and
call cases respectively; we have separated them into separate lemmas for clarity.

\begin{lemma} % L25
  \label{lem:stack-well-typed}
  For any $[[G0]]$ such that $[[Th | G0 | l:ll |- x: T1 => G1]]$ and $[[ Th | [] : T1 => G1 | ll |-e E[let y = [] l in e] : T2 => G2 ]]$ then
  $[[ Th | G0 | ll |- E[let y = [] l in e][x] : T2 => G2 ]]$.
\end{lemma}
\begin{proof}
  It suffices to show that $[[ Th | G0 | ll |- let y = x in e : T1' => G1']]$
  and $[[ Th | [] : T1' => G1' | ll |-e E : T2 => G2 ]]$ for some $[[ T1' ]]$ and $[[ G1' ]]$
  whence the result will hold from \Cref{lem:ectxt-sub-well-typed}.

  By inversion on
  $[[ Th | [] : T1 => G1 | ll |-e E[let y = [] l in e] : T2 => G2 ]]$ we have
  \begin{align}
    & [[ Th | G1, y: T1 | ll |- e : T1'' => G1'' ]] \label{eqn:let-body-ty} \\
    & [[ Th | []: T1'' => G1'' | B |-e E : T2 => G2 ]] \label{eqn:ctxt-typed} \\
    & [[ ll |- T1'' => G1'' ]] \label{eqn:t2g2-wf} \\
    & [[ y not in dom G1'' ]] \label{eqn:y-not-free-var}
  \end{align}
  We take $[[ G1' = G1'' ]]$, $[[ T1' = T1'' ]]$, and then \Cref{eqn:ctxt-typed}
  gives the necessary typing for $[[E]]$.

  It remains to to show that
  \[
    [[ Th | G0 | ll |- let y = x in e : T1' => G1' ]]
  \]
  
  By \Cref{lem:inversion}, from $[[ Th | G0 | l:ll |- x : T1 => G1 ]]$ we conclude there
  exists some $[[Gp]]$, $[[Tp]]$, and $[[Gp']]$ such:
  \begin{align}
    & [[G0 <: Gp]] \label{eqn:rin-sub} \\
    & [[Gp',Tp <: G1,T1]] \label{eqn:rout-sub} \\
    & [[Gp' = Gp[x <- Tp'] ]] \label{eqn:gp-up-def} \\
    & [[Gp(x) = Tp + Tp' ]] \label{eqn:gp-x-def} \\
    & [[ ll |- Gp ]] \label{eqn:renv-sub-in-wf} \\
    & [[ ll |- T1 => G1 ]] \label{eqn:rout-env-wf}
  \end{align} 

  We first apply \rn{T-Sub} with \Cref{eqn:rin-sub,eqn:renv-sub-in-wf}, so it remains to show
  \[
    [[ Th | Gp[x: Tp + Tp'] | ll |- let y = x in e : T1' => G1' ]]
  \]
  which, by \rn{T-Let} holds if we show that:
  \[
    [[ Th | Gp[x <- Tp' /\ x x = Tp' y],y: Tp /\ y y = Tp x | ll |- e : T1' => G1' ]]
  \]
  ($[[ y not in dom G1' ]]$ follows from \Cref{eqn:y-not-free-var},
  and $[[ ll |- T1' => G1']]$ follows from \Cref{eqn:t2g2-wf}.)
    
  We can first apply \rn{T-Sub} to weaken the type environment to:
  \[
    [[ Th | Gp[x <- Tp'],y: Tp | ll |- e : T1' => G1' ]]
  \]
  From \Cref{eqn:rout-sub} above, we have that $[[ Gp[x <- Tp'],y : Tp <: G1,y:T1 ]]$,
  whereby one final application of \rn{T-Sub} with \Cref{eqn:rout-env-wf}
  allows us to use to \Cref{eqn:let-body-ty} above.
\end{proof}

\begin{lemma} % L28
  \label{lem:callfunc}
  Let $[[ E[let x = f l (y1,,yn) in e'] ]]$ be a term such that:
  
  \begin{bcpcasearray}
    [[ Th | G0 | ll |- let x = f l (y1,,yn) in e' : T1 => G1 ]] &  [[ csub = [l:ll/A] ]] \\
    [[ Th | [] : T1 => G1 | ll |-e E : T2 => G2 ]] & [[ vsub = [y1/x1],,[yn/xn] ]] \\
    [[ f |-> ( x1, .. ,xn) e in D]] & [[ Th |- f |-> (x1,..,xn) e ]] \\
    [[ ll |- G0 ]] &  [[ |- Th ]]
  \end{bcpcasearray}

  where $[[Th(f) = A < x1 : T1 ,, xn: Tn> -> <x1: T1',,xn:Tn' | Tq >]]$.

  Then there exist some $[[T3]]$ and $[[G3]]$:
  \begin{align*}
    & [[ Th | G0 | l:ll |- vsub e : T3 => G3 ]] \\
    & [[ Th | [] : T3 => G3 | ll |-e E[let x = [] l in e] : T2 => G2 ]]
  \end{align*}
\end{lemma}
\begin{proof}
  From \Cref{lem:inversion} on
  $[[ Th | G0 | ll |- let x = f l (y1,,yn) in e' : T1 => G1 ]]$ we have, for some
  $[[ Gp ]], [[Tp]], [[Gp']]$, that:
  \begin{align}
    & [[ G0 <: Gp ]] \label{eqn:in-sub} \\
    & [[ Gp',Tp <: G1,T1 ]] \label{eqn:out-sub} \\
    & [[ Gp(yi) = csub vsub Ti ]] \label{eqn:arg-typed} \\
    & [[ ll |- Gp ]] \label{eqn:sub-in-env-wf} \\
    & [[ Th | Gp[yi <- csub vsub Ti'],x: csub vsub Tq | ll |- e' : Tp => Gp' ]] \label{eqn:let-body-well-typed} \\
    & [[ x not in dom Gp' ]] \label{eqn:cbind-erased}\\
    & [[ ll |- T1 => G1 ]] \label{eqn:out-type-wf}
  \end{align}
  
  To prove the first part, from the well-typing of the function body, we have
  $[[ Th | x1:T1,,xn:Tn | A |- e : Tq => x1:T1',,xn:Tn' ]]$.
  From our assumption that all variable names are distinct,
  by $n$ applications of the substituion lemma (\Cref{lem:substitution}) we have:
  $[[ Th | y1:vsub T1,,yn:vsub Tn | A |- vsub e : vsub Tq => y1:vsub T1',,yn:vsub Tn']]$.
  By \subref{lem:ctxt-substitution}{itm:ctxt-subst-well-typed} we then have
  $[[ Th | y1:csub vsub T1,,yn:csub vsub Tn | l:ll |- vsub e : csub vsub Tq => y1:csub vsub T1',,yn:csub vsub Tn']]$.
  We take $[[T3 = csub vsub Tq ]]$ and $[[ G3 = Gp[yi <- csub vsub Ti'] ]]$.
  
  By the well-formedness of function types and well-formedness of $[[ Gp ]]$,
  we must have that $[[ l:ll |- G3 ]]$.
  Then by \Cref{eqn:arg-typed,eqn:sub-in-env-wf,lem:tyenv-weaken} we have
  $[[ Th | Gp | l:ll |- vsub e : T3 => G3 ]]$, whereby \Cref{eqn:in-sub,eqn:sub-in-env-wf}
  and an application of \rn{T-Sub}
  gives $[[ Th | G0 | l:ll |- vsub e : T3 => G3 ]]$, i.e., the first result.

  To prove the second part, from the typing rule for \rn{TE-Stack} we must show:
  \begin{align}
    & [[ Th | [] : T1 => G1 | ll |-e E : T2 => G2]] \label{eqn:context-well-typed} \\
    & [[ ll |- T1 => G1 ]] \label{eqn:t1g1-wf} \\
    & [[ x not in dom G1 ]] \label{eqn:x-not-free} \\
    & [[ Th | G3, x: T3 | ll |- e' : T1 => G1 ]] \label{eqn:let-body-sub-typed}
  \end{align}
  \Cref{eqn:context-well-typed} holds by assumption, \Cref{eqn:t1g1-wf} follows
  from the inversion lemma above, and \Cref{eqn:x-not-free} follows from \Cref{eqn:cbind-erased} and that $[[ Gp' <: G1 ]]$ implies
  $[[ dom G1 <= dom Gp' ]]$.
  From \Cref{eqn:out-sub,eqn:let-body-well-typed,eqn:out-type-wf} we then have \Cref{eqn:let-body-sub-typed} via an application of \rn{T-Sub}.
\end{proof}

\begin{proof}[\Cref{lem:preservation}]
  The proof is organized by cases analysis on the transition rule used of $[[e]]$, and showing that the output configuration is well typed by
  $[[ |-D ]]$, and for that we must find a $[[G'']]$ that is consistent with $[[H']]$ and $[[R']]$ and also satisfies the other conditions imposed by
  the definition of $[[ |-D ]]$. Here $[[G'']],[[H']], [[R']]$ represent the type environment, heap and register after the transition respectively.
  We identify the heap and register file before transition with $[[H]]$ and $[[R]]$ respectively.
  In order to show that the ownership invariant is preserved, we need to prove that $[[ forall a in H .Own(H,R,G'')(a) <= 1]]$.
  In many cases, we will show that $[[ Own(H, R, G) = Own(H', R', G'') ]]$, whereby
  from the assumption that $[[ forall a in H.Own(H, R, G)(a) <= 1 ]]$ we will
  then have the desired result.
  % FIXED
  \begin{rneqncase}{R-Var}{
    [[ |- D <H, R, CEn-1 : Es, x>]], [[<H, R, CEn-1 : Es, x> --> D <H, R, Es, CEn-1[x]> ]] \\
  }
  By the Inversion on configuration typing $[[ |- D <H, R, CEn-1 : Es, x>]]$, we have:
    \begin{align*}
      & [[ Th | G | ll |- x : Tn => Gn ]] \\
      & \forall i\in\set{1..n}.[[ Th | [] : Ti => Gi | lli-1 |-e CEi-1 : Ti-1 => Gi-1 ]]
    \end{align*}
    
    Using \Cref{lem:stack-well-typed}, we can conclude that $[[ Th | G | lln-1 |- CEn-1[x] : Tn-1 => Gn-1 ]]$. We therefore take $[[ G'' = G ]]$.

    It remains to show that $[[Cons(H,R,G'')]]$ and $[[ lln-1 |- G ]]$, which follows
    immediately from $[[Cons(H,R,G)]]$ and $[[ ll |- G ]]$.
  \end{rneqncase}

  % FIXED
  \begin{rneqncase}{R-Deref}{
      [[ |- D <H, R, Es, E[let x = *y in e]>]] \\
      [[<H, R, Es, E[let x = *y in e]> --> D <H, R { x' |-> v }, Es, E[ [x'/x]e]> ]] \\
      [[ H(a) = v ]] \andalso [[ R(y) = a ]] \andalso [[R' = R { x' |-> v}]]\\
    }
    By inversion on the configuration typing relationship, we have that:
    \begin{align*}
      [[ ll |- G0 ]] && [[ Th | G0 | ll |- E[let x = *y in e] : Tn => Gn ]] \\
      [[ Cons(H,R,G0) ]] &&
    \end{align*}
    By \Cref{lem:stack_var}, we have some $[[T]], [[G0']]$ such that:
    \begin{align*}
      [[ Th | []: T => G0' | ll |-e E : Tn => Gn ]] && [[ Th | G0 | ll |- let x = *y in e : T => G0' ]]
    \end{align*}
    Using \Cref{lem:inversion}, we have some $[[Gp]]$, $[[Gp']]$ and $[[Tp]]$ such
    that:
    
    \begin{bcpcasearray}
      [[ G0 <: Gp ]] \andalso [[ ll |- Gp ]] \andalso [[ Gp',Tp <: G0',T ]] \andalso [[ ll |- T => G0' ]] \\
      [[ Gp(y) = (T1 + T2) ref r ]] \andalso [[ x not in Gp' ]] \\
      [[ Th | Gp[y <- T'' ref r], x : T2 | B |- e : Tp => Gp' ]]  \\
      [[T'' ]] = \begin{cases}
        [[(T1 /\ y y = T1 x)]] & [[ r > 0 ]] \\
        [[T1]] & [[r = 0]]
      \end{cases}
    \end{bcpcasearray}
    
    From \Cref{lem:subtyp-preserves-cons}, we then have $[[Cons(H,R,Gp)]]$.
    We will now show that:
    \begin{align}
      \label{eqn:new-tyenv-cons} & [[Cons(H,R { x' |-> v },G'')]] \\
      \label{eqn:new-tyenv-wf}  & [[ll |- G'']] \\
      & [[Th | G'' | ll |- [x'/x]e : [x'/x]Tp => [x'/x]Gp' ]]
    \end{align}
    where $[[ G'' = Gp[y <- T'' ref r], x' : T2]]$.

    From $[[Th | G'' | ll |- [x'/x]e : [x'/x]Tp => [x'/x]Gp' ]]$ we can
    derive $[[ Th | G'' | ll |- [x'/x]e : T => G0' ]]$.
    From $[[ x not in Gp' ]]$ and $[[ ll |- Tp => Gp' ]]$, we have that
    $[[ [x'/x]Tp = Tp ]]$ and $[[ [x'/x]Gp' = Gp' ]]$. As $[[ Gp',Tp <: G0',T ]]$
    and $[[ ll |- T => G0' ]]$, an application of \rn{T-Sub} gives
    $[[ Th | G'' | ll |- [x'/x]e : T => G0' ]]$.
    
    As $[[E]]$ and the stack $[[Es]]$ remained unchanged, combined with
    \Cref{eqn:new-tyenv-cons,eqn:new-tyenv-wf} this gives
    $[[ |- D <H, R { x' |-> v }, Es, E[ [x'/x]e]> ]]$ as required.
    As the above argument is used almost completely unchanged
    in all of the following cases, we will invert the redex without regard
    for the \rn{T-Sub} rule, with the understanding that the subtyping rule
    is handled with an argument identical to the above.
    
    We now want to show $[[ Th | G'' | ll |- [x'/x]e : [x/x']Tp => [x'/x]G' ]]$,
    $[[ ll |- G'' ]]$, and $[[Cons(H,R { x' |-> v }, G'')]]$.
    The first is easy to obtain using \Cref{lem:substitution} (observe that by \Cref{lem:r-valid-subst} and our
    choice that $[[ x' not in dom R ]]$ we have $[[ x not in dom G ]]$), and the second
    follows almost immediately from $[[ ll |- G ]]$.
    
    It therefore remains to show $[[Cons(H,R { x' |-> v }, G'')]]$. To show that the output environment is consistent, it suffices to show that $[[ SATv(H,R',R'(x'),T2) ]]$
    and $[[SATv(H,R',H(R'(y)),T'') ]]$.
    If $[[ T1 ]]$ is an integer type and $[[r > 0]]$, then
    by the definition of the strengthening operator, the latter is equivalent to show
    that $[[ SATv(H,R',H(R'(y)),T1) ]]$
    and that $[[R'(x')=H(R'(y))=H(R(y))]]$, which is immediate from the definition of $\rn{R-Deref}$.
    If $[[ T1 ]]$ is not an integer or if $[[r = 0]]$,
    then we must only show that $[[ SATv(H,R',H(R'(y)),T1) ]]$.
    
    From $[[Cons(H,R,Gp)]]$, we know that $[[SAT(H,R,Gp)]]$, in particular, $[[SATv(H,R,R(y),Gp(y)) ]] $.
    From \Cref{lem:satadd,lem:r-valid-subst,lem:register} and that $[[ R < R' ]]$, we obtain from
    $[[ SATv(H,R,v,T1+T2)]]$ that $[[ SATv(H,R',v,T1)]]$ and $[[ SATv(H,R',v,T2) ]]$, where $[[v = H(R(y))]]$.
    We thus have that $[[ SATv(H,R',R'(x'),T2) ]]$ and $[[ SATv(H,R',H(R'(y)),T1) ]]$ are satisfied.
    
    We must also show that the ownership invariant is preserved.
    Then, it's to show $[[forall a in H.Own(H,R',G'')(a) <= 1]]$. Define $[[O0']]$ and $[[O1']]$ as follows:
    \begin{align*}
      [[Own(H, R, Gp)]] & = [[O0' + own(H,R(y),Gp(y))]] \\
      [[Own(H, R', G'')]] & =[[O1' + own(H,R'(y),G''(y)) + own(H,R'(x'),G''(x'))]] \\
      [[O0']] &  = [[ |< {z in dom G \ {y}} own(H,R(z),Gp(z))]] \\
      [[O1']] & = [[ |< {z in dom G'' \ {y,x'}} own(H,R'(z'),G''(z')) ]]
    \end{align*}
    By \Cref{lem:heapop}, $[[O0' = O1']]$ holds. Then, it suffices to show that
    $[[ own(H, R(y), Gp(y)) = own(H,R'(y),G''(y)) + own(H,R'(x'),G''(x')) ]]$.
    
    As $[[R'(x')=H(R'(y))=H(R(y))]]$ and from the definition of $[[ G'' ]]$, we have:
    \begin{align*}
      [[ own(H,R'(x'),G''(x')) & = own(H,H(R(y)),T2) ]] \\
      [[ own(H,R'(y),G''(y)) & = {a |-> r} + own(H,H(R(y)),T1) ]] \\
    \end{align*}
    From the definition of the ownership function, we have that
    \[
      [[ own(H,R(y),Gp(y)) = {a |-> r} + own(H,H(R(y)),T1+T2) ]]
    \]
    which, by \Cref{lem:ownadd}, is equivalent to:
    \[
      [[ {a |-> r} + own(H,H(R(y)),T1) + own(H,H(R(y)),T2) ]]
    \]
    We therefore have $[[own(H,R(y),G(y))=own(H,R'(y),G''(y))+ own(H,R'(x'),G''(x'))]]$, and conclude that $[[Own(H, R, G)=Own(H, R', G'')]]$.
  \end{rneqncase} % R-Deref

  \begin{rneqncase}{R-Seq}{
      [[ |- D <H, R, Es, E[x; e]> ]]\\
      [[ <H, R, Es, E[x; e]> --> D <H, R, Es, E[e]> ]]\\
    }
    By inversion (see \rn{R-Deref}) we have for some $[[G]]$ that:
    \begin{align*}
      & [[ Th | G[x : T0 + T1] | ll |- x : T0 => G[x <- T1] ]] \\
      & [[ Th | G[x <- T1] | ll |- e : T' => G' ]] \\
      & [[ Cons(H,R,G) ]] \andalso [[ ll |- G ]]
    \end{align*}
    We take $[[G'' = G[x <- T1] ]]$.
    
    It suffices to show (see \rn{R-Deref})
    that $[[ Th | G'' | ll |- e : T' => G']]$, $[[ ll |- G'' ]]$
    and $[[Cons(H,R, G'')]]$.
    The first is immediate from the inversion above, and $[[ ll |- G[x <- T1] ]]$
    follows from the assumed well-formedness of $[[ ll |- G ]]$. Finally,
    $[[ Cons(H, R, G'') ]]$ follows from \Cref{lem:ownadd,lem:satadd}.
  \end{rneqncase}

  % FIXED
  \begin{rneqncase}{R-Let}{
      [[ |- D <H, R, Es, E[let x = y in e]> ]]\\
      [[<H, R, Es, E[let x = y in e]> --> D <H, R { x' |-> R(y)}, Es, E[ [x'/x]e]> ]]\\
      [[ x' fresh in R ]] \andalso [[R'= R { x' |->  R(y) }]]
    }
    By inversion (see \rn{R-Deref}) we have that for some $[[G]]$ that:
    \begin{align*}
      & [[ G(y) = T1 + T2 ]] \\
      & [[ Th | G [ y <- T1 /\ y y = T1 x  ], x : (T2 /\ x x = T2 y) | ll |- e : T => G']] \\
      & [[Cons(H,R,G)]] \andalso [[ll |- G ]] \andalso [[ ll |- G' ]] \andalso [[ x not in G' ]]
    \end{align*}
    We give $[[G'' = G [ y <- T1 /\ y y = T1 x'  ], x' : (T2 /\ x' x' = T2 y)]]$.
    
    It suffices to show (see \rn{R-Deref})
    that $[[ Th | G'' | ll |- [x'/x]e : T => G' ]]$, $[[ ll |- G'']]$,
    and $[[Cons(H,R { x' |->  R(y) }, G'')]]$.
    The first is easy to obtain using reasoning as in the \rn{R-Deref} casse.
    The second follows from the assumed well-formedness of $[[ T1 ]]$ and $[[ T2 ]]$.
    It therefore remains to show $[[Cons(H,R',G'')]]$.
    
    To show that the output environment is consistent, we must show that $[[SATv(H,R',R'(x'),T2 /\ x' x' = y)]]$ and $[[SATv(H,R',R'(y),T1 /\ y y=x')]]$.
    By reasoning similar to that in $\rn{R-Deref}$, it suffices to show that $[[ SATv(H,R',R'(x'),T2) ]]$ and $[[ SATv(H,R',R'(y),T1) ]]$.
    We know that $[[Cons(H,R,G)]]$, from which me have $[[SAT(H,R,G)]]$, in particular $[[y in R]]$ and $[[SATv(H,R,R(y),G(y))]]$.
    As $[[ R < R']]$, from \Cref{lem:satadd} and \Cref{lem:register}, we obtain from $[[ SATv(H,R,v,T1+T2) ]]$ that
    $[[ SATv(H,R',v,T1)]]$ and $[[ SATv(H,R',v,T2) ]]$ where $v = R(y)$.
    We then have $[[ SATv(H,R',R'(x'),T2) ]]$ and $[[ SATv(H,R',R'(y),T1) ]]$ are satisfied.
    
    We must also show that the ownership invariant is preserved.
    Then, it's to show $[[forall a in H.Own(H,R',G'')(a) <= 1]]$. Define $[[O0']]$ and $[[O1']]$ as follows:
    \begin{align*}
    [[Own(H,R,G)]] & = [[O0' + own(H,R(y),G(y))]] \\ 
    [[Own(H, R', G'')]] & = [[O1' + own(H,R'(y),G''(y)) + own(H,R'(x'),G''(x'))]] \\
    [[O0']] & = [[ |< {z in dom G \ {y}} own(H,R(z),G(z)) ]] \\
    [[O1']] & = [[ |< {z in dom G'' \ {y,x'}} own(H,R'(z'),G''(z'))]]
    \end{align*}
    By \Cref{lem:heapop}, $[[O0' = O1']]$ holds.
    That $[[own(H,R'(x'),T2) + own(H,R'(y),T1) = own(H,R(y),T1+T2)]]$ follows immediately
    from \Cref{lem:ownadd} and the condition $[[R(y)=R'(x')=R'(y)]]$.
    We therefore conclude that $[[Own(H,R,G)=Own(H, R', G'')]]$.
  \end{rneqncase} % R-Let
 
  \begin{rneqncase}{R-LetInt}{ % FIXED
      [[ |- D <H, R, Es, E[let x = nn in e]>]]\\
      [[ <H, R, Es, E[let x = nn in e]> --> D <H, R { x' |-> nn }, Es, E[ [x'/x]e]> ]]
    }
    By inversion (see \rn{R-Deref}) we have that, for some $[[G]]$:
    \begin{align*}
      & [[ Th | G, x:{nu : int | nu = nn } | ll |- e : T => G']] \\
      & [[ Cons(H,R,G) ]] \andalso [[ ll |- G ]] \andalso [[ ll |- T => G' ]] \andalso [[ x not in dom G' ]]
    \end{align*}
    
    We give that $[[ G''= G,x':{nu:int | nu = nn}]]$, and it thus suffices to show
    that $[[ Th | G'' | ll |- [x'/x]e : T => G' ]]$, $[[ ll |- G'' ]]$,
    and $[[ Cons(H, R { x' |-> nn }, G'') ]]$.
    The first one is easy to obtain using the \Cref{lem:substitution} (see \rn{R-Deref}
    and the reasoning of \rn{R-Let} above, and the final two items are trivial.
  \end{rneqncase} % R-LetInt
  
  \begin{rneqncase}{R-IfTrue}{ % DONE
      [[ |- D <H, R, Es, E[ifz y then e1 else e2]>]]\\
      [[ <H, R, Es, E[ifz y then e1 else e2]> --> D <H, R, Es, E[e1]> ]]
    }
    By inversion (see \rn{R-Deref}) we have that for some $[[G]]$:
    \begin{align*}
      & [[ Th | G[x <- {nu:int | ph /\ nu = 0 }] | ll |- e1 : T => G' ]] \\
      & [[ Cons(H,R,G) /\ ll |- G /\  G(x) = {nu:int|ph} ]]
    \end{align*}
    We take $[[ G'' = G[x <- {nu:int | ph /\ nu = 0 }] ]]$, and want to show that $[[ Cons(H, R, G'') ]]$ (that $[[ Th | G'' | ll |- e1 : T => G' ]]$ and $[[ ll |- G'' ]]$ is immediate).
    
    By definition, from $[[Cons(H,R,G) ]]$ we have $[[ SAT(H,R,G) ]]$, in particular $[[ x in R ]]$, $[[ R(x) is INT ]]$ and $[[ [R][R(x)/nu]ph]]$,
    here $[[ G(x) = {nu:int | ph}]]$.
    The refinement predicates $[[ph]]$ still holds in the output environment, since nothing changes in the register after transition.
    Also from precondition of $\rn{R-IfTrue}$, we have $[[R(x)=0]]$, thus $[[x]]$ satisfies the refinement that $[[nu=0]]$.
    Thus $[[ [R][R(x)/nu](ph /\ nu = 0)]]$ is trivially satisfied.
  \end{rneqncase} %R-IfTrue
  
  \begin{rncase}{R-IfFalse} % FIXED
    Similar to the case for \rn{R-IfTrue}.
  \end{rncase}
  
  \begin{rneqncase}{R-MkRef}{ 
      [[ |- D <H, R, Es, E[let x = mkref y in e]>]]\\
      [[ <H, R, Es, E[let x = mkref y in e]> --> D <H', R', Es, E[ [x'/x]e]> ]]\\
      [[ a not in H ]] \andalso [[ x' not in R ]] \\
      [[H' = H { a |-> R(y) }]] \andalso [[ R' = R { x' |-> a }]]
    }
    By inversion (see \rn{R-Deref}) we have that for some $[[ G ]]$:
    \begin{align*}
      & [[ G(y) = T1 + T2 ]] \\
      & [[ Th | G[y <- T1],x : (T2 /\ x x = y) ref 1 | ll |- e : T => G' ]] \\
      & [[ Cons(H,R,G) ]] \andalso [[ ll |- G ]] \andalso [[ ll |- T => G' ]] \andalso [[ x not in dom G' ]]
    \end{align*}
    We give $[[ G'' = G[y <- T1],x' : (T2 /\ x' x' = y) ref 1 ]]$,
    and must show that $[[ Th | G'' | ll |- [x'/x]e : T => G' ]]$, $[[ ll |- G'' ]]$ and
    $[[ Cons(H', R', G'') ]]$. The first follows
    from \Cref{lem:substitution} and the reasoning found in \rn{R-Let},
    and the second from the assumed well-formedness of $[[T1 + T2 ]]$.
    
    It remains to show $[[Cons(H',R',G'')]]$.
    To show that the output environment is consistent, we must show that $[[SATv(H',R',R'(x'),(T2 /\ x' x'=y) ref 1)]]$ and $[[ SATv(H',R',R'(y),T1) ]]$.
    By reasoning similar to that in $\rn{R-Deref}$, it suffices to show that $[[ SATv(H',R',R'(x'),T2 ref 1) ]]$ and $[[ SATv(H',R',R'(y),T1) ]]$.
    We know that $[[Cons(H,R,G)]]$, from which we have $[[ SAT(H,R,G) ]]$, in particular $[[ y in R]]$ and $[[ SATv(H,R,R(y),G(y)) ]] $.
    As $[[ R < R' ]]$, from \Cref{lem:register}, we have $[[ SATv(H,R,R(y),T1+T2) ]]$ implies $[[ SATv(H,R',R'(y),T1+T2) ]]$.
    By \Cref{lem:newaddheap}, we then have $[[ SATv(H',R',R(y),T1+T2) ]]$.
    Then by \Cref{lem:satadd}, we have $[[ SATv(H',R',v,T1)]]$ and $[[SATv(H',R',v,T2) ]]$ where $[[v = R(y)]]$.
    We then have $[[ SATv(H',R',R'(x'),T2 ref 1) ]]$ and $[[ SATv(H',R',R'(y),T1) ]]$ are satisfied.
    
    We must also show that the ownership invariant is preserved.
    Then, it's to show $[[forall a' in H.Own(H',R',G'')(a') <= 1]]$. From $[[ Cons(H, R, G) ]]$ and \Cref{lem:ownaddheap,lem:ownadd} we have:
    \begin{align*}
      [[Own(H', R', G'')]] & = [[|< {z in dom G''} own(H',R'(z),G''(z))]] \\
             & = [[ |< {z in dom G} own(H,R(z),G(z)) + {a |->  1}]] \\
             & = [[Own(H, R, G) + {a |-> 1}]]
    \end{align*}

    Since $[[a not in H]]$ and $[[forall a' in H.Own(H,R,G)(a') <= 1]]$,
    we have $[[forall a' in H.Own(H',R',G'')(a') <= 1]]$.  \AI{Right?  Then, the following paragraph is not needed.}

    We want to show that $[[forall a in H'.Own(H', R', G'')(a) <= 1]]$.
    Suppose $[[a != a']]$ (that is $[[a in H]]$): we have $[[Own(H, R, G)(a)= Own(H', R', G'')(a)]]$ and thus $[[Own(H', R', G'')(a) <= 1]]$ by $[[Cons(H,R,G)]].$
    Next, suppose $a=a'$; we have $[[Own(H',R',G'')(a)=1]]$ only if $[[a' not in Own(H,R,G)]]$;
    this requirement immediately holds from $[[a' not in H]]$ by the definition of
    $[[own(H,v,T)]]$. \JT{We have been a little sloppy with our definition of + on
      these ownership functions so the domains of these functions is a little unclear.}
  \end{rneqncase} % R-MkRef

  \begin{rneqncase}{R-Assign}{ % FIXED
      [[ |- D <H, R, Es, E[y:=x;e]>]]\\
      [[ <H, R, Es, E[y:=x;e]> --> D <H', R', Es, E[e]> ]] \\
      [[a = R(y)]] \andalso [[ H' = H { a <- R(x)} ]] \andalso [[R' = R]]
    }
    By inversion (see the \rn{R-Deref} case) we have that
    \begin{align*}
      & [[ Th | G[x: T1 + T2][y : T' ref 1] | ll |- y := x; e : T => G']] \\
      & [[ Th | G[x <- T1][y <- (T2 /\ y y = T2 x) ref 1] | ll |- e : T => G']] \\
      & [[Cons(H,R,G) ]] \andalso [[ ll |- G ]]
    \end{align*}
    We give $[[ G'' = G[x <- T1][y <- (T2 /\ y y = T2 x) ref 1] ]]$. That
    $[[ Th | G'' | ll |- e : T => G' ]]$ and $[[ ll |- G'' ]]$ is immediate.
    
    We must therefore show that $[[ Cons(H',R',G'')]]$.
    To show that the output environment is consistent, we must show that $[[SATv(H',R,R(y),(T2 /\ y y = x) ref 1)]]$ and $[[ SATv(H',R,R(x),T1) ]]$.
    By reasoning similar to that in $\rn{R-Deref}$, it suffices to show that $[[ SATv(H',R,R(y),T2 ref 1) ]]$ and $[[ SATv(H',R,R(x),T1) ]]$.

    From $[[Cons(H,R,G)]]$, we know that $[[SAT(H,R,G)]]$, in particular, $[[ SATv(H,R,R(x),G(x)) ]]$.
    If we show that $[[own(H, R(x), T1 + T2)(a)=0]]$ and $[[ H ~ a H']]$,
    then, by \Cref{lem:heapfor0}, we will obtain $[[ SATv(H',R,R(x),T1+T2) ]]$,
    from which, by \Cref{lem:satadd},
    $[[ SATv(H',R,R(x),T1) ]]$ and $[[ SATv(H',R,R(x),T2) ]]$ follow.
    We then have $[[ SATv(H',R,R(y),T2 ref 1) ]]$ and $[[ SATv(H',R,R(x),T1) ]]$ as $[[H'(R(y)) = R(x) ]]$.

    To show $[[own(H, R(x), T1 + T2)(a)=0]]$, 
    we define $[[O0']], [[O0'']], [[O1']]$ and $[[O1'']]$ as below:
    \begin{align*}
      [[Own(H, R, G)]] & = [[O0' + O0'']] \\
      [[Own(H', R, G'')]] & = [[O1' + O1'' ]] \\
      [[O0']] & = [[ |< {z in dom G \ {y,x} } own(H,R(z),G(z)) ]] \\
      [[O0'']] &= [[ own(H, R(y), G(y)) + own(H, R(x), G(x)) ]] \\
      [[O1']] & = [[ |< {z in dom G'' \ {y,x}} own(H',R(z),G''(z)) ]] \\
      [[O1'']] &= [[ own(H', R(y), G''(y)) + own(H', R(x), G''(x)) ]]
    \end{align*}
    By the definition of the ownership function, $[[G(y) = T' ref 1 ]]$ and $[[ G(x) = T1 + T2]]$, we have:
    \begin{align*}
      [[O0'']] & = [[own(H, H(R(y)), T') + {a |-> 1} + own(H, R(x), T1 + T2)]] \\
      [[O1'']] & = [[own(H', H'(R(y)), T2) + {a |-> 1} + own(H',R(x), T1)]]
    \end{align*}
    As $[[ Own(H, R, G)(a) <= 1 ]]$ (from $[[Cons(H,R,G)]]$) and from
    \begin{align*}
      [[Own(H, R, G)(a) ]] & = [[ O0'(a) + O0''(a) ]] \\
                           & = [[O0'(a) + own(H, H(R(y)), T')(a) + 1 + own(H, R(x), T1 + T2)(a)]] \\
                           & = 1
    \end{align*}
    we have that:
    \begin{align*}
      [[own(H, H(R(y)), T')(a) & = own(H, R(x), G(x))(a) ]] \\
                               & = [[ own(H, R(x), T1 + T2)(a) ]] \\
                               & = [[O0'(a) = 0]]
    \end{align*}

    We now show that $[[ H ~ a H' ]]$. The first two conditions are clear, so it
    remains to show that, for any $[[nn]]$, $[[ H |- a ~> nn ]]$ iff $[[ H' |- a ~> nn ]]$.
    From \Cref{lem:sat-implies-shape-cons}, we have $[[ H |- a ~> |T' ref 1| ]]$, and
    a proof by contradiction gives that $[[ |T' ref 1| ]]$ is the only such $[[ nn ]]$
    for which $[[ H |- a ~> nn ]]$. We now argue the forward case for the bi-implication,
    the backwards case follows similar reasoning.

    Given $[[ H |- a ~> |T' ref 1|]]$, we  must show $[[ H { a <- R(x) } |- a ~> |T2 ref 1| ]]$, for which it suffices to show
    $[[ H { a <- R(x) } |- R(x) ~> |T2| ]]$. 
    From our requirement that $[[T']]$ and $[[T2]]$
    (and therefore $[[ T1 + T2 ]]$) have similar shapes, we have $[[ |T'| = |T2| = |T1 + T2| ]]$.
    By inverting the well-typing of the input configuration, we must have $[[ SATv(H, R, R(x), T1 + T2) ]]$,
    thus by \Cref{lem:sat-implies-shape-cons} we must have $[[ H |- R(x) ~> |T2| ]]$.
    As $[[|T2| = |T'|]] < [[|T' ref 1|]]$, $[[a]]$ cannot be reachable from $[[R(x)]]$ in $[[H]]$
    (otherwise we would have $[[a]]$ reaches an integer along multiple heap paths of differing lengths,
    a clear contradiction).
    Then the value of $[[a]]$ in $[[H]]$ is irrelevant to the derivation of $[[ H |- R(x) ~> |T2| ]]$,
    whereby $[[ H { a <- R(x) } |- R(x) ~> |T2| ]]$ must hold.

    Then, it's to show $[[forall a' in H'.Own(H', R, G'')(a') = (O1' + O1'')(a') = O1'(a') + O1''(a') <= 1]]$.
    For every $[[ z in dom G \ { y, x } ]]$ (and similarly for $[[G'']]$), we have
    $[[G(z) = G''(z)]]$. Further, from $[[O0'(a) = 0]]$ above, we must have $[[own(H, R(z), G(z))(a) = 0]]$
    for all such $[[z]]$. As $[[ H ~ a H' ]]$, by \Cref{lem:heapop}, we have that $[[ O0' = O1' ]]$.
    Then, from $[[ forall a' in H.Own(H, R, G'')(a') = O0'(a') + O0''(a') <= 1 ]]$, \AI{$[[G'']]$ should be $[[G]]$?  I didn't see where it came from.} it suffices to show
    that $[[ forall a' in H.O1''(a') <= O0''(a') ]]$.
       
    We first consider the case for $[[a]]$:
    \begin{align*}
      [[O1''(a)]] & = [[own(H', H'(R(y)), T2)(a) + own(H', R(x), T1)(a)+1]] \\
      [[O0''(a)]] & = [[own(H, R(x), T1 + T2)(a) + own(H, H(R(y)), T')(a)+1]]
    \end{align*}
    From above, we have $[[own(H, R(x), T2 + T1)(a) = own(H, H(R(y)), T')(a) = 0]]$.
    By \Cref{lem:heapop} and $[[ H ~ a H' ]]$, we have $[[own(H, R(x), T2 + T1) = own(H', R(x), T2 + T1)]]$.
    Also by \Cref{lem:ownadd}, we have $[[own(H', R(x), T2+T1) = own(H', R(x), T1)+own(H', R(x), T2)]]$.
    From $[[ H'(R(y)) = R(x) ]]$, we therefor have $[[own(H', H'(R(y)), T2)(a)=own(H', R(x), T1)(a)=0]]$,
    and thus:
    \[
      [[O1''(a)=own(H', H'(R(y)), T2)(a) + own(H', R(x), T1)(a)+1 = 1 = O0''(a)]]
    \]
    
    Next, consider some $[[a != a']]$;
    \begin{align*}
      [[O1''(a')]] & = [[own(H', H'(R(y)), T2)(a') + own(H', R(x), T1)(a') ]] \\
      [[O0''(a')]] & = [[own(H, R(x), T2 + T1)(a') + own(H, H(R(y)), T')(a') ]]
    \end{align*}
    By reasoning similar to the case for $a = a'$, we have $[[O1''(a') <= own(H, R(x), T2 + T1)(a') <= O0''(a')]]$.
    We therefore conclude that $[[forall a' in H'.Own(H', R, G'')(a') <= 1]]$.
  \end{rneqncase} % R-Assign
  
  \begin{rneqncase}{R-Alias}{
    [[ |- D <H, R, Es, E[alias(x = y); e]>]]\\
    [[ <H, R, Es, E[alias(x = y); e]> --> D <H, R, Es, E[e]> ]]\\
    [[ R(x) = R(y) ]]
    }
    By inversion (see \rn{R-Deref}) we have for some $[[G]]$ that:
    \begin{align*}
      & [[ Th | G[x : T1 ref r1][y: T2 ref r2] | ll |- alias(x = y); e : T => G']] \\
      & [[ Th | G[x <- T1' ref r1'][y <- T2' ref r2'] | ll |- e : T => G']] \\
      & [[ T1 ref r1 + T2 ref r2 ~ T1' ref r1' + T2' ref r2' ]] \\
      & [[ Cons(H,R,G) ]] \andalso [[ ll |- G ]]
    \end{align*}
    We give $[[ G'' = G[x <- T1' ref r1'][y <- T2' ref r2'] ]]$, and must show
    $[[ Th | G'' | ll |- e : T => G' ]]$, and $[[ ll |- G'']]$, $[[Cons(H, R, G'')]]$.
    The first is immediate, and the second follows from the definition of $[[~]]$ and the
    assumed well-formedness of $[[ T1 ]]$ and $[[ T2 ]]$.
    
    To show $[[Cons(H,R,G'')]]$ we first define:
    \begin{align*}
      [[Tp1]] = & [[T1 ref r1]] \\
      [[Tp2]] = & [[T2 ref r2]] \\
      [[Tq1]] = & [[T1' ref r1']] \\
      [[Tq2]] = & [[T2' ref r2']] \\
      [[Tq]] = & [[Tq1 + Tq2]] \\
      [[Tp]] = & [[Tp1 + Tp2 ]]
    \end{align*}
    We thus have $[[Tq ~ Tp]]$.
    
    We know that $[[Cons(H,R,G) ]]$, from which we have $[[ SAT(H,R,G) ]]$, in particular
    $[[ SATv(H,R,R(y),G(y) = T2 ref r2) ]]$ and $[[ SATv(H, R, R(x), G(x) + T1 ref r1) ]]$.
    From $[[Tp1 + Tp2 = Tp]]$ and \Cref{lem:satadd}, we have
    $[[SATv(H,R,v,Tp1)]]$ and $[[SATv(H,R,v,Tp2)]]$ imply $[[SATv(H,R,v,Tp)]]$, where $[[v = H(R(y))=H(R(x))]]$.
    From $[[Tq ~ Tp]]$ and \Cref{lem:sattosat}, we have that $[[SATv(H,R,v,Tp)]]$ implies $[[ SATv(H,R,v,Tq)]]$.
    From \Cref{lem:satadd} we also have that $[[SATv(H,R,v,Tq)]]$ implies $[[ SATv(H,R,v,Tq1) ]]$ and $[[ SATv(H,R,v,Tq2)]]$, where
    again $[[v = H(R(y))=H(R(x))]]$.

    Then from the reasoning above, the refinements of $[[Tq1]]$ and $[[Tq2]]$ are valid and $[[Cons(H, R, G'')]]$ holds.

    Then, it's to show $[[forall a in H.Own(H, R, G'')(a) <= 1]]$.
    To prove that $[[Own(H, R, G)=Own(H, R, G'')]]$ follows from:
    \begin{align*}
      &[[own(H,R(x),T1 ref r1) + own(H,R(y),T2 ref r2) ]] =  \\
      &\,\,\,\,[[ own(H,R(x),T1' ref r1') + own(H,R(y),T2' ref r2')]]
    \end{align*}
    which follows immediately from the conditions $[[ T1 ref r1 + T2 ref r2 ~ T1' ref r1' + T2' ref r2']]$, $[[R(x) = R(y)]]$, and \Cref{lem:ownadd,lem:ownequiv-preserv}.
  \end{rneqncase} % R-Alias

  \begin{rncase}{R-AliasPtr}
    By reasoning similar to the \rn{R-Alias} case.
  \end{rncase}
    
  
  \begin{rncase}{R-AliasFail,R-AliasPtrFail} % DONE
    The result configuration $[[AliasFail]]$ is trivially well-typed.
  \end{rncase}
  
  \begin{rneqncase}{R-Assert}{ % DONE
    [[ |- D <H, R, Es, E[assert(ph); e]>]]\andalso [[ G |= [R]ph ]]\\
    [[ <H, R, Es, E[assert(ph); e]> --> D <H, R, Es, E[e]> ]]\\
    }
    By inversion (see \rn{R-Deref}) we can obtain $[[ Th | G | ll |- assert(ph); e : T => G']]
$ and $[[ Th | G | ll |- e : T => G' ]]$, and
    the result follows immediately by taking $[[G'' = G ]]$.
  \end{rneqncase} % R-Assert
  
  \begin{rneqncase}{R-AssertFail}{ % DONE
      [[ |- D <H, R, Es, E[assert(ph); e]>]] \\
      [[ <H, R, Es, E[assert(ph); e]> --> D AssertFail ]]\\
      [[ Th | G | ll |- assert(ph); e : T => G']]
    }
    By inversion (see the \rn{R-Deref} case) we have that
    $[[ G |= ph ]]$, i.e., $[[ |= [G] ==> ph ]]$,
    for some $[[G]]$ such that $[[Cons(H,R,G)]]$ and
    $[[ ll |- G ]]$. From \Cref{lem:sat-implies-gamma} we therefore have $[[ |= [R][G] ]]$.
    From the precondition of \rn{R-AssertFail} we have that
    $[[  !|= [R]ph ]]$. But from $[[ |= [G] ==> ph ]]$ and $[[ |= [R][G] ]]$
    we can conclude that $[[ |= [R]ph ]]$, yielding a contradiction.
    We therefore conclude that this case is impossible.
  \end{rneqncase} % R-AssertFail
  
  \begin{rneqncase}{R-Call}{
      [[ |- D <H, R, Es, E[let x = f l (y1,,yn) in e']>]]\\
      [[f |-> (x1, .., xn) e in D]] \\
      [[ <H, R, Es, E[let x = f l (y1,,yn) in e']> \\
      --> D <H, R, E[let x = [] l in e'] : Es, [y1/x1] ,, [yn/xn] e> ]] \\
    }
    We must show that
    $[[ |- D <H, R, E[let x = [] l in e'] : Es, [y1/x1] ,, [yn/xn] e> ]]$
    for some $[[G'']]$.
    
    By inversion on the configuration typing, we have that, for some $[[G]]$:
    \[
      [[ Th | G | ll |- E[let x = f l (y1,,yn) in e'] : Tn => Gn ]] .
    \]
    By \Cref{lem:stack_var}, we then have for some $[[ T ]]$, and $[[ G' ]]$ that:
    \begin{align*}
      & [[ Th | G | ll |- let x = f l (y1,,yn) in e' : T => G' ]] \\
      & [[ Th | [] : T => G' | ll |-e E : Tn => Gn ]]
    \end{align*}
    Taking $[[ T1 = T ]], [[ G1 = G' ]], [[ G0 = G ]], [[ G2 = Gn ]], [[ T2 = Tn ]]$,
    by \Cref{lem:callfunc} we have, for some $[[T''']], [[G''']]$:
    \begin{align*}
      & [[ Th | G | l : ll |- vsub e : T''' => G''' ]] \\
      & [[ Th | []: T''' => G''' | ll |-e E[let x = [] l in e'] : Tn => Gn ]]
    \end{align*}
    where:
    \begin{align*}
      [[ vsub ]] & = [[ [y1/x1] ,, [yn/xn] ]] \\
      [[ Th(f) ]] & = [[ A <x1 : Ti ,, xn : Tn> -> <x1: T1' ,, xn : Tn' | Tp > ]]
    \end{align*}
    We therefore take $[[ G'' = G ]]$. The well-formedness of $[[G'']]$
    follows from $[[G'' = G]]$ and by inversion on the typing of the runtime configuration.
     
    We must also prove that $\forall i\in\set{1..n+1}.[[ Th | [] : Ti => Gi | lli-1 |-e E'i-1 : Ti-1 => Gi-1 ]]$  where $[[ E'n = E[let x = [] l in e'] ]]$ and $[[ E'i = Ei ]] (0 \leq i < n)$,
    which can be divided into proving
    $\forall i\in\set{1..n}.[[ Th | [] : Ti => Gi | lli-1 |-e E'i-1 : Ti-1 => Gi-1 ]]$ and $[[ Th | [] : Tn+1 => Gn+1 | lln |-e E'n : Tn => Gn ]]$. The first follows by inversion on $[[ |- D <H, R, Es, E[let x = f l (y1,,yn) in e']>]]$.

    We define $[[Gn+1 = G''' ]]$ and $[[Tn+1 = T''' ]]$, whereby the
    well-typing holds from the result of applying \Cref{lem:callfunc} above.
    
    Finally, $[[Cons(H,R,G'')]]$ follows immediately from $[[Cons(H,R,G)]]$ and $[[G''=G]]$.
  \end{rneqncase}
\end{proof}


\section{Proof of Progress}
\label{sec:progress-proof}

We first state the standard decomposition lemma.
\begin{lemma}[Decomposition]
  \label{lem:decomposition}
  For any term $[[e]]$, either $[[ e = v]]$ or there exists some $[[E]]$ and $[[e']]$ where $[[E[e'] = e]]$ and one of the following
  cases hold:
  \begin{enumerate}
  \item $[[ e' = let x = mkref y in e'' ]]$
  \item $[[ e' = let x = y in e'' ]]$
  \item $[[ e' = let x = nn in e'' ]]$
  \item $[[ e' = let x = *y in e'' ]]$
  \item $[[ e' = let x = f l (y1,,yn) in e'' ]]$
  \item $[[ e' = x; e'' ]]$
  \item $[[ e' = alias(x = y); e'' ]]$
  \item $[[ e' = alias(x = *y); e'' ]]$
  \item $[[ e' = ifz x then e1 else e2 ]]$
  \item $[[ e' = assert(ph); e'' ]]$
  \item $[[ e' = x := y; e ]]$
  \end{enumerate}
\end{lemma}
\begin{proof}
  Straightforward induction on $[[e]]$
\end{proof}

\begin{lemma}
  For a well-typed configuration $[[ |- D C ]]$, one of the following holds:
  \begin{enumerate}
  \item $[[ C = AliasFail ]]$
  \item $[[ C = < H, R, ., x> ]]$
  \item There exists some $[[ C' ]]$ such that $[[ C --> D C' ]]$.
  \end{enumerate}
\end{lemma}
\begin{proof}
  By inversion on $[[ |- D C ]]$, either $[[ C = AliasFail ]]$ or $[[ C = < H, R, Es, e> ]]$.
  In the former case the result is immediate. In the latter case we have
  that $[[ Th | G | ll |- e : T => G' ]]$ for some $[[ T ]], [[G]]$ and $[[G']]$,
  and further from   \Cref{lem:decomposition}, we have that either $[[ e = v ]]$ or there exists
  some $[[ E ]]$ or $[[ e' ]]$ where $[[ e = E[e'] ]]$ and $[[ e' ]]$ meets one of the cases in
  \Cref{lem:decomposition}.

  Then either $[[ Es = . ]]$ or $[[ Es = CE : Es' ]]$. In the former
  case the result is immediate and in the latter case the configuration can step
  to $[[ <H, R, Es, CE[x]> ]]$ according to \rn{R-Var}.
  For the remaining cases where $[[ e = E[e'] ]]$,
  by the well-typing of $[[ e ]]$ with respect to $[[ G ]]$ and \Cref{lem:stack_var},
  we have that $[[ Th | G | B |- e' : T0 => G0 ]]$ some $[[T0]]$ and $[[G0]]$.

  We now treat the remaining forms of $[[e']]$
  \begin{eqncase}{
      [[ e' = let x = *y in e'' ]]
    }
    By inversion (\Cref{lem:inversion}) and \Cref{lem:subtyp-preserves-cons} we must have
    that for some $[[Gp]]$ where $[[ Cons(H, R, Gp) ]]$ that $[[ y in dom G ]]$ and
    $[[ G(y) = T' ref r ]]$. From $[[ Cons(H, R, Gp) ]]$ we must have $[[ y in dom R ]]$
    and further $[[ SATv(H, R, R(y), T' ref r') ]]$, from which we must have
    $[[ R(y) = a ]]$ and  $[[ a in dom H]]$. Then $[[ C ]]$ can step according to \rn{R-Deref}.
  \end{eqncase}
  
  \begin{eqncase}{[[ e' = let x = y in e'' ]]}
    Again, by \Cref{lem:inversion,lem:subtyp-preserves-cons} and the definition
    of $[[ Cons ]]$, we must have that $[[ y in dom R ]]$, and the system can step
    according to \rn{R-LetVar}.
  \end{eqncase}

  \begin{eqncase}{[[ e' = let x = mkref y in e'' ]]}
    Similar to the \rn{R-LetVar} case above.
  \end{eqncase}

  \begin{eqncase}{
      [[ e' = let x = nn in e'' ]] \\
      [[ e' = x; e'' ]] \\
      [[ e' = assert(ph); e'' ]]
    }
    The first two can trivially step according to \rn{R-LetInt} and \rn{R-Seq} respectively.
    the last can step according to \rn{R-Assert} or \rn{R-AssertFalse} (although
    by \Cref{lem:preservation,lem:assertfail} the latter is impossible).
  \end{eqncase}
  
  \begin{eqncase}{
      [[ e' = alias(x = y); e'' ]]
    }
    Again by \Cref{lem:inversion,lem:subtyp-preserves-cons} and that
    $[[Cons(H, R, G)]]$ implies $[[x]]$ and $[[y]]$ are bound to addresses
    in the register file, we have that the configuration can step according to \rn{R-Alias}
    or \rn{R-AliasFail}
  \end{eqncase}

  \begin{eqncase}{
      [[ e' = alias(x = *y); e'' ]] 
    }
    Similar to the case above, we must have that $[[x]]$ is bound to an address
    in the register file, and that $[[y]]$ is bound to an address that
    is itself mapped to an address in the heap $[[H]]$. Then the configuration may
    step according to \rn{R-AliasPtr} or \rn{R-AliasPtrFail}
  \end{eqncase}

  \begin{eqncase}{
      [[ e = ifz x then e1 else e2 ]]
    }
    As above, from the well-typing we must have that $[[x]]$ is bound in $[[R]]$
    to some integer $[[nn]]$. Then the configuration may step according to \rn{R-IfTrue}
    or \rn{R-IfFalse} depending on whether
    $[[nn = 0]]$ or $[[nn != 0 ]]$.
  \end{eqncase}
  
  \begin{eqncase}{
      [[ e' = x:=y;e'' ]]
    }
    From the well-typing of $[[e']]$,
    \Cref{lem:inversion,lem:subtyp-preserves-cons} and the definition
    of $[[Cons]]$, we must have that $[[ y in dom R ]]$ and
    $[[ x in dom R ]]$. From the typing rule for assignments, we must have
    that $[[ y ]]$ is a reference type from we which can conclude that $[[ R(y) = a ]]$
    and $[[ a in dom H ]]$. Then the configuration can step according \rn{R-Assign}.
  \end{eqncase}

  \begin{eqncase}{
      [[ e' = let x = f l (y1,,yn) in e'' ]]
    }
    From the well-typing of the function call we must have that $[[ f in dom Th ]]$.
    From $[[ Th |- D ]]$ in the precondition of $[[ |- D C ]]$, we must have that
    $[[ f |-> (x1,..,xj) e''' in D ]]$. Then from \rn{T-FunDef} we must have that
    $ j = n $ whereby the configuration can step according to \rn{R-Call}.
  \end{eqncase}
\end{proof}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
