(** Intrinsics give the definitions for built in operations defined in
   the language.

   We do not fix a set of intrinsics, but allow them to be loaded from
   a file, whose format is described below.

   {2 Intrinsic File}
   The intrinsic file is stored in a S-Expression
   format as generated by the Jane Street sexp library. The set of
   intrinsics includes built-in functions (abbreviate bifs) and
   relation operators. Relation operator definitions are ONLY used to
   translate assertion conditions into an equivalent SMT
   form. Relation operators used for program level comparisons (e.g.,
   <) are defined as functions, which take two numbers and return a
   single number, which is then compared against zero (to illustrate,
   supply the -show-ast option to see the desugaring of [if x < y then ...]).
   Built-in functions can be used anywhere, and may be
   operators or regular functions. The low-level syntax of ConSORT
   doesn't make a distinction, but the parser indentifies (x + y) as
   the function call (+)(x, y).  In short, infix operators are defined
   using the same mechanism as more traditional functions.

   The intrinsic file is an S-expression encoding of a tuple with
   three elements, a map from function names to function types, a
   interpretation map for relations, and the optional name for an smt definition file
   (explained below).

   The function map takes function names to bif_types, which describe the pre- and post- condition
   on the function arguments and return value with refinement types. These refinement types
   may reference SMT predicates via the NamedPred refinement, these predicates are defined in the smt definition file.

   The relation interpretation map takes relation symbols (e.g., string "=", "<", etc.) to SMT predicate names (i.e., strings).
   These predicate names are expected to take two integer arguments and return Bool. These predicates may be built in to the solver,
   or may be defined in the smt definition file.

   Finally, the smt definition file component is an optional string. If present, it names a file in the same directory
   as the intrinsic definition file which contains all predicate/function definitions relied upon by the bif or relation interpretations.
   Accordingly, any verification task which uses these intrinsics is appended to the contents of this file.
*)

open Sexplib.Std

type bif_arg_t = RefinementTypes.typ [@@deriving sexp]

type bif_t = {
  arg_types: bif_arg_t list;
  output_types: bif_arg_t list;
  result_type: bif_arg_t;
}[@@deriving sexp]

type bif_env_t = bif_t StringMap.t
let bif_env_t_of_sexp = StringMap.t_of_sexp ~v:bif_t_of_sexp
let sexp_of_bif_env_t = StringMap.sexp_of_t ~v:sexp_of_bif_t
        
(* just a mapping of connectives onto Z3 functions *)
type rel_interp_t = string StringMap.t
let rel_interp_t_of_sexp = StringMap.t_of_sexp ~v:string_of_sexp
let sexp_of_rel_interp_t = StringMap.sexp_of_t ~v:sexp_of_string

type interp_t = {
  op_interp: RefinementTypes.funtype StringMap.t; (** Map from bif name to refinement function type for that bif *)
  rel_interp: rel_interp_t; (** Map from relation symbols to binary SMT predicates giving their interpretation *)
  def_file: string option (** Path to the smt definition file; may be used directly provided the working directory has not been changed since the intrinsic file was loaded *)
}


let load f =
  let (op,rel,rel_defn) = Sexplib.Sexp.load_sexp f |> [%of_sexp: (bif_env_t * rel_interp_t * string)] in
  let mapped = StringMap.map (fun {arg_types; output_types; result_type } ->
      RefinementTypes.{
        arg_types;
        output_types;
        result_type
      }
    ) op in
  let defn = Filename.concat (Filename.dirname f) rel_defn in  {
    op_interp = mapped;
    rel_interp = rel;
    def_file = Some defn
  }
  

let empty = {
  op_interp = StringMap.empty;
  rel_interp = StringMap.empty;
  def_file = None
}

let option_loader () =
  let open Arg in
  let f_name = ref None in
  [
    "-intrinsics", String (fun x -> f_name := Some x), "Load definitions of standard operations from <file>"
  ], (fun () ->
    match !f_name with
    | None -> empty
    | Some s -> load s
  )
