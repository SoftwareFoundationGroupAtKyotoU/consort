package edu.kyoto.fos.regnant.cfg;

import edu.kyoto.fos.regnant.cfg.graph.BlockSequence;
import edu.kyoto.fos.regnant.cfg.graph.ConditionalNode;
import edu.kyoto.fos.regnant.cfg.graph.Continuation;
import edu.kyoto.fos.regnant.cfg.graph.Coord;
import edu.kyoto.fos.regnant.cfg.graph.ElemCont;
import edu.kyoto.fos.regnant.cfg.graph.GraphElem;
import edu.kyoto.fos.regnant.cfg.graph.InstNode;
import edu.kyoto.fos.regnant.cfg.graph.JumpCont;
import edu.kyoto.fos.regnant.cfg.graph.JumpNode;
import edu.kyoto.fos.regnant.cfg.graph.Jumps;
import edu.kyoto.fos.regnant.cfg.graph.LoopNode;
import fj.P;
import fj.P2;
import soot.Body;
import soot.Unit;
import soot.UnitPatchingChain;
import soot.jimple.IfStmt;
import soot.toolkits.graph.BriefUnitGraph;
import soot.toolkits.graph.DominatorTree;
import soot.toolkits.graph.DominatorsFinder;
import soot.toolkits.graph.HashMutableDirectedGraph;
import soot.toolkits.graph.MHGDominatorsFinder;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.Stream.Builder;

import java.io.IOException;
import java.io.PrintWriter;
/*
  The control flow graph reconstruction. This and the flag instrumentation are actually
  the trickiest parts of the translation; the actual dumping to IMPerial is relatively straightforward.

  The control flow graph reconstruction first generates basic blocks.
  A basic block is, unsurprisingly, any sequence of straightline code,
  i.e., a sequence of units ui such that for uj and uj+1 we have that succ(uj) = {uj+1}
  and pred(uj+1) = {uj}. We do not require that the units occur consecutively in the
  method body. During basic block construction, we also collapse singleton blocks
  (i.e., blocks with a single unit) that contain a single goto statement. These blocks are generated
  entirely due to a limitation in the Java bytecode format and lead to code bloat. Instead, we
  push those goto targets back to the source if expressions. After the generation, we generate
  a map from the head/tail of each block to the generated basic block object; these are used
  in graph construction below.

  We then construct a basic block graph based off of the underlying unit graph; with the
  exception of handling the collapsing described above, this process is relatively straightforward
  using the maps described above.

  Based off this graph, we run the standard natural loop detection algorithm. For the unfamiliar, a
  loop header is any unit (i.e., basic block) that dominates a predecessor. The jump from the predecessor node to
  the loop header is called a backjump. All blocks reachable by traversing predecessor edges starting from all backjumps
  and terminating at the loop header are the loop body. We make the standard assumption that loops are well-nested,
  that there is a distinguished entry point, etc. These assumptions (currently) hold for all loops generated by the Java
  compiler. We do NOT assume that all loops have a single distinguished exit; dealing with this complexity is what
  ultimately causes much of the complexity here.

  The result of the loop algorithm is a loop tree, which maps a basic block to the loop bodies containing the block,
  and whether a basic block is a header.

  Based on the loop information and the basic block computed previously, we then construct an Annotated basic block graph.
  This annotated graph gives information about successors annotated with the loops entered/continued/broken by the control
  flow edge. For example, a jump b -> c that exits loop l will annotate the successor information with the header of the loop
  (in general we identify loops by the (unique) header block).

  We then compute the BlockTree. The block tree data structure is used as a first order approximation of the structure of
  the resulting function. The block tree is a general tree where a parent must be executed before it's children; there may be control
  flow between the some of the children nodes. We also maintain the invariant that if block is a loop header, all children of that block must be within the loop body
  identified by the loop header. The block tree begins with a dominator tree; by construction this tree always satisfies the first condition.
  To satisfy the second conditon we walk this tree search for children of loop header nodes not contained within that loop's body. We then
  shift the nodes upwards into the tree until the second invariant is establish.

  For example, the expression H: if(...) { A } else { B } C would be represented by the tree H -> [ A, B, C ] Here, A may flow to C and similarly for B, but A does not flow
  to B or vice versa. Each subtree has set of sucessors; these are all intraprocedural successors of any node in the subtree
  that do not appear in that subtree. In other words, each tree can be viewed as a node in a digraph; the successors of the pseudo-node are those
  nodes identified previously. Given that all nodes with backjumps to a loop header must appear as children under the node for the basic block,
  and from the assumption that all cycles in our basic block graph occur in natural loops, we must then have that the edges between the pseudo-nodes formed by all immediate
  children of a node form a DAG. A toplogical sort of this DAG then gives a reasonable execution order for these child nodes. In the case where a node in the toplogical
  ordering is conditionally executed (because of "forward" jumps among the children) we use the gating scheme as implemented in FlagInstrumentation.

  The above gives the basic intuition for how the cfg reconstruction works. We process the tree from bottom up; each basic block node processed yields a
  a graphelem object. See the graph elem class for a detailed explanation of the graph elem representation; roughly, each graph element corresponds to a high-level
  control flow structure (if, loop, sequential composition), and is elaborated with the "unresolved" successors; i.e. successors targets that appeared within the corresponding
  subtree where the target was not a member of the subtree. After processing all the children of a node (i.e. block) in the tree, we have a (potentially empty)
  list of nodes.

  In the case where the list is empty, the current block does not dominate any successors or has no successors (in which case it returns). Then we wrap
  the current block in a JumpNode, which indicates that after executing the wrapped block we have an (unresolved) jump.

  In the case where the current block ends in a conditional jump we generate a conditional node. A conditional node has the conditional itself, which
  is a basic block that ends in a conditional expression. It has two "Continuation" children, each indicating how to execute the true and false branches.
  If either true/false targets correspond to child graph nodes, those graph nodes are directly embedded as the continuation; i.e., the program fragment
  represented by the graph node is used as the body of the if/else branch. Otherwise, if the true/false branch target is not a child of the current node, or
  the node may be reached from other child nodes, we add a Jump continuation, which indicates that to execute the corresponding branch, execution must flow
  to the indicated target.

  If there are any remaining child nodes, they are topographically ordered with respect to their "unresolved" jumps, the concatenation of this
  sorted sequence with the head node is this then packaged up as a SequenceNode (indicating sequential execution of the wrapped nodes) and returned.

  A final note about loops: The translation above always ensures that loop headers are wrapped in at least one pseudo-node. In otherwords, there must
  always be a graph node which corresponds directly to the loop itself, not to a component of the loop (including the head). In the case where the header
  of the loop has been wrapped in a sequence node, then this is sufficient. In the case where the loop body and the loop head are contained within
  a single graph elem, we introduce the synthetic loop node. Separating the node representing the loop and the body of the loop ensures that an edge out of a loop
  is effectively divided into two pieces; the first within the loop indicating to break out of the loop with a return, and the second edge from the loop
  node to the loop successor. This separates detecting breaking out of a loop with determining how to continue execution after the loop.
 */
public class CFGReconstructor {
  private final BasicBlockMapper bbm;
  private final LoopTree lt;
  private final UnitPatchingChain unitChain;
  private final AnnotatedBasicBlockGraph graph;
  private GraphElem cfgRoot;
  private BlockTree<BasicBlock> bt;
  private Set<Coord> recurseJumps = new TreeSet<>();
  private BasicBlockGraph bbg;

  public CFGReconstructor(Body b) {
    this.bbm = new BasicBlockMapper(b);
    this.unitChain = b.getUnits();
    this.bbg = new BasicBlockGraph(new BriefUnitGraph(b), bbm);
    this.lt = new LoopFinder(bbg).getTree();
    this.graph = new AnnotatedBasicBlockGraph(bbg,lt);
    computeCFG();
  }

  // 基本ブロックの制御フローグラフ (CFG) を求めるメソッド
  // TODO: ここの解読 特に branch の意味
  private void computeCFG() {
    // 結局 graph.getRawGraph() は this.bbg のこと
    DominatorsFinder<BasicBlock> doms = new MHGDominatorsFinder<>(graph.getRawGraph());
    DominatorTree<BasicBlock> dt = new DominatorTree<>(doms);
    assert dt.getHead().getGode().equals(graph.getHead());

    this.cfgRoot = recursiveLayout(dt);
  }

  public GraphElem getReconstructedGraph() {
    return cfgRoot;
  }

  public BlockTree<BasicBlock> getStructure() {
    return this.bt;
  }

  // bbm は基本ブロック cfgRoot は制御フローグラフを表している （ただし現行 regnant 向きのやつなのでそういう書き方をしてほしくない）。基本ブロックを出力してから cfgRoot の形を整えたやつを返す
  public String dump() {
    // System.out.println("-bbm->");
    this.bbm.iterator().forEachRemaining(System.out::println);
    // System.out.println("<-bbm-");
    return this.cfgRoot.dump();
  }

  // 基本ブロックの制御フローグラフを表示するためのメソッド
  private GraphElem recursiveLayout(DominatorTree<BasicBlock> dt) {
    // the block tree constructor generates the initial version of the block tree based on the dominator tree
    this.bt = new BlockTree<>(dt);
    // recursive lift then shuffles children up so their immediate parent is not a loop header whose body does not contain the child node
    recursiveLift(dt.getHead().getGode(), null, null);
    // the actual layout and lifting to graph nodes (elems)
    return recursiveLayout(bt, graph.getHead(), null);
  }

  private void recursiveLift(final BasicBlock node, final BasicBlock head, final Builder<BasicBlock> outQueue) {
    if(head != null) {
      if(this.lt.containingLoops(node).stream().map(Loop::getHeader).noneMatch(head::equals)) {
        outQueue.accept(node);
        return;
      }
    }
    List<BasicBlock> children = new ArrayList<>(this.bt.children.getOrDefault(node, Collections.emptyList()));
    if(lt.isLoopHeader(node)) {
      Stream.Builder<BasicBlock> b = Stream.builder();
      // lift each child. If the child is not within the body of the loop with this node as a header, it is added to the stream builder b.
      children.forEach(n -> {
        recursiveLift(n, node, b);
      });
      b.build().forEach(n -> {
        // if there are no further containing loops, or the child node being shifted up in the same loop as THIS containing loop,
        // add it to this node's parent
        if((this.lt.containingLoops(n).isEmpty() && head == null) ||
            this.lt.containingLoops(n).stream().map(Loop::getHeader).anyMatch(p -> p.equals(head))) {
          this.bt.shiftTo(n, this.bt.parent.get(node));
        } else {
          // other wise, push it out of this node's loop body
          assert outQueue != null : n + " " + node;
          outQueue.accept(n);
        }
      });
    } else {
      children.forEach(b -> recursiveLift(b, head, outQueue));
    }
  }

  private Unit fwMap(Unit u) {
    if(u.hasTag(RemapTag.REMAP)) {
      return ((RemapTag)u.getTag(RemapTag.REMAP)).target;
    } else {
      return u;
    }
  }


  private P2<AnnotatedEdge, AnnotatedEdge> getConditionalEdges(BasicBlock b) {
    IfStmt s = (IfStmt) b.getTail();
    BasicBlock ft = this.bbm.getBlockByHead(fwMap(this.unitChain.getSuccOf(s)));
    BasicBlock tgt = this.bbm.getBlockByHead(fwMap(s.getTarget()));
    List<AnnotatedEdge> succ = this.graph.getSucc(b);
    AnnotatedEdge tgtEdge = succ.stream().filter(e -> e.block.equals(tgt)).findAny().get();
    AnnotatedEdge ftEdge = succ.stream().filter(e -> e.block.equals(ft)).findAny().get();
    return P.p(tgtEdge, ftEdge);
  }

  private GraphElem recursiveLayout(final BlockTree<BasicBlock> bt, final BasicBlock curr, BasicBlock loopHeader) {
    List<BasicBlock> childBlocks = bt.children.get(curr);
    // a return then
    List<AnnotatedEdge> succ = this.graph.getSucc(curr);
    if(succ.size() == 0) {
      /*
       the jumps data structure records for each coordinate (explained in a moment) the (unresolved) jump targets originating from that coordinate.
       A jump target is either a normal flow (a forward jump), a continue a backjump to the immediate containing loop header, or a break. A break
       maps a coordinate and jump target to the loop headers to be broken out of. Recall that each loop is modeled as a function. To break
       out of multiple loops (as with a labelled break), we must somehow return immediately from multiple functions. Of course, this is impossible
       with a single return statement. Instead, we record the (unique) id of the source of the labeled break in our gate flag, and return. At return
       from the loop body, we check if there are any pending breaks; i.e., if the loop still has break jumps. If we do, we return again, and so on
       until we've broken out of all the loops. We statically model the above process with the list of loop headers that must be broken;
       a break edge becomes a normal successor edge (indicating all loops have been broken out of) when the list of pending loop headers is empty (see below).
       */
      return new JumpNode(curr, Jumps.ret(curr));
    }

    boolean isLoopHeader = lt.isLoopHeader(curr);
    /* The layout of a block happens within the context of the immediately containing loop header. This help determine whether a jump is
       a continue or not (continue's are modeled by returning after an invocation of the synthesized function corresponding to the current loop).
     */
    BasicBlock childHeaders = isLoopHeader ? curr : loopHeader;
    List<GraphElem> gElem = childBlocks.stream().map(cb -> recursiveLayout(bt, cb, childHeaders)).collect(Collectors.toList());
    // Each graph elem corresponds to the basic block rooting the subtree which generated the elem. This generates a map from those blocks to the corresponding graph elem
    // When resolving intra-child jumps we exclusively use this map. Note that we do NOT have to worry about jumps from one child to a basic block in a subtree of another child,
    // because the tree is based off the dominator tree; such a jump would violate the domination property.
    Map<BasicBlock, GraphElem> lkp = gElem.stream().collect(Collectors.toMap(GraphElem::getHead, i -> i));
    HashMutableDirectedGraph<BasicBlock> depGraph = new HashMutableDirectedGraph<>();
    lkp.keySet().forEach(depGraph::addNode);
    // Create a "flows to" graph amongst the child nodes. This is used for the topological sorting described below.
    lkp.forEach((bb, elem) -> elem.getJumps().flow.stream().map(P2::_2).filter(lkp::containsKey).forEach(tgt -> depGraph.addEdge(bb, tgt)));

    // these are the flow describing the exits from this entire subtree (only used if we need a synthetic wrapper node (loop or sequence)
    Jumps exitFlows = new Jumps();
    ArrayList<GraphElem> elems = new ArrayList<>();
    if(succ.size() == 2) {
      P2<AnnotatedEdge, AnnotatedEdge> v = this.getConditionalEdges(curr);
      Jumps hdJumps = new Jumps();

      /* a continuation may be a jump (may set a control flag, return, recurse, or simply do nothing) or a graph elem, in which case the program fragment
        corresponding to the block is used directly as the body of the corresponding branch. If this occurs, the element is removed from the dependence graph
       */
      Continuation trCont = this.toContinuation(Coord.of(true, curr), depGraph, v._1(), lkp);
      Continuation flCont = this.toContinuation(Coord.of(false, curr), depGraph, v._2(), lkp);
      // Now compute the jumps for the hd element
      /*
        The hd jumps record the the remaining unresolved jumps from within the conditional node. Those jumps that
        cannot be resolved within the remaining child nodes are recorded in exit flows.

        Note that if curr is the head of a loop, and one of the jumps from within the conditional body breaks out of the headed loop, the jump recorded in the conditional nodes
        jump will be a break jump, but the corresponding successor edge recorded in exitflows will be recorded as a regular flow. Recall that a loop is always represented
        by a synthetic, structural node, such that the break and the successor from the loop proper are separate.
       */
      mergeParentJumps(curr, hdJumps, exitFlows, lkp, trCont.getJumps(), loopHeader);
      mergeParentJumps(curr, hdJumps, exitFlows, lkp, flCont.getJumps(), loopHeader);
      elems.add(new ConditionalNode(curr, hdJumps, trCont, flCont));
    } else {
      assert succ.size() == 1;
      Coord c = Coord.of(curr);
      AnnotatedEdge e = this.graph.getSucc(curr).get(0);
      // save recurse saves whether the jump indicated by this edge should be compiled into a recursive call.
      this.saveRecurse(c, e);
      Jumps j = Jumps.of(c, e);
      Jumps nodeJump = new Jumps();
      mergeParentJumps(curr, nodeJump, exitFlows, lkp, j, loopHeader);
      elems.add(new JumpNode(curr, nodeJump));
    }
    while(depGraph.size() > 0) {
      // get all elements (i.e., graph elements) with no incoming edges from other children
      List<BasicBlock> next = depGraph.getHeads();
      assert next.size() > 0;
      assert next.stream().allMatch(lkp::containsKey);
      // any unresolved jumps from these successors must be added to the exit flows of the containing sequence node (that we are in this) loop means we will have a synthetic node
      next.stream().map(lkp::get).map(GraphElem::getJumps).forEach(j -> mergeSuccessorJumps(curr, exitFlows, lkp, j, loopHeader));
      if(next.size() == 1) {
        elems.add(lkp.get(next.get(0)));
      } else {
        /* an inst node indicates that one of several nodes may execute next. this most often occurs when there is a return within a loop body:
          according to standard loop detection, the return is not part of the loop. Thus at the exit of the loop, we must either return or continue along the
          "normal" path of execution.
         */
        InstNode n = new InstNode(next.stream().map(lkp::get).collect(Collectors.toList()));
        elems.add(n);
      }
      next.forEach(depGraph::removeNode);
    }

    /*
      We have multiple elements so wrap them into a sequence node. We may tag this block as representing a loop depending on whether the corresponding basic block was a loop header
     */
    if(elems.size() > 1) {
      return new BlockSequence(elems, exitFlows, isLoopHeader);
    } else {
      GraphElem toRet = elems.get(0);
      if(isLoopHeader) {
        // here we wrap the (singleton) node in a single, synthetic loop node, for all the reasons discussed above.
        return new LoopNode(toRet, exitFlows);
      } else {
        return toRet;
      }
    }
  }

  private void saveRecurse(final Coord c, final AnnotatedEdge e) {
    if(e.cont.isPresent() && e.brk.isEmpty()) {
      /* If this is a continue (i.e., a jump to a loop header) and we do not have to break any loops, then we can model
        this jump by a direct recursive invocation
       */
      this.recurseJumps.add(c);
    }
  }

  private void mergeSuccessorJumps(BasicBlock curr, final Jumps exitFlows, Map<BasicBlock, GraphElem> lkp, Jumps j, BasicBlock loopHeader) {
    mergeJump(curr, exitFlows, j, flow -> !lkp.containsKey(flow._2()), true, loopHeader);
  }

  private void mergeParentJumps(BasicBlock curr, final Jumps hdJumps, final Jumps exitFlows, final Map<BasicBlock, GraphElem> lkp, final Jumps cont, final BasicBlock loopHeader) {
    mergeJump(curr, hdJumps, cont, tgt -> true, false, loopHeader);
    mergeJump(curr, exitFlows, cont, tgt -> !lkp.containsKey(tgt._2()), true, loopHeader);
  }

  /*
    the isFlow predicate tests whether the flow in the src should be a flow in the target. When we call this function with the exitJumps, i.e., the jumps
    out of entire subtree, only flows that remain unresolved in the subtree should be a flow.


   */
  private void mergeJump(BasicBlock curr, Jumps tgtJumps, Jumps srcJumps, Predicate<P2<Coord, BasicBlock>> isFlow, boolean breakAsFlow, final BasicBlock loopHeader) {
    srcJumps.flow.forEach(f -> {
      if(isFlow.test(f)) {
        tgtJumps.flow.add(f);
      }
    });
    srcJumps.brk.forEach((coord, headers) -> {
      // this may be a break, check if we propagate the break, or turn it into a flow
      Set<BasicBlock> newHead;
      if(headers.contains(curr)) {
        newHead = headers.stream().filter(p -> !curr.equals(p)).collect(Collectors.toSet());
        // this is the outer most break location, transform this break into a flow
        if(newHead.isEmpty()) {
          // transform to a flow if breakAsFlow flag is true. This is false when computing the flows out of the conditional node;
          // if the conditional node itself is the loop header being broken, the flow out of the conditional is still a break flow;
          // We are guaranteed that the loop header is going to be wrapped in a synthetic node, where the break flow will be turned into
          // a successor/continue flow
          if(breakAsFlow) {
            if(coord._2().equals(loopHeader)) {
              tgtJumps.cont.add(coord);
            } else {
              tgtJumps.flow.add(coord);
            }
            return;
          } else {
            newHead = new HashSet<>(headers);
          }
        }
      } else {
        newHead = new HashSet<>(headers);
      }
      assert !newHead.isEmpty();
      tgtJumps.brk.computeIfAbsent(coord, ign -> new HashSet<>()).addAll(newHead);
    });
  }

  private Continuation toContinuation(final Coord coord, final HashMutableDirectedGraph<BasicBlock> depGraph,
      final AnnotatedEdge annotatedEdge, Map<BasicBlock, GraphElem> lkp) {
    if(!depGraph.containsNode(annotatedEdge.block) || !depGraph.getHeads().contains(annotatedEdge.block)) {
      this.saveRecurse(coord, annotatedEdge);
      return JumpCont.of(coord, annotatedEdge);
    } else {
      assert lkp.containsKey(annotatedEdge.block);
      depGraph.removeNode(annotatedEdge.block);
      return new ElemCont(lkp.get(annotatedEdge.block));
    }
  }

  public Collection<? extends Coord> getRecurseLocations() {
    return recurseJumps;
  }

  // 追加
  public BasicBlockMapper getBbm() {
    return bbm;
  }

  public BasicBlockGraph getBbg() {
    return bbg;
  }
}
