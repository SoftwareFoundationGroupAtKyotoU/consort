package edu.kyoto.fos.regnant.cfg.instrumentation;

import edu.kyoto.fos.regnant.cfg.BasicBlock;
import edu.kyoto.fos.regnant.cfg.CFGReconstructor;
import edu.kyoto.fos.regnant.cfg.graph.BlockSequence;
import edu.kyoto.fos.regnant.cfg.graph.ConditionalNode;
import edu.kyoto.fos.regnant.cfg.graph.Coord;
import edu.kyoto.fos.regnant.cfg.graph.GraphElem;
import edu.kyoto.fos.regnant.cfg.graph.InstNode;
import edu.kyoto.fos.regnant.cfg.graph.JumpNode;
import edu.kyoto.fos.regnant.cfg.graph.Jumps;
import edu.kyoto.fos.regnant.cfg.graph.LoopNode;
import fj.P2;

import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.function.Consumer;
import java.util.stream.Collectors;

/*
  This class determines both when the control flow flag must be set, and where
  and how it should be checked.

  Roughly, every break jump (i.e., portion in the code where it is indicated that
  we must break out of a loop) is flagged to be a "return jump". These locations
  are saved in a set interpreted by the Translate class; if a coordinate
  is true, the jump is modeled by an immediate return.

  During processing this class walks the generated tree generated by the CFG reconstruction. If
  when processing a node the analysis must determine from whence execution originated,
  it adds the predecessors targeting the current nodes' jump locations to the "setFlag" set.
  When translating these jumps, Translate
  ensures before performing the jump (by either falling through or returning, i.e., breaking out of a loop)
  the special control flag it set to some unique value. This analysis then annotates the current node, indicating it
  only conditionally executes if execution arrived from points p1, p2, ... etc.
*/
public class FlagInstrumentation {
  public static final String GATE_ON = "gate-on";
  public static final String CHOOSE_BY = "choose-by";
  public static final String RECURSE_ON = "recurse-on";
  public static final String RETURN_ON = "return-on";
  public Set<Coord> setFlag = new TreeSet<>();
  public Set<Coord> returnJump = new TreeSet<>();
  public Set<Coord> recurseFlag = new TreeSet<>();

  public FlagInstrumentation(CFGReconstructor cfg) {
    recurseFlag.addAll(cfg.getRecurseLocations());
    GraphElem root = cfg.getReconstructedGraph();
    this.assignFlags(root, null);
  }

  private void assignFlags(final GraphElem graph, BasicBlock parentLoop) {
    BasicBlock childLoop = graph.isLoop() ? graph.getHead() : parentLoop;
    Consumer<GraphElem> curry = g -> assignFlags(g, childLoop);
    if(graph instanceof JumpNode) {
    } else if(graph instanceof ConditionalNode) {
      ConditionalNode cond = (ConditionalNode) graph;
      cond.fBranch.elem().ifPresent(curry);
      cond.tBranch.elem().ifPresent(curry);

      /*
        Given the number of times I add coordinates to the return jump set, I suspect
        something is fishy about this design. It speaks to (poor) defensive programming.
       */
      cond.tBranch.getJumps().brk.keySet().stream().map(P2::_1).forEach(returnJump::add);
      cond.fBranch.getJumps().brk.keySet().stream().map(P2::_1).forEach(returnJump::add);
    } else if(graph instanceof BlockSequence) {
      BlockSequence toCheck = (BlockSequence) graph;
      toCheck.chain.forEach(curry);

      Iterator<GraphElem> iterator = toCheck.chain.iterator();
      GraphElem hd = iterator.next();
      assert !(hd instanceof InstNode);
      // get the flow successors from the head, mapping those successors to the set of source jumps targeting those nodes
      Map<BasicBlock, Set<Coord>> flows = hd.getJumps().flow.stream().collect(Collectors.groupingBy(P2::_2, Collectors.mapping(P2::_1, Collectors.toSet())));
      while(iterator.hasNext()) {
        hd = iterator.next();
        // Is the next element in the sequence executed unconditionally; i.e., do all successors remaining from the previous element have this current block as their target.
        boolean unconditional = hd.heads().stream().distinct().filter(flows::containsKey).count() == flows.size();
        // If not, we must conditionally execute this block. This is achieve with the GATE_ON annotation, which contains the set of coordinates with this as their target.
        if(!unconditional) {
          Set<Coord> gate = hd.heads().stream().flatMap(p -> flows.get(p).stream()).collect(Collectors.toSet());
          hd.putAnnotation(GATE_ON, gate);
          // all outstanding jumps must set their flag to determine whether to conditionally execute this node
          flows.values().forEach(setFlag::addAll);
        }
        // There are multiple possibilities to execute here. To know which one to execute,
        // we must track which predecessor jumps have which nodes as their targets
        if(hd instanceof InstNode) {
          InstNode inst = (InstNode) hd;
          // set the targets
          inst.hds.stream().flatMap(c -> flows.get(c.getHead()).stream()).forEach(setFlag::add);
          // generate a map from basic blocks to the set of jump coordinates with that basic block as the target
          Map<BasicBlock, Set<Coord>> chooseBy = inst.hds.stream().map(GraphElem::getHead).collect(Collectors.toMap(i -> i, flows::get));
          hd.putAnnotation(CHOOSE_BY, chooseBy);
        }
        hd.heads().forEach(flows::remove);
        // for each successor from this current node, update the list of expected targets and the jump coordinates as their source
        hd.getJumps().flow.forEach(pp -> {
          flows.computeIfAbsent(pp._2(), ign -> new TreeSet<>()).add(pp._1());
        });
      }
    } else if(graph instanceof LoopNode) {
      curry.accept(((LoopNode) graph).loopBody);
    } else {
      assert graph instanceof InstNode;
      ((InstNode)graph).hds.forEach(curry);
    }

    Jumps jumps = graph.getJumps();
    if(parentLoop == null) {
      assert jumps.brk.isEmpty();
      assert jumps.cont.isEmpty();
    }
    // sure, just for good measure
    jumps.brk.keySet().stream().map(P2::_1).forEach(returnJump::add);

    if(graph.isLoop()) {
      Set<Coord> recurseOn = new HashSet<>();
      Set<Coord> returnOn = new HashSet<>();

      /* now instrument on "return on" or "recurse on"
         Return on is for implementing breaking out of multiple loops.
         After returning out of one of the containing loops, it may be necessary to return again to continue breaking out
         of the loops. The return on set are the sets of jump sources WITHIN the loop from whence execution flows necessitate
         continued returns. Thus, we have those jumps set a control flag and add those coordinates to the return-on set. During
         translation, translating a call to the translated loop body, the translation pass will check if this
         set is non-empty; if so it adds a conditional which checks if the control flag equals any of the source
         coordinates in said set, and returns if so.

         A similar approach is taken for nested continues; after "breaking" the containing loop, it checks the the "recurse-on" map
         and generates a conditional recursive call if it is non empty.

         In both cases, we add it to return jump JUST TO BE SURE.
       */
      graph.getJumps().cont.forEach(bb -> {
        assert parentLoop != null;
        assert bb._2().equals(parentLoop);

        recurseOn.add(bb._1());
        setFlag.add(bb._1());
        returnJump.add(bb._1());
      });
      graph.getJumps().brk.keySet().forEach(p -> {
        returnOn.add(p._1());
        setFlag.add(p._1());
      });
      graph.putAnnotation(RETURN_ON, returnOn);
      graph.putAnnotation(RECURSE_ON, recurseOn);
    } else {
      assert graph.getJumps().cont.isEmpty();
    }
  }
}
