# Regnant: Automated Verification of Java Programs

Regnant translates a Java program (represented by a collection of Java classes) into a
simplified low-level program in the imperative language supported by ConSORT. This translated
program can then be fed into ConSORT to get a verification result for the original Java
program.

## Requirements

A compiler that supports Java 11, and a Java runtime that supports Java 11.
The gradle build tool can be bootstrapped with the gradlew script (see below).

To use the scripts distributed here, you will also need `python` versions 2 and 3 (porting
the scripts to python 3 is a work in progress).

To actually run the Regnant translation you will need a JDK 8 installation, which includes
at least `rt.jar` (to give the definitions for the JCL classes).

Finally, you will of course need to have ConSORT, but considering you checked out this repo,
you're already there!

## Building

`./gradlew installDist` will download the necessary dependencies, build the regnant classes,
and generate an execution script. (It does not actually install anything on your system).

To build the example programs included with the source run:

`./gradlew integrationJar`

## Running

At the most basic level, you can invoke the Regnant translation with `build/install/regnant/bin/regnant`.

By itself invoking this script won't do anything; regnant is implemented as a Soot
whole program transformation and hooks into Soot's main method. To directly invoke regnant,
you will need to provide the (quite numerous) magical flags required to make Soot run.

Instead, it is recommended you use the `regnant.py` script. If you want to know
how to invoke regnant directly, you can pass the `--verbose` option which 
causes the `regnant` script to print the flags it is using.

The basic invocation is:

`./regnant.py /path/to/jdk8/root path.to.Main consort-args...`

Any future argumens after the entry point are passed directly to the
underlying consort tool (you will likely need to provide the `--`
argument to avoid confusion from python).

## Code Walkthrough

As mentioned above, Regnant is built upon Soot; you will need at least
a basic understanding of that ecosystem to make any sense of the Regnant implementation.
Accordingly, this README will assume basic familiarity with Soot.

### Basics of the Translation

Before processing any individual methods, Regnant first computes storage information
for classes in the program. Inspired by the work by Igarashi and Kobayashi, we use
the "big tuple" model for objects; an object is represented by a tuple of fields (the
exact format for these fields is configurable, as discussed below under "Object Model").
That is, an object with three fields is represented by a tuple with (at least) 3 elements
as discussed below.

However, in the presence of subclassing, a variable of static type `A` may hold an object
with more fields that those declared in `A`; indeed, in the presence of interfaces, it is
unknown entirely what fields will exist in objects contained in that variable. As the
underlying language of Consort does not support subclasses or row polymorphism, a
straightforward translation where we use a tuple with exactly the number of fields
for each class is sufficient. Rather, if objects of different static types
may flow to the same storage location, we _unify_ their representation such that
objects of either type have the same number of tuple fields of exactly the same type.
Thus objects of either type can be freely assigned into a location that is a (super type)
of the two static types. As an unfortunate side effect, this necessarily means that some
objects will have useless fields that always have dummy values.

To compute the representations used for objects of each class, Regnant first
traverses the pointer assignment graph generated by Soot to determine what objects
may share static storage locations. By using the pointer assignment graph, we are guaranteed
to only operate on concrete types. Types that share a static storage location are unified
with union find; the _unique_ fields of the unioned classes are then given a canonical
(but arbitrary) order. This computation is handled in the `StorageLayout` class.

The translation then proceeds on a per-method basis. Each Java method can generate
multiple ConSORT functions (due to the handling of loops, as explained below).

The unit graph is first pre-processed by a series of rewriters, as defined in `RewriteChain`.
These rewriters perform the following functions:

1. Translating the if statements generated by an `assert e` statement into `if(!e) fail` (`AssertionRewriter`).
  * Technically we insert a new NOP statement which is given a tag interpreted by the translation pass such that it compiles to `fail`
2. Rewriting `random.nextInt()` into a call to `edu.kyoto.regnant.random.rand()` (this is later recognized and rewritten into a `_` form) (`RandomRewriter`)
3. Automatically inserting aliasing annnotations (`AliasInsertion`):
  * Aliasing annotations are handled with calls to (dummy) functions in the Regnant "runtime"
  * This pass searches for variables that:
     * are used and defined exactly once in the same block
     * are defined with `x = y.f`
     * after their last use, we have `mustAlias(x, y.f)`
     * are not passed to to `Aliasing.noAutoReturn`
  * For such variables, Regnant automatically inserts calls to the must aliasing calls

The unit graph of the method is first translated into a BlockGraph, which gives the basic blocks
of the method. The basic block construction is handled entirely by the `BasicBlockGraph` class.

Next Regnant reconstructs a high-level control-flow graph from the basic block graph.
This high level reconstruction not only gives (relatively) easier to read code, but gives
a more natural translation into ConSORT, which lowers the burden on the backend solver
(fewer "administrative" relations, etc.) The result is an AST like structure which
is (misleadingly) called a graph. This pass is handled in `CFGReconstructor`.

This graph is then walked to generate control gates. ConSORT's language does not
support breaks, continues, etc.; i.e., there is no direct translation of the
following Java code:

```java
lbl: {
   A;
   if(e1) { 
     B; 
     if(e2) { break lbl; }
   } else {
     C
   }
   D;
}
```

In the above, despite not appearing in an `if` expression, `D` is conditionally executed
under the condition `!e1 || !e2`. The above could be rewritten to:

```java
A;
if(e1) { 
  B; 
  if(!e2) { D }
} else {
  C; D
}
```

This rewriting increases the size of the program, which can negatively impact verification
performance. More generally, when translating a graph into straightline code, it may
be necessary to place some block `c` as an immediate control-flow successor to block `b`,
even though `c` may not always be execute after `b` (of course, such a layout
only makes sense if there is some successor `d` of `c` which may execute after `b` and `c`).

Instead, we instrument the program to record the path through the program,
and use that record to determine whether a block should be executed. In the above
example, we rewrite the program to:

```java
A;
flag = 0
if(e1) { 
  B; 
  if(!e2) { flag = 1 }
} else {
  C
};
if(flag = 0) { D }
```

More generally, if the execution of a block is conditional upon the control flow path through
its preceding block we given give each path a unique id, and at the end of each path record
that unique id into a dummy variable. The conditinally-executed block is then placed
inside an if block, conditioned upon the value of the flag. To ease analysis,
rather than string together several integer inequality checks in the object langage,
Regnant uses intrinsics that are given interpretations by `genFlags.exe`; these interpretations
implement the necessary checks directly in SMT. This instrumentation is implemented
in `FlagInstrumentation`.

Next, the object "graph" is walked, determining where to insert let bindings. If
a variable is used in blocks `A, B, C...` then this pass finds the first common predecessor
of all these blocks (this may include one of the blocks in the set). In addition, this
pass determines mutability of variables: if a variable is proven to be written exactly once,
this pass indicates it does not need to be bound in `mkref`; mutable variables are
flagged as such as instead bound in `mkref`. This pass occurs in the `LetBindAllocator`.

Finally the resulting graph is translated into a set of low-level ConSORT functions.
Each loop (including nested loops) is given it's own function; `break`, `continue`
etc. statements are modeled as simple functions returns. The basic data structure
in the translation is the `InstructionStream`. The instruction stream interleaves
side effected statements and bindings. The instruction stream maintains the
key invariant that any variables bound in the stream are guaranteed to be in scope
for later statements added to the stream. Each instruction stream object exports
methods to dump the IMPerial representation of the instructions to an output stream.
In this way, the instructions added to the InstructionStream model the (surface) AST
accepted by ConSORT. The syntax of expressions is given by `ImpExpr`. The translation
is handled by `Translate`.

### Object Model

As stated above, Regnant uses a large, monolithic tuple to represent objects. 
More precisely, an object is represented with a tuple consisting n elements, 
the first element is an (immutable) integer representing the runtime tag of the object,
and the remaining n - 1 fields representing the field values of the object or dummy values
as required by the monolithic representation.

However, within this broad definition, there are several design choices. Namely:

1. Should the object tuple copied around directly, or placed under a tuple constructor, and
2. Should the fields themselves be references, or should field updates be "functional"

Regnant takes the latter approach in the first point as it simplifies the representation
of null, and yields a direct representation of null checks (a simple `ifnull` in IMPerial).
For the 2nd question, Regnant actually implements both strategies, indirecting
the choice of field representation though an `ObjectModel` type. The `ObjectModel` interface
provides methods that translate the reading/writing of fields, translating an access path
to a field into low-level IMPerial access paths, etc. The assumption about 1 is baked in,
but in principle the flexibility of the `ObjectModel` interface implies other representation
strategies are feasible.

As a final note, the functional approach appear to scale better as it requires *significantly*
fewer ownership variables. Even in the relaxed ownership mode, the maximization constraint
emited by ConSORT can grind Z3 to a halt if the number of ownership variables is too large.
