_reverse(l, l_next) {
    match l_next with
      Nil -> {
        // alias(*(l.Cons.2) = l_next);
        return l
      }
    | Cons(h, t) -> {
        let t_deref = *t in {
            t := l;
            alias(l_next.Cons.2 = t);
            let reversed = _reverse(l_next, t_deref) in
            reversed
        }
    }
}

reverse(l) {
    match l with
      Nil -> l
    | Cons(h, r) -> {
        let reversed = _reverse(Nil, l) in
        reversed
    }
}

{
    let n = mkref Nil in
    let m = mkref Cons(1, n) in
    let l = Cons(2, m) in
    let rev_l = reverse(l) in
    ()
}