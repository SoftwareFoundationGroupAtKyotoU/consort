\section{Typing}
\label{sec:typesystem}
We now introduce a combined
fractional ownership refinement type system that guarantees well-typed
programs do not encounter assertion failures. We first present
a brief background on ownership types (\Cref{sec:ownership}),
before describing our fractional ownership refinement types
(\Cref{sec:types}), the type system (\Cref{sec:intra-types,sec:cs}),
and finally close with our soundness statement
(\Cref{sec:soundness}).

\subsection{Background: Fractional Ownership Types}
\label{sec:ownership}
Before describing our type system in detail, we provide a brief
overview of the fractional ownership type system upon which it
is built. The fractional ownership system of
Suenaga and Kobayashi \cite{suenaga2009fractional}
ensures safe memory access in low-level languages like C; it
was later extended by Suenaga et al. \cite{suenaga2012type} to also guarantee
correct allocation/deallocation of shared resources in concurrent programs.
Fractional ownership types elaborate reference
types with an ownership $[[r]]$, which is a rational number that
ranges from $[0,1]$. In their original presentation, an ownership of
$[[1]]$ indicates that a pointer
has exclusive ownership of a memory cell, and may freely read or write
the contents of the cell. An ownership in the range $(0,1)$
indicates a pointer with shared ownership, through which
a memory cell can be read but \emph{not} modified. Finally, a pointer
with $0$ ownership may be neither read nor modified.

The fractional ownership type systems in \cite{suenaga2009fractional,suenaga2012type} enforced the
following key invariant: the total ownership of all pointer types that
point to the same memory cell never exceeds 1. As an immediate
consequence, given a pointer $p$ with ownership $1$, no other readable
pointers that alias with $p$ may exist (otherwise the total ownership
would exceed 1). The type system is designed such that when an alias
to a pointer $p$ is created, the current ownership of $p$ is divided
between the new alias and $p$ (hence \emph{fractional} ownership).
Further, on writes to a reference $p$,
the type system may destructively change
the type of $p$'s contents to be inconsistent with previous content type.
In a language with unrestricted aliasing, such an operation would
be unsound, but the above invariant guarantees that
at the time of update no readable pointers that expect the old
contents remain.
\name maintains the same invariant; this guarantee enables our combined
type system to destructively
(and incompatibly) change the refinements of mutable memory cells;
readable pointers that expect values constrained by the previous
refinement cannot exist when an update occurs.

\begin{remark}
  In the fractional ownership type systems cited above,
  an ownership also represents an \emph{obligation} to
  ensure the memory referenced by a pointer was eventually
  freed. Further, a $0$ ownership was used for pointers that
  had been freed to ensure dangling pointers were not used.
  As mentioned in \Cref{sec:semantics}, our language
  does not include deallocation which
  significantly simplifies our formalism.
  In particular, our type system \emph{does}
  allow reads of references with 0 ownerships. However,
  such references provide no information about their contents
  beyond simple types for reasons discussed below.
\end{remark}

\begin{figure}[t]
  \begin{minipage}{0.45\textwidth}
  \[
    \begin{array}{rrcl}
      \text{\scriptsize Types} & [[ T ]] &::=& [[ {nu:int|ph} ]] \mid [[ T ref r ]] \\
      \text{\scriptsize Ownership} & [[ r ]] & \in & [0,1] \\
      \text{\scriptsize Refinements} & [[ph]] & ::= & [[ ph1 \/ ph2 ]] \mid [[ !ph ]] \mid [[Top]] \\
                               & & \mid & [[ pfun(pval1,..,pvaln) ]] \\
                               & & \mid & [[ pval1 = pval2 ]] \\
                                 & & \mid & \mathcal{CP} \\
      \text{\scriptsize Refinement Values} & [[ pval ]] & ::= & [[ x ]] \mid [[ v ]] \mid [[ nu ]]
    \end{array}
  \]
\end{minipage}
\hfill
\begin{minipage}{0.49\textwidth}
  \[
    \begin{array}{rrcl}
      \text{\scriptsize Function Types} & [[FT]] & ::= & [[ A <x1 : T1 ,, xn : Tn> \\ & & & -> <x1: T1' ,, xn : Tn' | T> ]] \\
      \text{\scriptsize Context Variables} & [[A]] & \in & \CVar \\
      \text{\scriptsize Concrete Context} & [[ ll ]] & ::= & [[ l : ll ]] \mid [[ . ]] \\
      \text{\scriptsize Pred. Context} & [[ plhs ]] & ::= & [[ l : plhs ]] \mid [[ A ]] \mid [[ . ]] \\
      \text{\scriptsize Context Query} & [[CQP]] & ::= & [[ ll <= plhs ]] \\
      \text{\scriptsize Typing Context} & [[ B ]] & ::= & [[ A ]] \mid [[ ll ]]
    \end{array}
  \]
  \end{minipage}
  \caption{Syntax of types, refinements, and contexts}
  \label{fig:types}
\end{figure}

\subsection{Types and Contexts}
\label{sec:types}
The syntax of types is given in \Cref{fig:types}.
Our type system has two type constructors: references and integers. $[[ T ref r ]]$ is the
type of a (non-null) reference to a value of type $[[ T ]]$.
$[[r]]$ is an ownership which is a rational number in the
range $[0,1]$. An ownership of $[[0]]$ indicates a
reference that provides no refinement information, cannot be written,
and for which there may exist a mutable alias.
By contrast, $[[1]]$ indicates a pointer with exclusive
ownership that can be read and written. Reference types with ownership values between
these two extremes indicate a pointer that is readable but not writable, which
has non-trivial refinement information, and for which no mutable aliases exist.
Like the ownership type systems described above, \name ensures that no mutable aliases
exist for a pointer with ownership in the range $(0,1]$, and that any aliases
of a mutable reference have ownership $0$. \NK{I do not quite understand the part
 ``and for which ...''}

The base types of our type system are integers that are refined with a
predicate $[[ph]]$.  The language of predicates is built using the
standard logical connectives of first-order logic,
with (in)equality between variables and integers, and atomic predicate symbols
$[[pfun]]$ as the basic atoms. We include a special
``value'' variable $[[nu]]$ representing the
value being refined by the predicate. For simplicity, we omit the
connectives $[[ ph /\ ph ]]$ and $[[ ph ==> ph ]]$; they can be written
as derived forms using the given connectives.
We leave the choice of underlying theory from which $[[pfun]]$
are drawn unspecified, provided it is decidable. $\mathcal{CP}$
are context predicates, which are used for context sensitivity as
explained in the following paragraph.

\begin{example}
  $[[{nu:int | nu > 0}]]$ is the type of strictly positive integers.
  $[[{nu:int | nu = 3} ref 0.5]]$ is the type of immutable
  references to integers exactly equal to $3$.
\end{example}

\AI{If we are desperate for space, we might want to omit ``$[[pval1 = pval2]]$'' (which could be assumed in $[[pfun]]$) and ``$[[Top]]$'' (which could be expressed by, say, $[[0=0]]$) from the syntax of refinements.}


\paragraph{Contexts and Context Polymorphism}
Our type system achieves context sensitivity
by allowing function types to depend on where and how a function
is called, i.e., the \emph{execution context} of the function invocation.
Our system represents a \emph{concrete} execution contexts with
string of call site labels (or just ``call strings''),
defined as $[[ll]] ::= [[.]] \mid [[l : ll ]]$.
As is standard (e.g., \cite{sharir1978two,shivers1991control}), the string $[[ l : ll ]]$ abstracts
an execution context where the most recent, active function call occurred
at call site $[[ l ]]$ which itself was executed in a context abstracted
by $[[ ll ]]$; $[[.]]$ is the context under which program execution begins. \emph{Context variables},
drawn from a finite domain $\CVar$ and ranged over by $[[A1]], [[A2]], \ldots$,
represent an arbitrary, unknown context.

Function types in our language are context polymorphic,
expressed by universal quantification \KS{``universal quantifier'' or ``universally quantified''.} \JT{done?}
over a context variable. Intuitively,
this context variable represents the many different execution contexts
under which a function may be called.
Argument and return types may then depend on this context variable with
\emph{context query predicates} described below.
The arguments of a function are an $n$-ary tuple of types $[[Ti]]$.
To model side-effects, the function type includes the same number of \emph{output types}
$[[Ti']]$. In addition, function types have a direct return value $[[T']]$. 
The argument and output types are given names: refinements within the function type
may refer to these names.

Types within a function type may depend on the function's calling context
by including \emph{context query predicates} in their refinements.
A context query predicate $[[CQP]]$ usually takes the
form $[[ ll <= A ]]$, and is true iff $[[ll]]$ is a
prefix of the concrete context represented by $[[A]]$.
We will also write $[[ ll </= A ]]$ as a more convenient
syntax for $[[ !(ll <= A) ]]$.
Intuitively, a refinement $[[ ll <= A ==> ph ]]$ on a value
asserts $[[ ph ]]$ holds in any concrete execution context
with prefix $[[ll]]$, and provides no information in any other
context. Notice that in full generality, a context query predicate may
be of the form $[[ ll1 <= ll2 ]]$ or $[[ ll1 <= l1,,ln:A ]]$;
these forms may be immediately simplified to
$[[ Top ]]$, $[[ Bot ]]$ or $[[ ll' <= A ]]$.

\begin{example}
  \label{exmp:cs-type-example}
  The type $[[ {nu:int| (l1 <= A ==> nu = 3) /\ (l2 <= A ==> nu = 4)} ]]$ represents
  an integer that is 3 if the most recent active
  function call site is $[[l1]]$, 4 if the most recent call site is $[[l2]]$,
  and is otherwise unconstrained.
\end{example}

As types in our type system may contain context variables, our typing judgment
(introduced below) includes a typing context $[[B]]$, which is either a single
context variable $[[A]]$ or a concrete context $[[ll]]$. This typing context
represents the assumptions about the \emph{concrete} execution context of the term being
typed. If the typing context is a context variable $[[A]]$, then no assumptions
can be made about the execution context of the term, although types
may depend upon the context with context query predicates.
Accordingly, function bodies are typed under the context variable
universally quantified over in the corresponding function type; i.e.,
no assumptions can be made about the exact execution context of the function body.
As in parametric polymorphism, our type rules are designed such that consistent
substitution of a concrete context $[[ll]]$ for a context variable $[[A]]$
in a typing derivation yields a valid type derivation under concrete context $[[ll]]$.


\begin{remark}
  \label{rem:cfa}
  The context-sensitivity scheme described here corresponds
  to the standard CFA approach \cite{shivers1991control} without \emph{a priori} call-string limiting.
  We chose this scheme as it can be easily encoded with equality over integer variables (see \Cref{sec:infr}),
  but in principle another context-sensitivity strategy could be used instead. The important
  feature of our type system is the inclusion of predicates $[[CQP]]$ over
  contexts, not the specific choice for these predicates.
\end{remark}

\paragraph{Well Formedness}
We impose two well-formedness conditions on types:
\emph{ownership well-formedness} and \emph{refinement well-formedness}.
The ownership condition is purely syntactic:
$[[ T ]]$ is ownership well-formed if $[[ T = T' ref 0 ]]$ implies
$[[ T' = topn ]]$ for some $[[n]]$. $[[topi]]$ is the ``maximal'' type
of a chain of $[[i]]$ references, and is defined inductively as
$[[top0 = {nu:int|Top}]], [[topi = topi-1 ref 0]]$.

The ownership well-formedness condition ensures that aliases introduced via
heap writes do not violate the invariant of ownership types \emph{and} that refinements remain consistent
in the presence of heap writes. Recall our ownership type invariant
states that aliases of a mutable reference have 0 ownership.
Any mutations through that alias will therefore be consistent with the
``no information'' $[[ Top ]]$ refinement required by the
well-formedness condition. \JT{There used to be a sentence here
  effectively saying that we can exploit aliasing to restore ownership
  and refinement information. It came off as a non-sequitor, and is restated
  elsewhere}

Refinement well-formedness
requires that any free program variables in a refinement
are given integer types in the type environment $[[G]]$. This
condition also ensures that the only context variable used
in a refinement is $[[A]]$ when $[[B = A]]$ (no context variables
may be used if $[[B = ll]]$). Notice this well-formedness condition
forbids refinements that refer to references. Although
ownership information can signal when the refinement on a mutably-aliased
reference must be discarded, our current formulation
provides no such information for refinements that include
mutably-aliased references. We therefore conservatively reject
such refinements at the cost of some expressiveness in our type system.
We write $[[ G | B |- T ]]$ to indicate a well-formed type
with respect to $[[B]]$ and $[[G]]$, and write $[[ ST(G) | B |- ph ]]$ to
indicate a well-formed predicate with respect to $[[B]]$ and
the simple type version of $[[G]]$, denoted $[[ ST(G) ]]$.
We write $[[ B |- G ]]$ for a type environment where all
types are well-formed, and write $[[ B |- T => G ]]$ for
$[[ B |- G ]]$ and $[[ G | B |- T ]]$. A function environment
is well-formed (written $[[ |- Th ]]$) if, for every $[[FT]]$ in $[[Th]]$,
the argument, result, and output types are well-formed with respect
to each other and the context variable quantified over in $[[FT]]$.
As the formal definition refinement well-formedness is fairly standard, we
omit it for space reasons (the full definition may be found in \Cref{sec:aux-defn-lem}).

\begin{figure}[t]
%  \leavevmode
  \scriptsize
  \infrule[T-Var]{
  }{
    [[ Th | G [ x : T1 + T2] | B |- x : T1 => G[ x <- T2 ] ]]
  }
  \vspace*{2ex}
  \infrule[T-Let]{
    [[ Th | G [ y <- T1 /\ y y = T1 x  ], x : (T2 /\ x x = T2 y) | B |- e : T => G']] \\
    [[B |- T => G']] \andalso [[ x not in dom G' ]]
  }{
    [[ Th | G[y: T1 + T2] | B |- let x = y in e : T => G']]
  }
  \vspace*{2ex}
  \infrule[T-LetInt]{
    [[ Th | G, x:{nu : int | nu = nn } | B |- e : T => G']] \andalso
    [[B |- T => G' ]] \andalso [[ x not in dom G' ]]
  }{
    [[ Th | G | B |- let x = nn in e : T => G']]
  }
  \vspace*{2ex}
  \infrule[T-If]{
    [[ Th | G[x <- {nu:int | ph /\ nu = 0 }] | B |- e1 : T => G' ]] \\
    [[ Th | G[x <- {nu:int | ph /\ nu != 0}] | B |- e2 : T => G' ]]
  }{
    [[ Th | G[x : {nu:int|ph}] | B |- ifz x then e1 else e2 : T => G' ]]
  }
  \vspace*{2ex}
  \bcprulessavespacetrue
  \begin{center}
  \infrule[T-MkRef]{
    [[ Th | G[y <- T1],x : (T2 /\ x x = T2 y) ref 1 | B |- e : T => G']] \\
    [[ B |- T => G' ]] \andalso [[ x not in dom G' ]]
  }{
    [[ Th | G[y : T1 + T2] | B |- let x = mkref y in e : T => G' ]]
  }
  \infrule[T-Seq]{
    [[ Th | G | B |- e1 : T' => G' ]] \\
    [[ Th | G' | B |- e2 : T'' => G'' ]]
  }{
    [[ Th | G | B |- e1 ; e2 : T'' => G'' ]]
  }
  \infrule[T-Deref]{
    [[ T' ]] = \begin{cases}
      [[ T1 /\ y y = T1 x ]] & [[r > 0]] \\
      [[ T1 ]] & [[ r = 0 ]]
    \end{cases}  \\
    [[ Th | G[y <- T' ref r], x : T2 | B |- e : T => G']] \\
    [[ B |- T => G' ]] \andalso [[ x not in dom G' ]]
  }{
    [[ Th | G[y: (T1 + T2) ref r] | B |- let x = *y in e : T => G' ]]
  }
  \infrule[T-Assert]{
    [[ G |= ph ]] \andalso
    [[ ST(G) | . |- ph ]] \\
    [[ Th | G | B |- e : T => G' ]]
  }{
    [[ Th | G | B |- assert(ph); e : T => G']]
  }
  \end{center}
  \bcprulessavespacefalse
  \caption{Expression typing rules.}
  \label{fig:intra-type}
\end{figure}

% \begin{figure}[t]
%   \leavevmode
%   \infax[Tadd-Int]{
%     [[{nu:int|ph1} + {nu:int|ph2} = {nu:int|ph1 /\ ph2}]]
%   }
%   \infax[Tadd-Ref]{
%     [[T1 ref r1 + T2 ref r2 = (T1 + T2) ref r1 + r2]]
%   }
%   \caption{Rules for $[[ T1 + T2 ]]$.}
%   \label{fig:addition}
% \end{figure}

\subsection{Intraprocedural Type System}
\label{sec:intra-types}
We now introduce the type system for the intra-procedural fragment of
our language. Accordingly, this section focuses on interplay of
mutability and refinement types. The typing rules are given in
\Cref{fig:intra-type,fig:pointer-typing}.  
A typing judgment takes the
form $[[ Th | G | B |- e : T => G' ]]$, which indicates that $[[e]]$
is well-typed under a type environment $[[G]]$, function type
environment $[[Th]]$, and typing context $[[B]]$
and evaluates to a value of type $[[T]]$ and modifies the input environment
according to $[[G']]$. A type environment $[[G]]$ is a finite
mapping from variable names to refinement types $[[T]]$.
We write $[[G[x: T] ]]$ to denote a type environment $[[G]]$ such
that $[[G(x) = T]]$ where $[[x in dom G]]$, $[[G,x:T]]$ to indicate the
extension of $[[G]]$ with the type binding $[[x : T]]$, and $[[G[x <- T] ]]$
to indicate the type environment $[[G]]$ with the binding of $[[x]]$
updated to $[[T]]$. We write the empty environment as $[[:G_em: empty]]$.
$[[B]]$ is defined as in \Cref{sec:types}
and $[[Th]]$ is a finite map from function names to function types.

\begin{remark}
  \label{rmk:env-mapping}
  The treatment of type environments as mappings instead of sequences
  in a dependent type system is somewhat non-standard. However, this
  approach does not cause problems in our formalism as we do not include
  higher-order functions; all arguments are bound simultaneously
  in our abstract semantics.
\end{remark}

The typing rules in \Cref{fig:intra-type} handle the relatively
standard features in our language. The most noteworthy feature is the
type addition operator $[[T1 + T2]]$ used in \rn{T-Let}, \rn{T-MkRef}, and
\rn{T-Deref} forms. Intuitively, the type addition operator describes
how to ``linearly'' split a type into two components, dividing information in the original
type between the two result types.
Viewed another way, it describes how to combine two types for the same
value such that the combination soundly incorporates all information from
the two original types.
Critically, the type addition operation cannot create or destroy
ownership or refinement information, only combine or divide it between
types. Formally, the type addition operator is defined as the least
commutative partial operation that satisfies the following rules:
\begin{gather*}
  [[{nu:int|ph1} + {nu:int|ph2} = {nu:int|ph1 /\ ph2}]] \\
  [[T1 ref r1 + T2 ref r2 = (T1 + T2) ref r1 + r2]]
\end{gather*}
Although not explicit in the rules,
by the ownership well-formedness condition,
if the entirety of a reference's ownership is transferred to
another type during a split, all refinements in the remaining
type must be $[[ Top ]]$.

The let bindings (\rn{T-Let}, \rn{T-MkRef}, \rn{T-Deref}, and
\rn{T-LetInt}) introduce new bindings based on the right hand side.
The rules for \rn{T-Let}, \rn{T-MkRef} and \rn{T-Deref} also \emph{update}
the type of the variable appearing on the right hand side; as some
ownership from the right-hand side may have been transferred to the new binding,
retaining the original type would be unsound.
The bindings rules then analyze the let body $[[e]]$ in this new environment.
The typing rule for each form requires the type and result environment of the
let body to no longer mention the bound variable $[[x]]$.
This requirement can be met by applying the subtyping rule (see below)
to weaken refinements to no longer mention $[[x]]$. As in other refinement
type systems \cite{rondon2008liquid}, this requirement is critical for ensuring soundness.
\AI{\rn{T-Let} already uses $[[ T /\ y ph' ]]$ and it's not for tracking path information.}

When creating bindings our type system tracks equality between
integer values. We use the
strengthening operation $[[ T /\ x ph ]]$ and typed equality
proposition $[[ x = T y]]$, defined respectively as:
\begin{align*}
  [[ { nu: int | ph } /\ y ph' ]] & = [[ { nu: int | ph /\ [nu/y]ph' }]] &
  [[ (x = {nu:int|ph} y) ]] & =  [[ (x = y) ]] \\ 
    [[ T ref r /\ y ph' ]] & = [[T ref r]] &
    [[ (x = T ref r y) ]] & = [[Top]]
\end{align*}
We do not track equality between references or between
the contents of reference cells as doing so would violate
our refinement well-formedness condition. Notice also that the
equality tracking in the \rn{T-Deref} case is \emph{conditionally}
applied depending on the ownership of the dereferenced pointer. 

Our type system also tracks path information; in the \rn{T-If}
rule, we update the refinement on the condition variable within the respective
branches to indicate whether the variable must be zero. By requiring
both branches produce the same output type environment, we guarantee
that these conflicting refinements are rectified within the
type derivations of the two branches.

The rule for type checking assert statements has the precondition
$[[ G |= ph ]]$ which is defined to be $[[|= [G] ==> ph]]$. $[[ [G] ]]$
lifts the refinements on the integer valued variables into a proposition
in the decidable logic used for verification. This denotation
operation is defined as:
\[
\begin{array}{rlcrl}
  [[ [empty] ]] &= [[ Top ]] & \hspace{1em} &  [[ [{nu:int|ph}] y ]] & = [[ [y/nu]ph ]] \\
  [[ [G,x: T] ]] &= [[ [G] /\ [T] x ]] &   &  [[ [T' ref r] y ]] & = [[ Top ]] \\
\end{array}
\]
If the formula $[[ [G] ==> ph]]$
is valid, then under any valuation of program variables that satisfy
the refinements in $[[ [G] ]]$, the predicate $[[ph]]$ must be true and the
assertion may not fail. This intuition forms the foundation of our
soundness claim (\Cref{sec:soundness}).
\AI{We could allow an assertion $[[ph]]$ to mention $[[ B ]]$.}

\begin{figure}[t]
  \scriptsize
  \leavevmode
    \infrule[T-Assign]{
    (\text{The shapes of $[[T']]$ and $[[T2]]$ are similar}) \\
    [[ Th | G[x <- T1][y <- (T2 /\ y y = T2 x) ref 1] | B |- e : T => G']] \\
  }{
    [[ Th | G[x: T1 + T2][y : T' ref 1] | B |- y := x; e : T => G']]
  }
  \infrule[T-Alias]{
    [[(T1 ref r1 + T2 ref r2) ~ (T1' ref r1' + T2' ref r2')]] \\
    [[ G | B |- T2' ]] \andalso [[ G | B |- T1' ]] \\
    [[ Th | G[x <- T1' ref r1'][y <- T2' ref r2'] | B |- e : T => G']]
  }{
    [[ Th | G[x : T1 ref r1][y: T2 ref r2] | B |- alias(x = y); e : T => G' ]]
  }
  \infrule[T-AliasPtr]{
    [[(T1 ref r1 + T2 ref r2) ~ (T1' ref r1' + T2' ref r2')]] \\
    [[ G | B |- T2' ]] \andalso [[ G | B |- T1' ]] \\
    [[ Th | G[x <- T1' ref r1][y <- (T2' ref r2') ref r] | B |- e : T => G' ]]
  }{
    [[ Th | G[x : T1 ref r1][y: (T2 ref r2) ref r] | B |- alias(x = *y); e : T => G' ]]
  }
  \infrule[T-Sub]{
    [[ G <: G' ]] \andalso
    [[ Th | G' | B |- e : T => G'' ]] \andalso
    [[ G'',T <: G''',T' ]] \andalso
    [[ B |- G' ]] \andalso [[ B |- T' => G''' ]]
  }{
    [[ Th | G | B |- e : T' => G''' ]]
  }
  \begin{center}
    $[[ T1 ~ T2]]$ iff $[[ empty |- T1 <: T2  ]]$ and $[[ empty |- T2 <: T1 ]]$.
  \end{center}
  \caption{Pointer manipulation and subtyping}
  \label{fig:pointer-typing}
\end{figure}

\begin{figure}[t]
  \leavevmode
  \bcprulessavespacetrue
  \begin{center}
  \infrule[Sub-Int]{
  [[G |= ph1 ==> ph2]]
  }{
   [[G |- {nu:int|ph1} <: {nu:int|ph2}]]
  }
  \infrule[Sub-Ref]{
    [[r1 >= r2]]
    \andalso
    [[ G |- T1 <: T2 ]]
  }{
    [[ G |- T1 ref r1 <: T2 ref r2 ]]
  }
  \infrule[Sub-TyEnv]{
    [[ forall x in G'.G|- G(x) <: G'(x) ]]
  }{
    [[ G <: G' ]]
  }
  \infrule[Sub-Result]{
    [[G,x:T <: G',x:T']] \andalso [[ x not in dom G ]]
  }{
    [[G,T <: G,T']]
  }
  \end{center}
  \bcprulessavespacefalse
  \caption{Rules for subtyping.}
  \label{fig:subtyping}
\end{figure}

\paragraph{Destructive Updates, Aliasing, and Subtyping}
We now discuss the handling of assignment, aliasing annotations,
and subtyping as described in \Cref{fig:pointer-typing}.
Although apparently unrelated, all three program forms concern
updating the refinements of (potentially) aliased reference cells.

Like the binding forms discussed above, \rn{T-Assign} splits the assigned
value's type into two types via the type addition operator,
and distributes these types between the right hand side of the
assignment and the reference contents.
Notice that refinement information in the fresh
contents are \emph{not} required to be consistent with
any previous refinement information.
In a system with unrestricted aliasing, this
typing rule would be unsound, as it could invalidate the refinements on
references that alias with the left hand side. However, the assignment rule
requires that the updated reference has an ownership of $1$,
which by the ownership type invariant guarantees aliases
with the updated reference have $0$ ownership, and
thus by well-formedness may only contain the $[[Top]]$ refinement.

\begin{example}
  We can type the program as follows:
  \begin{lstlisting}
    let x = mkref 5 in // $\color{comment-green}{[[x:{nu:int|nu=5} ref 1]]}$
    let y = x in // $\color{comment-green}{[[x:top1,y:{nu:int|nu=5} ref 1]]}$
    y := 4; assert(*y = 4) // $\color{comment-green}{[[x:top1,y:{nu:int|nu=4} ref 1]]}$
  \end{lstlisting}
  In this example and the following, we include type annotations within comments. We stress
  that these annotations are for expository purposes only; our tool can infer these types
  automatically with no manual annotations.
\end{example}

As described thus far, the type system is quite strict: if ownership
has been completely transferred from one reference to another, the
refinement information found in the original reference is effectively useless.
Additionally, once
a mutable pointer has been split through an assignment or let binding, there is no
way to recover mutability. The typing rule for
must alias assertions, \rn{T-Alias} and \rn{T-AliasPtr}, overcomes this restriction
by exploiting the must-aliasing information to
``shuffle'' or redistribute ownerships \emph{and refinements} between two
aliased pointers. The typing rule assigns
two fresh types $[[T1' ref r1']]$ and $[[T2' ref r2']]$ to the two operand pointers.
The choice of $[[T1']], [[r1']], [[T2']]$, and $[[r2']]$ is left open,
provided that the sum of the new types, $[[(T1' ref r1') + (T2' ref r2')]]$ is
equivalent (denoted $[[~]]$) to the sum of the original types.
Formally, $[[~]]$ is defined as in \Cref{fig:pointer-typing}; it implies
that any refinements in the two types must be logically equivalent and
that ownerships must also be equal.
\AI{It's a bit unfortunate that $[[~]]$ is menioned before subtyping is discussed (but the following description seems sufficient to understand the intuition).}
\AI{Why does $[[~]]$ compare two types under the empty type environment?
Could it use assumptions on other integer variables in $[[G]]$?}
This redistribution is sound precisely because the two references are
assumed to alias; the total ownership for the single memory cell pointed
to by both references cannot be increased by this shuffling. Further,
any refinements that hold for the contents of one reference must necessarily
hold for contents of the other and vice versa.

\begin{example}[Shuffling ownerships and refinements]
  \begin{lstlisting}
    let x = mkref 5 in // $\color{comment-green}{[[x:{nu:int|nu=5} ref 1]]}$
    let y = x in // $\color{comment-green}{[[x:top1,y:{nu:int|nu=5} ref 1]]}$
    y := 4; alias(x = y) // $\color{comment-green}{[[x:{nu:int|nu=4} ref 0.5,y:{nu:int|nu=4} ref 0.5]]}$    
  \end{lstlisting}
  Taking $[[ph]]$ to be $[[nu = 4]]$, the final type assignment for $[[x]]$ and $[[y]]$ is justified by
  \begin{align*}
    &[[top1 + {nu:int|ph} ref 1 = {nu:int|Top /\ ph} ref 1]][[~]]\\
    \,\,\,\,&[[{nu:int|ph/\ph} ref 1 = {nu:int|ph} ref 0.5 + {nu:int|ph} ref 0.5 ]]
  \end{align*}
\end{example}

The aliasing rule gives fine-grained control over ownership information. In particular,
this flexibility allows mutation through two aliased references within the same scope.
Provided sufficient aliasing annotations, the type system may shuffle ownerships between
one or more live references, enabling and disabling mutability as required. Although the
reliance on these annotations appear to decrease the practicality of such a type system,
we expect these aliasing annotations can be inserted by a conservative must-aliasing
analysis, and empirical experience from prior work \cite{suenaga2009fractional} shows
that only a small number of annotations are required for real-world programs.

\begin{example}[Shuffling Mutability]
  \label{exmp:shuffle-example}
  The following program uses two live, aliased references to mutate the same memory location:
  \begin{lstlisting}
    let x = mkref 0 in
    let y = x in (
      x := 1; alias(x = y); // $\color{comment-green}{[[x:{nu:int|nu = 0} ref 1,y:top1]]}$
      y := 2; alias(x = y); // $\color{comment-green}{[[x:top1,y:{nu:int|nu = 1} ref 1]]}$
      assert(*x = 2) // $\color{comment-green}{[[x:{nu:int|nu = 2} ref 0.5,y:{nu:int|nu=2} ref 0.5]]}$
    )
  \end{lstlisting}
  The types shown in the comments give the type environment under
  which the first statement on the line is typed. After the first aliasing
  statement the type system shuffles the (exclusive) mutability between $[[x]]$
  and $[[y]]$ to enable write to $[[y]]$. After the second aliasing statement
  the ownership in $[[y]]$ is split with $[[x]]$; notice
  that transferring all ownership from $[[y]]$ to $[[x]]$ would also yield a
  valid typing.
\end{example}

Finally, we describe the subtyping rule. The rules for subtyping types
and environments are shown in \Cref{fig:subtyping}. For base integer types,
the rules require the refinement of a supertype is a logical consequence of
the subtype's refinement; i.e., the subtyping rule allows weakening the refinement
on integer types. The subtype rule for references is \emph{covariant} in the type
of reference contents. It is widely known that in a type system with unrestricted aliasing
and mutable references such a rule is unsound: after coercing to a supertype,
a write into the coerced pointer may cause a later read through an aliased pointer to
yield a value that does not match the type of reference contents \cite{pierce2002types}. However, as in
the assign case, ownership types prevents this scenario; a write to the
coerced pointer requires the pointer to have ownership 1, which guarantees
any aliased pointers have the maximal type and provide no information about their contents
beyond simple types.

\begin{figure}[t]
  \leavevmode
    \infrule[T-Call]{
    [[ Th(f) = A < x1 : T1 ,, xn : Tn > -> <x1: T1' ,, xn : Tn' | T > ]] \\
    [[csub = [l:B/A] ]] \andalso [[ vsub = [y1/x1] ,, [yn/xn] ]] \\
    [[ Th | G[yi <- csub vsub Ti'], x : csub vsub T | B |- e : T' => G' ]] \\
    [[ x not in dom G' ]] \andalso
    [[ B |- T' => G' ]]
  }{
    [[ Th | G[yi: csub vsub Ti] | B |- let x = f l (y1,,yn) in e : T' => G']]
  }
  \infrule[T-FunDef]{
    [[ Th (f) = A <x1 : T1 ,, xn : Tn > -> < x1: T1' ,, xn : Tn' | T> ]] \\
    [[ Th | x1:T1 ,, xn:Tn | A |- e : T => x1: T1' ,, xn : Tn' ]]
  }{
    [[ Th |- f |-> (x1,..,xn) e ]]
  }
  \bcprulessavespacetrue
  \infrule[T-Funs]{
    \forall [[f |-> (x1, .., xn) e in D]].[[ Th |- f |-> (x1,..,xn) e ]] \\ [[ dom D = dom Th ]]
  }{
    [[ Th |-  D ]]
  }
  \hfil
  \infrule[T-Prog]{
    [[ Th |- D ]] \andalso [[ |- Th ]] \\
    [[ Th | empty | . |- e : T => G ]]
  }{
    [[ |- < D, e > ]]
  }
  \bcprulessavespacefalse
\caption{Program typing rules}
\label{fig:progTyping}
\end{figure}

\subsection{Interprocedural Fragment and Context-Sensitivity}
\label{sec:cs}
We now turn to a discussion of the interprocedural fragment of our
language, and how our type system propagates context information. The remaining
typing rules for our language are shown in \Cref{fig:progTyping}.
These rules concern the typing of function calls, function bodies, and
entire programs.

We first explain the \rn{T-Call} rule. The rule uses two substitution
maps. $[[vsub]]$ translates between the parameter names used in the
function type and actual argument names at the call-site. $[[csub]]$
instantiates all occurrences of $[[A]]$ with $[[ l : B ]]$, where $[[l]]$
is the label of the call-site and $[[B]]$ the typing context of the call. If $[[B]]$
is itself a context variable $[[A']]$, this substitution effectively
transforms any context prefix queries over $[[A]]$ in the argument/return types
into a queries over $[[A']]$. Intuitively, this substitution
represents incrementally refining the behavior of
the callee function with partial context information. Although the exact
concrete execution context of the callee (and therefore exact behavior)
is unknown, we at least know the exact context begins with $[[l]]$ and
can potentially use this knowledge to rule out certain behaviors.
To type check the function call the formal arguments are required to match the parameter
types (post substitution). Then the body of the let binding is
checked with the argument types updated to reflect the changes in the
function call (again, post substitution). This update is well-defined because
we require all function arguments be distinct as described in \cref{sec:language}.

Rule \rn{T-FunDef} type checks a function definition
$[[ f |-> (x1,..,xn) e]]$ against the function type given in $[[Th]]$.
As a convenience we assume that the parameter
names in the function type match the formal parameters in the function
definition. The rule checks that under an initial environment given
by the argument types, the function body produces a value of the
return type and transforms the arguments according to the output types.
Further, as mentioned above,
functions may be executed under many different contexts,
so function body type checking is performed under the type context
variable $[[A]]$ that occurs in the function type.

Finally, the rule for typing programs (\rn{T-Prog}) checks that
all function definitions are well-typed under a well-formed
function type environment, and that the entry point $[[e]]$
is well-typed in an empty environment. The program
entry point is always executed under the empty context $[[.]]$,
which is reflected in the typing context of $[[e]]$.

\begin{example}[Simple 1-CFA]
  \label{exmp:1cfa}
  Recall the program in \Cref{fig:running-example} in \Cref{sec:intro}; assume
  the function calls are labeled as follows:
\begin{lstlisting}
p := get$^{\ell1}$(p) + 1;
// ...
r := get$^{\ell2}$(r) + 1;
\end{lstlisting}
  Taking $[[T]]$ to be the type shown in \Cref{exmp:cs-type-example}:
  \[
    [[{nu:int|(l1 <= A ==> nu = 3) /\ (l2 <= A ==> nu = 4)}]]
  \]
  we can give \lstinline{get} the function type $[[ A <z: T ref 1> -> <z: T ref 1 | T>]]$.
\end{example}
\begin{example}[Simple 2-CFA]
  To see how to propagate context information across multiple calls, consider
  the following change to code in \Cref{exmp:1cfa}:
  \begin{lstlisting}
    get_real(z) { *z }
    get(z) { get_real$^{[[l3]]}$(z) }
  \end{lstlisting}
  The type of \imp{get} remains as in \Cref{exmp:1cfa}, and taking $[[T]]$
  to be \[
    [[ {nu:int| (l3 l1 <= A' ==> nu = 3) /\ (l3 l2 <= A' ==> nu = 4) } ]]
  \]
  the type of \imp{get_real} is: $[[ A' <z: T ref 1> -> <z: T ref 1 | T>]]$.

  We focus on the typing of the call to \imp{get_real} in \imp{get}.
  The call is typed in context $[[A]]$ and a type environment where
  \imp{z} is given type:
  \[
    [[ {nu:int|(l1 <= A ==> nu = 3) /\ (l2 <= A ==> nu = 4)} ref 1]]
  \]
  Applying the substitution $[[ [l3 : A / A'] ]]$ to the argument
  type of \imp{get_real} yields the expected type:
  \begin{align*}
    & [[ {nu:int|(l3 l1 <= l3:A ==> nu = 3) /\ (l3 l2 <= l3:A ==> nu = 4)} ref 1 ]][[~]] \\
    & \,\,\,\,\, [[ {nu:int|(l1 <= A ==> nu = 3) /\ (l2 <= A ==> nu = 4)} ref 1]]
  \end{align*}
  which is exactly the type of \imp{z}.
  A similar derivation applies to
  give the return type of \imp{get_real} and thus \imp{get}.
\end{example}

\subsection{Soundness}
\label{sec:soundness}
We have proven that any closed program that type checks according to
the rules above will never experience an assertion failure.
We formalize this claim with the following soundness theorem.

\begin{theorem}[Soundness]
  \label{thm:soundness}
  For any program $[[ <D, e> ]]$ such that $[[ |- <D, e> ]]$ then
  $[[ <empty, empty, ., e> !-->*D AssertFail ]]$.
  
  Further, any well-typed program either diverges, halts in the configuration $[[AliasFail]]$, or
  halts in a configuration $[[<H, R, ., x>]]$ for some $[[H]], [[R]]$ and $[[x]]$, i.e.,
  evaluation does not get stuck.
\end{theorem}
\begin{proof}[Proof Sketch]
  We omit a full proof for space details, the full proof can be found
  in the accompanying appendix.

  We define a typing relation for runtime configurations; well-typed
  configurations satisfy the following invariants
  \begin{enumerate}
  \item The value of heap locations and program variables satisfy the refinements given in the program typing judgment, and
  \item The ownership given to every memory cell never exceeds 1.
  \end{enumerate}
  We then prove a standard preservation lemma, showing that
  well-typedness is preserved by our step relation.  By defining the
  $[[AssertFail]]$ configuration as ill-typed, we have the first result.

  The second result follow from our preservation lemma and a standard progress lemma.
\end{proof}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:

%  LocalWords:  Suenaga Kobayashi deallocation ownerships CFA
%  LocalWords:  Formedness formedness supertype subtype's covariant
