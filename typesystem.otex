\section{Typing}
\label{sec:typesystem}
We now introduce a refinement type system combined
with fraction ownership types that guarantees runtime
assertion failures do not occur. We first present
a brief background on ownership types (\cref{sec:ownership}),
before describing our fractional ownership refinement types
(\cref{sec:types}), the type system (\cref{sec:intra-types,sec:cs}),
and finally close with our soundness statement
(\cref{sec:soundness}).

\AI{\rn{T-Let} loses information that $x$ is equal to $y$ (unlike \rn{T-LetInt}).}

\AI{\rn{T-Let} discards all the refinement on \(x\).  Probably we should propagate it to $\tenv'$.}

\AI{\rn{T-Let} and \rn{T-LetInt} can be merged.}

\AI{\rn{T-Call} requires actual arguments to be variables introduced at the end of the type environment.  This is not a restriction because one can introduce let-expressions before a function call and alias-expressions after the call.}

\AI{$\varepsilon$ in \rn{T-Prog} stands for the empty string.}

\subsection{Background: Fractional Ownership Types}
\label{sec:ownership}
Before describing our type system in detail, we provide a brief
overview of the fractional ownership type system upon which it
is built. The fractional ownership system of
Suenaga and Kobayashi \needcite 
ensures safe memory access in low-level languages like C; it
was later extended by Suenaga et al. \needcite to also guarantee
correct allocation/deallocation of shared resources in concurrent programs.
Fractional ownership types elaborate reference
types with an ownership $[[r]]$, which is a rational number that
ranges from $[0,1]$. An ownership of $[[1]]$ indicates that a pointer
has exclusive ownership of a memory cell, and may freely read or write
the contents of the cell. An ownership in the range $(0,1)$
indicates a pointer with shared ownership, through which
a memory cell can be read but \emph{not} modified. Finally, a pointer
with $0$ ownership may be neither read nor modified.

The fractional ownership type systems in \needcite enforced the
following key invariant: the total ownership of all pointer types that
point to the same memory cell never exceeds 1. As an immediate
consequence, given a pointer $p$ with ownership $1$, no other readable
pointers that alias with $p$ may exist (otherwise the total ownership
would exceed 1). The type system is designed such that when an alias
to a pointer $p$ is created, the current ownership of $p$ is divided
between the new alias and $p$ (hence \emph{fractional} ownership).
Further, on writes to a reference $p$,
the type system may destructively change
the type of $p$'s contents to be inconsistent with previous content type.
In a language with unrestricted aliasing, such an operation would
be unsound, but the above invariant guarantees that
at the time of update no readable pointers that expect the old
contents remain.
This guarantee enables our combined type system to destructively
(and incompatibly) change the refinements of mutable memory cells;
readable pointers that expect values constrained by the previous
refinement cannot exist when an update occurs.

\begin{remark}
  In the fractional ownership type systems cited above,
  an ownership also represents an \emph{obligation} to
  ensure the memory referenced by a pointer was eventually
  freed. Further, a $0$ ownership was used for pointers that
  had been freed to ensure dangling pointers were not used.
  However, as mentioned in \cref{sec:semantics}, our language
  does not support manually freeing memory which
  significantly simplifies some of the technical components
  of our formalism.
\end{remark}

\begin{figure}[t]
  \[
    \begin{array}{rrcl}
      \text{\footnotesize Types} & [[ T ]] &::=& [[ {nu:int|ph} ]] \mid [[ T ref r ]] \\
      \text{\footnotesize Ownership} & [[ r ]] &::=& [0,1] \\
      \text{\footnotesize Refinements} & [[ph]] & ::= & [[ ph1 \/ ph2 ]] \mid [[ !ph ]] 
                                                        \mid [[ pfun(pval1,..,pvaln) ]] \mid
                                                        [[ pval1 = pval2 ]] \mid [[ Top ]] \\
                                 & & \mid & \mathcal{CP} \\
      \text{\footnotesize Refinement Values} & [[ pval ]] & ::= & [[ x ]] \mid [[ v ]] \mid [[ nu ]] \\

                                 & & & \\
      \text{\footnotesize Function Types} & [[FT]] & ::= & [[ A <x1 : T1 ,, xn : Tn> -> <x1: T1' ,, xn : Tn' | T> ]] \\
      \text{\footnotesize Context Variables} & \CVar & ::= & [[A1]], [[A2]], \ldots \\
      \text{\footnotesize Concrete Context} & [[ ll ]] & ::= & [[ l : ll ]] \mid [[ . ]] \\
      \text{\footnotesize Parameterized Context} & [[ plhs ]] & ::= & [[ ll ]] \mid [[ ll A ]] \\
      \text{\footnotesize Context Query Predicates} & [[CQP]] & ::= & [[ plhs != ll ? ]] \mid [[ plhs = ll ? ]] \\
      \text{\footnotesize Typing Context} & [[ B ]] & ::= & [[ A ]] \mid [[ ll ]]
    \end{array}
  \]
  \caption{Grammar of types, refinements, and contexts}
  \label{fig:types}
\end{figure}

\subsection{Types and Contexts}
\label{sec:types}
The grammar of types is given in \cref{fig:types}.
Our type system has two type constructors: references and integers. $[[ T ref r ]]$ is the
type of a (non-null) reference to a value of type $[[ T ]]$.
$[[r]]$ is an \emph{ownership}, which ranges from $[[0]]$ indicating a
pointer that provides no refinement information and cannot be
written, to $[[1]]$ indicating a pointer with exclusive
ownership that can be read and written. Ownership values between these two
extremes indicate a pointer that is readable but not writable and which
has up-to-date refinement information. Further,
the ownership type system described above ensures that no mutable aliases
exist for a pointer with ownership in the range $(0,1]$. \NK{I do not quite understand the part
 ``and for which ...''}

The base types of our type system are integers that are refined with a
predicate $[[ph]]$.  The language of predicates is built using the
standard logical connectives of first-order logic,
with (in)equality between variables and integers, and atomic predicate symbols
$[[pfun]]$ as the basic atoms. As is standard \needcite,
we include a special ``value'' variable $[[nu]]$, which represents the
value being refined by the predicate. For simplicity, we omit the
connectives $[[ ph /\ ph ]]$ and $[[ ph ==> ph ]]$; they can be written
as derived forms using the given connectives.
We leave the choice of underlying theory from which $[[pfun]]$ symbols
are drawn unspecified, provided it is decidable. The atoms $\mathcal{CP}$
are context predicates, which are used for context sensitivity as
explained below.

\begin{example}
  $[[{nu:int | nu > 0}]]$ is the type of integers that are strictly
  positive.  $[[{nu:int | nu = 3} ref 0.5]]$ is the type of immutable,
  readable references to integers that are exactly equal to $3$.
\end{example}

\paragraph{Contexts and Context Polymorphism}
Our type system achieves context sensitivity
by having function types to depend on where and how a function
is called, i.e., the \emph{execution context} of the function invocation.
Our system represents a \emph{concrete} execution contexts with
string of call site labels (or just ``call strings''),
defined as $[[ll]] ::= [[.]] \mid [[l : ll ]]$.
As is standard, the string $[[ l : ll ]]$ abstracts
an execution context where the most recent, active function call occurred
at call site $[[ l ]]$ which itself was executed in a context abstracted
by $[[ ll ]]$. In addition our system includes \emph{context variables}
drawn from a finite domain $\CVar$ and ranged over by $[[A1]], [[A2]], \ldots$.
A context variable (like type variables in parametric polymorphism \needcite[?])
represents an arbitrary, unknown context. Function types in our language
are polymorphic over a distinguished context variable, and argument
and return types may depend on that context varaible. Intuitively,
this context variable represents the many different execution contexts
under which a function may be called.
As a result, a function may have different behaviors depending on the
choice of concrete context used to instantiate the context variable,
i.e., depending on where the function is called.

Our language of function types expreses this polymorphism by universally quantifying
over a context variable $[[A]]$; the argument, output, and return types may depend
on this $[[A]]$ with \emph{context predicates} described below. A function type
takes a tuple of zero or more argument types $[[Ti]]$ to the same number of \emph{output types}
$[[Ti']]$. These output types express the side effects that may occur within a method.
Recall that our type system language supports destructive updates to refinements
on memory locations; these output types express these changes. In addition, function types
have a direct return value $[[T']]$. Notice that the argument and output types are given
names: the refinements of the argument and output types may refer to these variable
names in their refinements.

Types within a function type may depend on the function's calling context
by including \emph{context query predicates} in their refinements.
A context query predicate $[[CQP]]$ takes the
form $[[ plhs = ll? ]]$, and is true iff $[[ll]]$ is a
prefix of $[[plhs]]$. We will also write $[[ plhs != ll? ]]$ as a more convenient
syntax for $[[ !(plhs = ll?) ]]$.
$[[plhs]]$ is a parameterized context, which
may be a concrete context $[[ll]]$ or an unknown context $[[A]]$
with a (potentially empty) concrete prefix; we abbreviate $[[ . A ]]$ as
$[[A]]$.
Intuitively, a refinement $[[ A = ll ? ==> ph ]]$ on a value
asserts $[[ ph ]]$ holds in any concrete execution context
with prefix $[[ll]]$, and provides no information in any other
context. Notice that while our grammar allows context query predicates
of the form $[[ ll2 A = ll1 ? ]]$, any such query can be reduced
to a predicate of the form $[[ A = ll2' ? ]], [[Top]], [[Bot]]$ using
the following equivalences:
\begin{align*}
  [[ A = .? <=> Top ]] && [[ l1 : ll1' A = l1 : ll2' ? <=> ll1' A = ll2' ? ]] && [[ l1 : ll1' A = l2 : ll2' ? <=> Bot ]]
\end{align*}
Additionally, a context query predicate over a concrete context can always be
immediately reduced to either $[[Top]]$ or $[[Bot]]$. We therefore do not expect
such predicates to be used directly in refinements, but include them for the purposes
of proving soundness (see \cref{sec:soundness} and the appendix for details).

\begin{example}
  The type $[[ {nu:int| (A = l1? ==> nu > 0) /\ (A != l1? ==> nu < 0)} ]]$ represents
  an integer that is strict positive if the most recent active
  function call site is $[[l1]]$, or is strictly negative otherwise.
\end{example}

As types in our type system may contain context variables, our typing judgment
(introduced below) includes a typing context $[[B]]$, which is either a single
context variable $[[A]]$ or a concrete context $[[ll]]$. This typing context
represents the assumptions about the \emph{execution} context of the term being
typed. If the typing context is a context variable $[[A]]$, then no assumptions
can be made about the execution context of the term, although types
may be dependent upon the context using context query predicates described above.
Accordingly, function bodies are typed under the context variable
universally quantified over in the corresponding function type; i.e.,
no assumptions can be made about the exact execution context of the function body.
As in parametric polymorphism, our type rules are designed such that consistenct
substitution of a concrete context $[[ll]]$ for a context variable $[[A]]$
in a typing derivation yields a valid type derivation under concrete context $[[ll]]$.

\paragraph{Well Formedness}
We impose two well-formedness conditions on types:
refinement well-formedness and ownership well-formedness.
Refinement well-formedness (defined in \cref{fig:type-wf})
ensures that program and context variables in refinements
are consistent with a typing context and type environment
respectively.
The ownership condition is purely syntactic:
$[[ T ]]$ is ownership well-formed if $[[ T = T' ref 0 ]]$ implies
$[[ T' = topn ]]$ for some $[[n]]$. $[[topi]]$ is the ``maximal'' type
of a chain of $[[i]]$ references, and is defined inductively as
$[[top0 = {nu:int|Top}]], [[topi = topi-1 ref 0]]$.

The ownership well-formedness condition ensures that aliases introduced with heap writes do not
violate the ownership invariant \emph{and} that refinements remain consistent
in the presence of heap writes. Recall that the ownership type system ensures
that the ownership of a reference drops to 0 when a mutable alias to that
reference is created.
Any mutations through the alias will therefore be consistent with the
``no information'' $[[ Top ]]$ refinement required by the
well-formedness condition.  Our type system can also exploit aliasing
information to restore the read/write capabilities to a pointer (i.e.,
restore an ownership greater than 0) while simultaneously updating its
refinement to reflect any mutations through aliases.

\begin{figure}[t]
  \scriptsize
  \leavevmode
  \infrule[WF-Env]{
    [[ forall x in G. G | B |- G(x) ]]
  }{
    [[B |- G]]
  }
  \infrule[WF-Int]{
    [[ST(G), nu:int | B |- ph]]
  }{
    [[G | B |- { nu:int|ph} ]] 
  }
  \infrule[WF-Ref]{
    [[G | B |- T]]
  }{
    [[G | B |- T ref r ]]
  }
  \infrule[WF-Phi]{
    [[FPV(ph)]] \subseteq \set{x \mid [[x in Gst /\ Gst(x) = int]]} \andalso
    [[FPCV(ph)]] \subseteq [[CV(B)]]
  }{
    [[Gst | B |- ph]]
  }
  \infrule[WF-Result]{
    [[G | B |- T]] \andalso
    [[B |- G]]
  }{
    [[ B |- T => G ]]
  }
  \infrule[WF-FunType]{
    [[ A |- x1:T1,,xn:Tn ]] \\ [[ A |- T => x1:T1',,xn:Tn' ]]
  }{
    [[ |- A <x1:T1,,xn:Tn> -> <x1:T1',,xn:Tn'|T> ]]
  }
  \infrule[WF-FunEnv]{
    [[ forall f in Th.|- Th(f)]]
  }{
    [[ |- Th ]]
  }
  \begin{minipage}[t]{0.48\textwidth}
  \[
    \begin{array}{lrcl}
      \text{Simple Types} & [[ST]] & ::= & [[int]] \mid [[ ST ref ]] \\
      \text{Simple Ty. Env} & [[Gst]] & ::= & [[empty]] \mid [[ Gst,x:ST]] \\
      \text{Lifting} & [[ [S {nu:int|ph} ] ]] & = & [[ int ]] \\
                          & [[ [S T ref r] ]] & = & [[ [S T ] ref ]] \\
                          & [[ ST(empty) ]] & = & [[ empty ]] \\
                          & [[ ST(G, x:T) ]] & = & [[ ST(G),x: [S T ] ]] 
    \end{array}
  \]
\end{minipage}
\begin{minipage}[t]{0.485\textwidth}
  \[
    \begin{array}{rrl}
      \text{Free Ctxt Vars} & [[FPCV(ph1 \/ ph2)]] & = [[FPCV(ph1) U FPCV(ph2) ]] \\
                            & [[FPCV(!ph)]] & = [[ FPCV(ph) ]] \\
                            & [[FPCV(pval1 = pval2)]] & = [[FPCV(pfun(pval1,..,pvaln)) = null ]] \\
                            & [[FPCV(plhs = ll ?)]] & = [[FPCV(plhs)]] \\
                            & [[FPCV(ll A)]] & = [[ {A} ]] \\
                            & [[FPCV(ll) ]] & = [[ null ]] \\
      \text{Ctxt Vars} & [[CV(ll)]] & = [[ null ]] \\
                            & [[ CV(A)]] & = [[{A}]]
    \end{array}
  \]
\end{minipage}
  \caption{Well-formedness of types and environments}
  \label{fig:type-wf}
\end{figure}

\begin{figure}[t]
  \scriptsize
  \leavevmode
  \infrule[T-Var]{
  }{
    [[ Th | G [ x : T1 + T2] | B |- x : T1 => G[ x <- T2 ] ]]
  }
  \infrule[T-Let]{
    [[ Th | G [ y <- T1 /\ y y = T1 x  ], x : (T2 /\ x x = T2 y) | B |- e : T => G']] \andalso
    [[B |- T => G' \ x]]
  }{
    [[ Th | G[y: T1 + T2] | B |- let x = y in e : T => G' \ x]]
  }
  \infrule[T-LetInt]{
    [[ Th | G, x:{nu : int | nu = nn } | B |- e : T => G']] \andalso
    [[B |- T => G' \ x]]
  }{
    [[ Th | G | B |- e : T => G' \ x]]
  }
  \infrule[T-If]{
    [[ Th | G[x <- {nu:int | ph /\ nu = 0 }] | B |- e1 : T => G' ]] \\
    [[ Th | G[x <- {nu:int | ph /\ nu != 0}] | B |- e2 : T => G' ]]
  }{
    [[ Th | G[x : {nu:int|ph}] | B |- ifz x then e1 else e2 : T => G' ]]
  }
  \infrule[T-MkRef]{
    [[ Th | G[y <- T1],x : (T2 /\ x x = T2 y) ref 1 | B |- e : T => G']] \andalso
    [[ B |- T => G' \ x ]]
  }{
    [[ Th | G[y : T1 + T2] | B |- let x = mkref y in e : T => G' \ x ]]
  }
  \infrule[T-Deref]{
    [[ Th | G[y <- T' ref r], x : T2 | B |- e : T => G']] \andalso
    [[ B |- T => G' \ x ]] \andalso [[ T' ]] = \begin{cases}
      [[ T1 /\ y y = T1 x ]] & [[r > 0]] \\
      [[ T1 ]] & [[ r = 0 ]]
    \end{cases} 
  }{
    [[ Th | G[y: (T1 + T2) ref r] | B |- let x = *y in e : T => G' \ x ]]
  }
  \infrule[T-Seq]{
    [[ Th | G | B |- e1 : T' => G' ]] \andalso
    [[ Th | G' | B |- e2 : T'' => G'' ]]
  }{
    [[ Th | G | B |- e1 ; e2 : T'' => G'' ]]
  }
  \infrule[T-Assert]{
    [[ G |= ph ]] \andalso
    [[ ST(G) | . |- ph ]] \andalso
    [[ Th | G | B |- e : T => G' ]]
  }{
    [[ Th | G | B |- assert(ph); e : T => G']]
  }
  \[
    [[ G \ x = G' <=> dom G' U {x} = dom G /\ forall y in dom G'. G'(y) = G(y) ]]
  \]
  \caption{Expression typing rules.}
  \label{fig:intra-type}
\end{figure}

\begin{figure}
  \scriptsize
  \leavevmode
    \infrule[T-Assign]{
    (\text{The shapes of $[[T']]$ and $[[T2]]$ are similar}) \\
    [[ Th | G[x <- T1][y <- (T2 /\ y y = T2 x) ref r] | B |- e : T => G']] \\
  }{
    [[ Th | G[x: T1 + T2][y : T' ref 1] | B |- y := x; e : T => G']]
  }
  \infrule[T-Alias]{
    [[(T1 ref r1 + T2 ref r2) ~ (T1' ref r1' + T2' ref r2')]] \\
    [[ Th | G[x <- T1' ref r1'][y <- T2' ref r2'] | B |- e : T => G']]
  }{
    [[ Th | G[x : T1 ref r1][y: T2 ref r2] | B |- alias(x = y); e : T => G' ]]
  }
  \infrule[T-AliasPtr]{
    [[(T1 ref r1 + T2 ref r2) ~ (T1' ref r1' + T2' ref r2')]] \\
    [[ Th | G[x <- T1' ref r1][y: (T2' ref r2') ref r] | B |- e : T => G' ]]
  }{
    [[ Th | G[x : T1 ref r1][y: (T2 ref r2) ref r] | B |- alias(x = *y); e : T => G' ]]
  }
  \infrule[T-Sub]{
    [[ G <: G' ]] \andalso
    [[ Th | G' | B |- e : T => G'' ]] \andalso
    [[ G'',T <: G''',T' ]] \\
    [[ B |- G' ]] \andalso [[ B |- T' => G''' ]]
  }{
    [[ Th | G | B |- e : T' => G''' ]]
  }
  \caption{Pointer manipulation and subtyping}
  \label{fig:pointer-typing}
\end{figure}

\subsection{Intraprocedural Type System}
\label{sec:intra-types}
We now introduce the type system for the intra-procedural fragment of
our language. Accordingly, this section focuses on interplay of
mutability and refinement types. The typing rules are given in
\cref{fig:intra-type,fig:pointer-typing}.  
A typing judgment takes the
form $[[ Th | G | B |- e : T => G' ]]$, which indicates that $[[e]]$
is well-typed under a type environment $[[G]]$, function type
environment $[[Th]]$, and typing context $[[B]]$
and evalutes to a type $[[T]]$ and modifies the input environment
to produce $[[G']]$. A type environment $[[G]]$ is a finite
mapping from variable names to refinement types $[[T]]$.
We write $[[G[x: T] ]]$ to denote a type environment $[[G]]$ such
that $[[x in dom G /\ G(x) = T]]$, $[[G,x:T]]$ to indicate the
extension of $[[G]]$ with the type binding $[[x : T]]$, and $[[G[x <- T] ]]$
to indicate the type environment $[[G]]$ with the binding of $[[x]]$
updated to $[[T]]$. $[[B]]$ is defined as in \cref{sec:types}
and $[[Th]]$ is a finite map from function names to function types.

\begin{remark}
  \label{rmk:env-mapping}
  The treatment of type environments as mappings instead of sequences
  in a dependent type system is somewhat non-standard. However, this
  approach does not cause problems in our formalism as we do not include
  higher-order functions; all arguments are bound simultaneously
  in our abstract semantics.
\end{remark}

\begin{figure}[t]
  \leavevmode
  \infax[Tadd-Int]{
    [[{nu:int|ph1} + {nu:int|ph2} = {nu:int|ph1 /\ ph2}]]
  }
  \infax[Tadd-Ref]{
    [[T1 ref r1 + T2 ref r2 = (T1 + T2) ref r1 + r2]]
  }
  \caption{Rules for $[[ T1 + T2 ]]$.}
  \label{fig:addition}
\end{figure}

The typing rules in \cref{fig:intra-type} handle the relatively
standard features in our language. The most noteworthy feature is the
type addition operator used in \rn{T-Let}, \rn{T-MkRef}, and
\rn{T-Deref} forms. Intuitively, the type addition operator
``splits'' the ownership \emph{and} refinement information
between the assigned value and the newly bound value. 
Formally, it is defined as the least commutative partial
operation that satisfies the rules in \cref{fig:addition}.  According
to the well-formedness condition, if the entirety of ownership is
transferred to one of the result types, all refinements in the other
type are $[[ Top ]]$.

The let bindings (\rn{T-Let}, \rn{T-MkRef}, \rn{T-Deref}, and
\rn{T-LetInt}) introduce new bindings based on the right hand side,
and analyze the let body $[[e]]$, in this new environment. The typing
rule for each form requires the type and result environment of the
let body to be well-formed after the removal of the bound variable $[[x]]$.
This requirement can be met by applying the subtyping rule (see below)
to weaken refinements to no longer mention $[[x]]$. As in other refinement
type systems \needcite, this requirement is critical for ensuring soundness.

Our type system also tracks path information. Specifically, In the \rn{T-If}
rule, we update the refinement on the condition variable in the respective
branches to indicate whether said variable must be zero. By requiring
both branches produce the same output type environment, we guarantee
that these conflicting refinements are rectified within the
type derivations of the two branches. Further, when creating bindings our
type system can track equalities between integer values. We use the
strengthening operation $[[ T /\ x ph ]]$ and typed equality
proposition $[[ x = T y]]$, defined respectively as:
\begin{align*}
  [[ T /\ y ph' ]] = \begin{cases}
    [[ { nu: int | ph /\ [nu/y]ph' }]] & [[ T = { nu: int | ph } ]] \\
    [[ T ]] & o.w.
    \end{cases} &&
  [[ x = T y ]] = \begin{cases}
    [[ x = y ]] & [[ T = {nu:int|ph} ]] \\
    [[ Top ]] & o.w.
  \end{cases}
\end{align*}
\JT{The above is very ugly}
Where $[[FPV(ph)]]$ are the free variables that appear in predicate
$[[ph]]$.  \NK{How about $y =_{\tau} x\ ref$ in \rn{T-Assign}?}
\JT{unfortunate ambiguity in the rules, fixed with parens}
We do not track equalities between references or between
the contents of reference cells, as doing so would violate
our refinement well-formedness condition. Notice also that the
equality tracking in the \rn{T-Deref} case is \emph{conditionally}
applied, depending on the ownership of the dereferenced pointer. 

The rule for type checking assert statements has the precondition
$[[ G |= ph ]]$ which is defined to be $[[|= [G] ==> ph]]$. $[[ [G] ]]$
lifts the refinements on the integer valued variables into a proposition
in the deciable logic used for verification. This denotation
operation is defined as:
\[
\begin{array}{rlcrl}
  [[ [empty] ]] &= [[ Top ]] & \hspace{1em} &  [[ [{nu:int|ph}] y ]] & = [[ [y/nu]ph ]] \\
  [[ [G,x: T] ]] &= [[ [G] /\ [T] x ]] &   &  [[ [T' ref r] y ]] & = [[ Top ]] \\
\end{array}
\]
If the formula $[[ [G] ==> ph]]$
is valid, then under any valuation of program variables that satisfy
the refinements in $[[ [G] ]]$, the predicate $[[ph]]$ must be true and the
assertion may not fail. (From the well-formedness requirement on $[[ph]]$
any free program variables within $[[ph]]$ must be bound within $[[G]]$).
This intuition forms the foundation of our
soundness claim (\cref{sec:soundness}).

\paragraph{Destructive Updates, Aliasing, and Subtyping}
We now discuss the handling of assignment, aliasing annotations,
and subtyping as described in \cref{fig:pointer-typing}.
Although apparently unrelated, all three program forms concern
updating the refinements of (potentially) aliased reference cells.

Like the binding forms discussed above, \rn{T-Assign} splits the assigned
value's type into two types via the type addition operator,
and distributes these types between the right hand side of the
assignment and the reference contents.
Notice that refinement information in the fresh
contents are \emph{not} required to be consistent with
any previous refinement information.
In a system with unrestricted aliasing, this
typing rule would be unsound, as it could invalidate the refinements on
references that alias with the left hand side. However, the assignment rule
requires that the updated reference has an ownership of $1$,
which by the ownership system invariant guarantees any pointers
that alias with the updated reference have $0$ ownership, and
thus by well-formedness have the $[[Top]]$ refinement.

\begin{example}
  We can type the program as follows:
  \begin{lstlisting}
    let x = mkref 5 in // $\color{comment-green}{[[x:{nu:int|nu=5} ref 1]]}$
    let y = x in // $\color{comment-green}{[[x:top1,y:{nu:int|nu=5} ref 1]]}$
    y := 4; assert(*y = 4) // $\color{comment-green}{[[x:top1,y:{nu:int|nu=4} ref 1]]}$
  \end{lstlisting}
\end{example}

\begin{figure}
  \leavevmode
  \infrule[TEq-Ref]{
    [[T1 ~ T2]] \andalso [[r1]] = [[r2]]
  }{
    [[T1 ref r1 ~ T2 ref r2]]
  }

  \infrule[TEq-Int]{
    [[|= ph1 <=> ph2]] \andalso [[ FPV(ph1) = FPV(ph2) ]] \andalso [[ FPCV(ph1) = FPCV(ph2) ]]
  }{
    [[ {nu:int | ph1} ~ {nu:int | ph2} ]]
  }
  \caption{Rules for type equality}
  \label{fig:equality}
\end{figure}

As described thus far, the type system is quite strict: if ownership
has been completely transferred from one location to another, the
original location is effectively unusable. Additionally, once
a mutable pointer has been split through an assignment, there is no
way to recover a mutable pointer. The typing rule for
must alias assertions, \rn{T-Alias} and \rn{T-AliasPtr}, overcomes this restriction
by exploting the aliasing information to
``shuffle'' ownerships \emph{and refinements} between two
aliased pointers. The typing rule assigns
two fresh types $[[T1']]$ and $[[T2']]$ to the two operand pointers;
the sum $[[T1' + T2']]$ must be equal modulo logical equivalence
(denoted $[[~]]$) to the sum of the original types. Formally, $[[~]]$
is defined as the least relation closed under the rules show in
\cref{fig:equality}.

The definition of $[[~]]$ ensures the total ownerships between
the two types are equal, and as the two operands are assumed
to alias, the type system may therefore freely redistribute
ownerships of the two references withou violating the
ownership invariant. This shuffling operation can also be used to
propagate refinement updates caused by destructive updates.

\begin{example}[Shuffling ownerships and refinements]
  \begin{lstlisting}
    let x = mkref 5 in // $\color{comment-green}{[[x:{nu:int|nu=5} ref 1]]}$
    let y = x in // $\color{comment-green}{[[x:top1,y:{nu:int|nu=5} ref 1]]}$
    y := 4; alias(x = y) // $\color{comment-green}{[[x:{nu:int|nu=4} ref 0.5,y:{nu:int|nu=4} ref 0.5]]}$    
  \end{lstlisting}
  Taking $[[ph]]$ to be $[[nu = 4]]$, the final type assignment for $[[x]]$ and $[[y]]$ is justified by
  \begin{align*}
    &[[top1 + {nu:int|ph} ref 1 = {nu:int|ph} ref 1]][[~]]\\
    \,\,\,\,&[[{nu:int|ph/\ph} ref 1 = {nu:int|ph} ref 0.5 + {nu:int|ph} ref 0.5 ]]
  \end{align*}
\end{example}

\begin{figure}
\leavevmode
\infrule[Sub-Int]{
  [[G |= ph1 ==> ph2]]
  }{
   [[G |- {nu:int|ph1} <: {nu:int|ph2}]]
  }
  \infrule[Sub-Ref]{
    [[r1 >= r2]]
    \andalso
    [[ G |- T1 <: T2 ]]
  }{
    [[ G |- T1 ref r1 <: T2 ref r2 ]]
  }
  \infrule[Sub-TyEnv]{
    [[ forall x in G'.G|- G(x) <: G'(x) ]]
  }{
    [[ G <: G' ]]
  }
  \infrule[Sub-Result]{
    [[G,x:T <: G',x:T']] \andalso [[ x not in dom G ]]
  }{
    [[G,T <: G,T']]
  }
  \caption{Rules for subtyping.}
  \label{fig:subtyping}
\end{figure}

Finally, we describe the subtyping rule. The rules for subtyping types
and environments are shown in \cref{fig:subtyping}. For base integer types,
the rules require the refinement of a supertype is a logical consequence of
the subtype's refinement; i.e., the subtyping rule allows weakening the refinement
on integer types. The subtype rule for references is \emph{covariant} in the type
of reference contents. It is widely known that in a type system with unrestricted aliasing
and mutable references such a rule is unsound: after coercing to a supertype,
a write into the coerced pointer may cause a later read through an aliased pointer to
yield a value that does not match the type of reference contents. However, as in
the assign case, the ownership type system prevents this scenario; a write to the
coerced pointer requires the pointer to have ownership 1, which guarantees
any aliased pointers have the maximal type and provide no information about their contents.

\begin{figure}[t]
  \leavevmode
    \infrule[T-Call]{
    [[ Th(f) = A < x1 : T1 ,, xn : Tn > -> <x1: T1' ,, xn : Tn' | T > ]] \\
    [[csub = [l:B/A] ]] \andalso [[ vsub = [y1/x1] ,, [yn/xn] ]] \\
    [[ Th | G[yi <- csub vsub Ti'], x : csub vsub T | B |- e : T' => G' ]] \\
    [[ B |- T' => G' \ x]]
  }{
    [[ Th | G[yi: csub vsub Ti] | B |- let x = f l (y1,,yn) in e : T' => G' \ x]]
  }
  \infrule[T-FunDef]{
    [[ Th (f) = A <x1 : T1 ,, xn : Tn > -> < x1: T1' ,, xn : Tn' | T> ]] \\
    [[ Th | x1:T1 ,, xn:Tn | A |- e : T => x1: T1' ,, xn : Tn' ]]
  }{
    [[ Th |- f |-> (x1,..,xn) e ]]
  }
  \infrule[T-Funs]{
    \forall [[f |-> (x1, .., xn) e in D]].[[ Th |- f |-> (x1,..,xn) e ]]
  }{
    [[ Th |-  D ]]
  }
  \infrule[T-Prog]{
    [[ Th |- D ]] \andalso [[ |- Th ]] \andalso
    [[ Th | empty | . |- e : T => G ]]
  }{
    [[ |- < D, e > ]]
  }
\caption{Program typing rules}
\label{fig:progTyping}
\end{figure}

\subsection{Interprocedural Fragment and Context-Sensitivity}
\label{sec:cs}
We now turn to a discussion of the interprocedural fragment of our
language, and how our type system propagates context information. The remaining
typing rules for our language are shown in \cref{fig:progTyping}.
These rules concern the typing of function calls, function bodies, and
entire programs.

We first explain the \rn{T-Call} rule. The rule uses two substitution
maps. $[[vsub]]$ translates between the parameter names used in the
function type and actual argument names at the call-site. $[[csub]]$
instantiates all occurrences of $[[A]]$ with $[[ l : B ]]$, where $[[l]]$
is the label of the callsite. If $[[B]]$
is itself a context variable $[[A']]$, this substitution effectively
transforms any context prefix queries over $[[A]]$ in the argument/return types
into a queries over $[[A']]$. These new queries may be simplified using the
equivalences described in \cref{sec:types}.  Intuitively, this substitution
and simplification represents incrementally refining the behavior of
the callee function with partial context information. Although the exact
concrete execution context of the callee (and therefore exact behavior)
is unknown, we at least know the exact context begins with $[[l]]$ and
can potentially use this knowledge to rule out certain behaviors.
Notice that if $[[B]]$ is concrete, then any prefix
queries can be immediately simplified to $[[Top]]$ or $[[Bot]]$. In
either case however, the formal arguments are required to match the parameter
types (post substitution), and then the body of the let binding is
checked with the argument types updated to reflect the changes in the
function call (again, post substitution).

Rule \rn{T-FunDef} type checks a function definition
$[[ f |-> (x1,..,xn) e]]$ against the function type given in $[[Th]]$.
As a convenience we assume that the parameter
names in the function type match the formal parameters in the function
definition. The rule checks that under an initial environment given
by the argument types, the function body produces a value of the
return type and transforms the arguments according to the output types.
Further, as mentioned above,
functions may be executed under many different contexts,
so function body type checking is performed under the type context
variable $[[A]]$ that occurs in the function type.

Finally, the rule for typing programs (\rn{T-Prog}) checks that
all function definitions are well-typed under a well-formed
function type environment, and that the entry point $[[e]]$
is well-typed in an empty environment. The program
entry point is always executed under the empty context $[[.]]$,
which is reflected in the typing context of $[[e]]$.

\begin{example}[Simple 1-CFA]
  \label{exmp:1cfa}
  Consider the following simple program:
  \begin{lstlisting}
    get(z) { *z }
    
    let y = mkref 1 in
    let x = mkref -1 in
    assert(get$^{[[l1]]}$(y) > 0);
    assert(get$^{[[l2]]}$(x) < 0)
  \end{lstlisting}
  Taking $[[T]]$ to be the type:
  \[
    [[{nu:int|(A = l1? ==> nu > 0) /\ (A = l2? ==> nu < 0)}]]
  \]
  we can give \lstinline{set} the function type $[[ A <z: T ref 1> -> <z: T ref 1 | T>]]$

  Assuming \lstinline{x} is given the type $[[ {nu:int|nu < 0} ref 1]]$
  then after substitution the function call
  with label $[[l2]]$ requires an argument of type \[
    [[ {nu:int|l1 = l2? ==> nu > 0 /\ l2 = l2? ==> nu < 0} ref 1 ~ {nu:int|nu < 0} ref 1]]
  \]
  which is exactly the type of \imp{x}. Further, after substitution the
  function's type indicates it returns a strictly negative integer, which is
  sufficient to prove the assertion correct.
\end{example}
\begin{example}[Simple 2-CFA]
  To see how to compose context information across multiple calls, consider
  the following change to code in \cref{exmp:1cfa}:
  \begin{lstlisting}
    get_real(z) { *z }

    get(z) { get_real$^{[[l3]]}$(z) }
  \end{lstlisting}
  The type of \imp{get} remains as in \cref{exmp:1cfa}, and taking $[[T]]$
  to be \[
    [[ {nu:int| (A' = l3 l2 ? ==> nu < 0) /\ (A' = l3 l1 ? ==> nu > 0) } ]]
  \]
  the type of \imp{get_real} is:
  \[
    [[ A' <z: T ref 1> -> <z: T ref 1 | T>]]
  \]
  We focus on the typing of the call to \imp{get_real} in \imp{get}.
  The call is typed in context $[[A]]$ and a type environment where
  \imp{p} is given type:
  \[
    [[ {nu:int|(A = l2? ==> nu < 0) /\ (A = l1? ==> nu > 0)} ref 1]]
  \]
  Applying the substitution $[[ [l3 : A / A'] ]]$ to the argument
  type of \imp{get_real} yields the expected type:
  \begin{align*}
    & [[ {nu:int|(l3 A = l3 l2 ? ==> nu < 0) /\ (l3 A = l3 l1 ? ==> nu > 0)} ref 1 ]][[~]] \\
    & \,\,\,\,\, [[ {nu:int|(A=l2? ==> nu < 0) /\ (A=l1? ==> nu > 0)} ref 1]]
  \end{align*}
  which is exactly the type of \imp{p}. A similar derivation applies to
  give the return type of \imp{get_real} and thus \imp{get}.
\end{example}

\begin{remark}
  The context sensitivity scheme described in this section corresponds
  to the standard CFA approach without \emph{a priori} call-string limiting.
  However, this scheme cannot distinguish between calls
  that occur within a recursive cycle. In principle we could the language
  of refinements to include more complex context query operations, such
  as checking whether a context matches a given context free language.
  However, it seems unlikely such an extension would be amenable to
  automated type inference, a major goal of this work. Further,
  we are able to verify several interesting examples even with this
  relatively simple approach. We leave the rigorous exploration
  of other context sensitivity schemes to future work.
\end{remark}

\subsection{Soundness}
\label{sec:soundness}
We have proven that any closed program that type checks according to
the rules above will never experience an assertion failure.
We formalize this claim with the following soundness theorem.

\begin{theorem}[Soundness]
  \label{thm:soundness}
  For any program $[[ <D, e> ]]$ such that $[[ |- <D, e> ]]$ then
  $[[ <empty, empty, ., e> !-->*D AssertFail ]]$.
\end{theorem}
\begin{proof}[Proof Sketch]
  We omit a full proof for space details, the full proof can be found
  in the accompanying appendix.

  We define a typing relation for runtime configurations; well-typed
  configurations satisfy the following invariants
  \begin{enumerate}
  \item The value of heap locations and program variables satisfy the refinements given in the program typing judgment, and
  \item The ownership given to every memory cell never exceeds 1.
  \end{enumerate}
  We then show that well-typedness is preserved by our step relation.
  By defining the $[[AssertFail]]$ configuration as ill-typed, a
  simple inductive argument then gives the desired result.
\end{proof}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
