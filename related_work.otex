\section{Related Work}
\label{sec:rw}

The difficulty in handling programs with mutable references and
aliasing has been well-studied. Like JayHorn many approaches model the heap explicitly
at analysis time, approximating concrete heap locations with allocation site
labels \cite{kahsai2017quantified,kahsai2016jayhorn,chugh2012dependent,rondon2010low,fink2008effective};
each \emph{abstract location} is associated with a refinement.
As abstract locations summarize many concrete locations, this approach
does not admit strong updates and flow-sensitivity; in particular, the refinement
associated with an abstract location is fixed for the lifetime of the program.
The techniques cited above include various workarounds for this limitation. For
example, \cite{rondon2010low,chugh2012dependent} temporarily allow
breaking these invariants through a distinguished program name
as long as the abstract location is not accessed through another name.
The programmer must therefore eventually bring the invariant back in sync with the summary location.
As a result, these systems ultimately cannot precisely handle programs that require
evolving invariants on mutable memory locations.

As similar approach was taken in
CQual \cite{foster2002flow} by Aiken et al. \cite{aiken2003checking}.
They used an explicit \emph{restrict} binding for pointers.
Strong updates are permitted through pointers bound
with \emph{restrict}, but the program is forbidden from
using any may-aliased pointers while the restrict binding is live.

A related technique used in the field of object-oriented verification is
to declare object invariants at the class level and allow these
invariants on object fields to be broken during a limited period of time
\cite{barnett2011specification,flanagan2002extended} \JT{find and cite}. In particular, the work on
Spec\# \cite{barnett2011specification} uses an ownership system which tracks
whether object $a$ owns object $b$; like \name's ownership system these ownerships
are used to track when states may be inconsistent. However, Spec\#'s ownership
is quite strict, and does admit references to $b$ outside of the owning object $a$.
% These techniques implicitly use \emph{type-based} abstract heap; like the
% techniques above, any temporarily broken invariants on an abstract location
% (i.e., class invariant) must be eventually brought back in sync with the
% fixed invariant.

F*, a dependently typed dialect of ML, includes an update/select
theory of heaps and require explicit annotations summarizing the heap
effects on a method
\cite{protzenko2017verified,swamy2016dependent,swamy2013verifying}.
This approach enables modular reasoning and precise specification of
method pre- and post-conditions with respect to the heap, but requires
manual annotation from the programmer.

The work on rely--guarantee reference types by Gordon et
al. \cite{gordon2013rely,gordon2017verifying} uses refinement
types in a language mutable references and aliasing.
Their approach extends reference types with rely/guarantee predicates;
the rely predicate describes possible mutations via aliases,
and the guarantee predicate describes the admissible mutations through the current reference reference.
If two references may alias, then guarantee predicate of one of
the references implies the rely of the other and vice versa. 
This invariant is maintained with a splitting operation that
is similar to our $+$ operator.
Further, their type system allows strong updates to reference refinements
provided the new refinements are preserved by the rely predicate.
Thus, rely-guarantee refinement support multiple
mutable, aliased references with non-trivial refinement information. Unfortunately this
expressiveness comes at the cost of automated inference and verification; an embedding
of this system into Liquid Haskell \cite{vazou2014refinement} described in
\cite{gordon2017verifying} was forced to sacrifice strong updates.

Work by Degen et al. \cite{degen2007tracking} introduced linear state annotations to Java.
To effect strong updates in the presence of aliasing, like \name,
their system requires state annotated memory locations are mutated only through
a distinguished reference. Further, all aliases of this mutable reference give
no information about the state of the object much like our $0$ ownership pointers.
However, their system cannot handle multiple, immutable aliases with non-trivial
annotation information; \emph{only} the mutable reference may
have non-trivial annotation information.

The idea of using a rational number to express permissions to access a
reference dates back to the type system of \emph{fractional
permissions} by Boyland~\cite{DBLP:conf/sas/Boyland03}.  His work used
fractional permissions to verify race freedom of a concurrent program
without a may-alias analysis.  Later,
Terauchi~\cite{terauchi2008checking} proposed a type-inference
algorithm that reduces typing constraints to a set of linear
inequalities over rational numbers.  Boyland's idea also inspired a
variant of separation logic for a concurrent programming
language~\cite{DBLP:conf/popl/BornatCOP05} to express sharing of read
permissions among several threads.  Our previous
work~\cite{suenaga2009fractional,suenaga2012type}, inspired by
Boyland's work and Terauchi's work, proposed methods for type-based
verification of resource-leak freedom, in which a rational number
expresses an \emph{obligation} to deallocate certain resource, not
just a permission.

The fractional ownerships in \name and their counterparts in
\cite{suenaga2009fractional,suenaga2012type} have a clear relation to
linear type systems. Many authors have explored the use of linear type
systems to reason in contexts with aliased mutable references
\cite{fahndrich2002adoption,deline2001enforcing,smith2000alias}, and
in particular with the goal of supporting strong updates
\cite{ahmed20073}. A closely related approach is RustHorn by
Matsushita and Kobayashi \cite{matsushita2019rusthorn}. Much like
\name, RustHorn uses CHC and linear aliasing information for
the sound and (unlike \name) complete verification of
programs with aliasing and mutability. However, their approach depends Rust's
strict \emph{borrowing discipline}. In particular, it cannot handle programs
where multiple aliased references are used to
mutate memory in the same lexical region. In contrast, \name supports
fine-grained, per-statement changes in mutability and even further
control with \imp{alias} annotations, which allows it to verify larger
classes of programs.


The issue of context-sensitivity (sometimes called \emph{polyvariance})
is well-studied in the field of abstract interpretation
(e.g., \cite{kashyap2014jsai,hardekopf2014widening,shivers1991control,smaragdakis2011pick,milanova2005parameterized}, see \cite{gilray2013survey}
for a recent survey).
Polyvariance has also been used in type systems to assign
different behaviors to the same function depending on its call site
\cite{banerjee1997modular,wells2002calculus,amtoft2000faithful}.
In the area of refinement type systems, Zhu and Jagannathan developed
a context sensitive dependent type system for a functional language \cite{zhu2013compositional}
that indexed function types by unique labels attached to call-sites. Our
context-sensitivity approach was inspired by this work; the type of \imp{get} in
\Cref{exmp:1cfa} is effectively two function types indexed by call-site labels.
In fact, we could have formalized context-polymorphism within the framework of full dependent
types, but chose the current presentation for simplicity.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:

%  LocalWords:  ownerships CQual Haskell Degen polyvariance Zhu
%  LocalWords:  Jagannathan
