\section{Related Work}
\label{sec:rw}

The difficulty in handling programs with mutable references and
aliasing has been well-studied. A common approach is to model the heap explicitly
at analysis time, approximating concrete heap locations with allocation site
labels \cite{kahsai2017quantified,kahsai2016jayhorn,chugh2012dependent,rondon2010low,fink2008effective};
these \emph{abstract locations} are associated with a refinement.
However, as these abstract locations summarize many concrete locations, this approach
comes at the cost of strong updates and flow-sensitivity; in particular, the refinement
associated with an abstract location is fixed for the lifetime of the program.
The techniques cited above include various workarounds for this limitation. For
example, \cite{rondon2010low,chugh2012dependent} temporarily allow
breaking these invariants through a distinguished program name
as long as the abstract location is not accessed through another name.
The programmer must therefore eventually bring the invariant back in sync with the summary location.
As a result, these systems ultimately cannot precisely handle programs that require
evolving invariants on mutable memory locations. \JT{This comes off as pretty uncharitable}

Another related approach can be found in the work on strong updates in
CQual \cite{foster2002flow} by Aiken et al. \cite{aiken2003checking}. Their goal
was to enable strong updates to type qualifiers when pointers are represented with
abstract locations. The accomplished this with an explicit \emph{restrict}
binding for variables. Within the restrict binding for a variable $x$
with abstract location $l$, the program is forbidden from accessing $l$
except through $x$. This approach is broadly similar with the temporary 
refinement violations described above, although their approach does not appear
to model abstract heaps directly.

A related technique used in the field of object-oriented verification is
to declare object invariants at the class level and allow these
invariants on object fields to be broken during a limited period of time
\cite{barnett2011specification,flanagan2002extended} \JT{find and cite}. In particular, the work on
Spec\# \cite{barnett2011specification} uses an ownership system which tracks
whether object $a$ owns object $b$; like \name's ownership system these ownerships
are used to track when states may be inconsistent. However, Spec\#'s ownership
is quite strict, and does admit references to $b$ outside of the owning object $a$.
Further, these techniques implicitly use \emph{type-based} abstract heap; the boundaries during
which an object invariant can be broken are similar to the regions described
above during which strong updates to inconsistent refinement are permitted. Thus, these techniques also cannot
provide per-object invariants nor support evolving invariants.

F*, a dependently typed dialect of ML, includes an update/select
theory of heaps and require explicit annotations summarizing the heap
effects on a method
\cite{protzenko2017verified,swamy2016dependent,swamy2013verifying}.
This approach enables modular reasoning and precise specification of
method pre- and post-conditions with respect to the heap, but comes at
the cost of fully automated inference.

The work on rely-guarantee reference types by Gordon et
al. \cite{gordon2013rely,gordon2017verifying} uses refinement
types in a language mutable references and aliasing without relying on
an abstract heap. Their approach extends reference types with rely/guarantee predicates;
the rely predicate describes the ways the value of the reference may be mutated via aliases,
and the guarantee predicate describes the admissible mutations through the reference.
If two references may alias, then guarantee predicate of one of
the references implies the rely of the other and vice versa. 
This invariant is maintained by way of a linear ``splitting'' operation that
bears many similarities to the behavior of our $+$ operator.
Further, their type system allows strong updates to reference content refinements
provided that mutations admitted by the rely predicate do not
invalidate the new refinement. Thus, rely-guarantee refinements can support multiple
mutable, aliased references with non-trivial refinement information. Unfortunately this
expressiveness comes at the cost of automated inference and verification; an embedding
of this system into Liquid Haskell \cite{vazou2014refinement} described in
\cite{gordon2017verifying} was forced to sacrifice strong updates.

Work by Degen et al. \cite{degen2007tracking} introduced linear state annotations to to Java.
To effect strong updates in the presence of aliasing, like \name,
their system requires state annotated memory locations are mutated only through
a distinguished reference. Further, all aliases of this mutable reference give
no information about the state of the object, much like our $0$ ownership pointers.
However, their system cannot handle multiple, immutable aliases with non-trivial
annotation information; \emph{only} the distinguished, mutable reference may
have non-trivial annotation information.

The fractional ownerships in \name and their counterparts in
\cite{suenaga2009fractional,suenaga2012type} have a clear relation to
linear type systems. Many authors have explored the use of linear type
systems to reason in contexts with aliased mutable references
\cite{fahndrich2002adoption,deline2001enforcing,smith2000alias}, and
in particular with the goal of supporting strong updates
\cite{ahmed20073}.

The issue of context-sensitivity (sometimes called \emph{polyvariance})
is well-studied in the field of abstract interpretation
(e.g., \cite{kashyap2014jsai,hardekopf2014widening,shivers1991control,smaragdakis2011pick,milanova2005parameterized}, see \cite{gilray2013survey}
for a recent survey).
Polyvariance has also been used in type systems to assign
different behaviors to the same function depending on its call site
\cite{banerjee1997modular,wells2002calculus,amtoft2000faithful}.
In the area of refinement type systems, work by Zhu and Jagannathan in
\cite{zhu2013compositional} combined a dependent type system for a functional
language with context sensitivity.
In their formalism, function types are indexed by a set of labels that are
also attached to call-sites; the type used for checking a function call
is thus determined by the label of the call site. Our
context-sensitivity approach was inspired by this work; the type of \imp{get} in
\Cref{exmp:1cfa} is effectively two function types indexed by call-site labels.
In fact, our context-polymorphism could be \JT{is???} formalized within dependent type
theory by threading a call-string through the program with dependent argument
types. However, we chose the current presentation based on
context query predicates to simplify the formal presentation and 
the encoding to SMT formulae.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:

%  LocalWords:  ownerships
