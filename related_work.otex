\section{Related Work}
\label{sec:rw}

\paragraph{Verification of Mutable Memory}
The difficulty in handling programs with mutable references and
aliasing has been well-studied. As mentioned in \cref{sec:intro}, a
commond approach is to model the heap explicitly at analysis time, approximating
concrete heap locations with allocation site labels \cite{kahsai2017quantified,kahsai2016jayhorn,chugh2012dependent,rondon2010low}
\JT{There must be many more of these papers, find them, and cite them}.
To support programs with unbounded allocations while keeping verification tractable,
these techniques use \emph{summary} locations to abstract multiple concrete
locations. However, this abstraction comes at the cost of strong updates and flow-sensitivity.
The techniques cited above include various work arounds for this limitation. For
example, in addition to inlining, JayHorn \cite{kahsai2016jayhorn,kahsai2017quantified} ``pulls'' information
from mutable, aliased memory into local variables which can be strongly updated.
This information is cached in local variables as long as possible, until memory interaction
(e.g., a read through a may-aliased heap location) forces a ``push'' back into the heap
location. At each push back into the heap, the information cached in local variables must satisfy
the (unchanging) object invariant for the summary location. The work of
of \cite{rondon2010low,chugh2012dependent} take a similar approach, temporarily
allowing violations of the unchaing invariant on a summary location
provided the type system can prove no references to that location are used. However, despite
these work arounds, these systems ultimately cannot precisely handle programs that require
evolving invariants on mutable memory locations. \JT{This comes off as pretty uncharitable}

A related technique used in the field of object-oriented verification is
to declare object invariants at the class level and allow these
invariants on object fields to be broken during a limited period of time
\cite{barnett2011specification,flanagan2002extended} \JT{find and cite}. In particular, the work on
Spec\# \cite{barnett2011specification} uses an ownership system which tracks
whether object $a$ owns object $b$; like \name's ownership system these ownerships
are used to track when states may be inconsistent. However, Spec\#'s ownership
is quite strict, and does admit references to $b$ outside of owning object $a$.
Further, these techniques implicitly use \emph{type-based} abstract heap; the boundaries during
which an object invariant can be broken are similar to the regions described
above during which strong updates are permitted. Thus, these techniques also cannot
provide per-object invariants nor support evolving invariants.

The work on rely-guarantee reference types by Gordon et
al. \cite{gordon2013rely,gordon2017verifying} uses refinement
types in a language mutable references and aliasing without relying on
an abstract heap. Their approach extends reference types with rely/guarantee predicates;
the rely predicate describes the ways the value of the reference may be mutated via aliases,
and the guarantee predicate describes the admissable mutations through the reference. A key invariant
of their type system is that if two references may alias, the guarantee predicate of one of
the references implies the rely of the other and vice versa. 
This invariant is maintained by way of a linear ``splitting'' operation that
bears many similarities to the behavior of our $+$ operator.
In particular, their split operation could express that a mutable reference two immutable references.
Further, their type system allows strong updates to reference context refinements
provided that mutations admitted by the rely guarantee do not
invalidate the new refinement. Thus, rely-guarantee refinements can support multiple
mutable, aliased references with non-trivial refinement information. Unfortunately this
expressivity comes at the cost of automated inference and verification; an embedding
of this system into Liquid Haskell \cite{vazou2014refinement} described in
\cite{gordon2017verifying} was forced to sacrifice strong updates.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
