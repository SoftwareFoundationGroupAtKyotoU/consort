metavar termvar, x, y, z ::=
  {{ tex \mathit{[[termvar]]} }} {{ com  term variable  }}

metavar funvar, f, g ::=
  {{ tex \mathit{[[funvar]]} }} {{ com  function name }}

metavar l::=
  {{ tex \ell }}  {{ com  label }}

metavar ll ::=
  {{ tex \overrightarrow{\ell} }}

indexvar index, i, n, p ::=   {{ com index }}

metavar a ::= {{ com addresses }}

metavar pfun ::= {{ com predicate symbol }} {{ tex \phi }}

grammar

  e :: 'e_' ::=                                         {{ com exp }}
    | x                   ::   :: Var                     {{ com variable }}
    | let x = y in e      ::   :: Let {{ tex \LET [[x]] = [[y]] \IN [[e]] }}
    | let x = v in e      ::   :: LetV {{ tex \LET [[x]] = [[v]] \IN [[e]] }}
    | ifz x then e1 else e2 ::   :: Ifz {{ tex \IFZERO [[x]] \THEN [[e1]] \ELSE [[e2]] }}
    | let x = mkref y in e :: :: MkRef {{ tex \LET [[x]] = \MKREF [[y]] \IN [[e]] }}
    | let x = * y in e    ::   :: Deref {{ tex \LET [[x]] = * [[y]] \IN [[e]] }}
    | let x = f l ( y1 ,, yn ) in e :: :: Call {{ tex \LET [[x]] = [[f]]^[[l]]([[y1]],\ldots,[[yn]]) \IN [[e]] }}
    | x := y ; e          ::   :: Assign {{ tex [[x]] \WRITE [[y]] \SEQ [[e]] }}
    | alias ( x = y ) ; e ::   :: Alias  {{ tex \ALIAS([[x]] = [[y]]) \SEQ [[e]] }}
    | assert ( ph ) ; e  ::   :: Assert {{ tex \ASSERT([[ph]]) \SEQ [[e]] }}
    | e ; e'              ::   :: Seq    {{ tex [[e]] \SEQ [[e']] }}
    | vsub e :: :: subst_mult {{ tex [[vsub]] [[e]] }}
    | ( e )               :: S :: paren
	  | CE [ x ]  :: M:: ret
	  | E [ e ] :: M:: ctxt
	  | e1 = e2 :: :: eq

  A {{ tex \alpha }} :: 'A_' ::=

  v :: 'v_' ::=                                         {{ com  value }}
    | nn                   ::   :: Nat     {{ com  natural number }}    {{ tex n }}

  d :: d_ ::=
    | f |-> ( x1 , .. , xi ) e  ::  :: def

  D :: D_ ::=
    | { d1 , ... , di }     ::   :: set

  P :: P_ ::=                              {{ com programs }}
    | < D , e >            ::   :: prog    {{ tex \tuple{[[D]], [[e]]} }}

  r {{ tex r }} :: 'O_' ::=
    | q :: :: const_owner {{ tex [0,1] \in \mathbb{Q} }}
	| r1 + r2 :: :: add_owner
	| 0 :: :: dead_owner
	| 1 :: :: excl_owner

  C {{ tex \mathbf{C} }} :: C_ ::=    {{ com configuration }}
    | < H , R , Es , e >         ::   :: Quad {{ tex \tuple{[[H]], [[R]], [[Es]], [[e]]} }}
    | AssertFail                ::   :: AFail {{ tex \textbf{AssertFail} }}
	| AliasFail :: :: AliasFail {{ tex \textbf{AliasFail} }}

  R :: R_ ::= {{ com env or register file }}
    | empty :: :: em {{ tex \emptyset }}
	| R { x |-> Rv } :: :: fresh
  H :: H_ ::= {{ com heap }}
    | empty :: :: em {{ tex \emptyset }}
	| H { a |-> Rv } :: :: update
	| H { a <- Rv } :: :: destrUpdate

  Rv :: Rv_ ::= {{ com runtime value forms }}
    | a :: :: addr
	| R ( x ) :: :: var
	| H ( Rv ) :: :: lkp
	| v :: :: const
	| 0 :: :: z

  E :: E_ ::=    {{ com evaluation context }}
    | []                ::   :: hole
	| E ; e :: :: seq {{ tex [[E]]\SEQ[[e]] }}
	| ( E ) :: :: paren
	| E = E' :: :: eq

  CE {{ tex E_c }} :: E_ ::=
    | E [ let x = [] l in e ] :: :: stack {{ tex [[E]][\LET [[x]] = \HOLE^[[l]] \IN [[ e ]] ]}}

  Es {{ tex \overrightarrow{E} }} :: Es_ ::=                  {{ com  stack }}
    | .                  ::   :: empty {{ tex \cdot }}
    | CE : Es             ::   :: cons
    | En-1 : Es             ::    :: cons_new

  ph {{ tex \varphi }} :: 'P_' ::= {{ com refinement predicates }}
    | pfun ( x1 , .. , xn ) :: :: pred_sym {{ com predicate in underlying logic }}
	| ph1 /\ ph2 :: :: pred_conj {{ tex [[ph1]] \wedge [[ph2]] }} {{ com conjunction }}
	| lvar = V2 :: :: pred_const {{ com equality }}
	| lvar != V2 :: :: pred_ineq {{ com inequality }} {{ tex [[lvar]] \neq [[V2]] }}
	| Top :: :: pred_top {{ tex \top }}
	| ph1 ==> ph2 :: :: entail
	| [ V1 / lvar ] ph :: :: subst_var
	| vsub ph :: :: sub_v
	| [ R ; V1 / lvar ] ph :: :: subst_env
	| csub ph :: :: subst_ctxt
	| B1 = B2 ? :: :: prefix_query {{ tex [[B1]] = [[B2]]? }}
	| ( ph ) :: :: paren
	| x = T y :: :: typed_eq {{ tex [[x]] =_{[[T]]} [[y]] }}

  lvar {{ tex V }} :: 'LV_' ::=
  	| nu :: :: nu {{ tex \nu }}
    | x :: :: var

  V :: 'V_' ::=
    | x :: :: var
	| v :: :: val
	| Rv :: :: rv

  csub {{ tex \sigma_{\alpha} }} :: 'C_' ::=
  	| [ B / A ] :: M :: subst_ctxt
	| csub1 csub2 :: M :: subst_concat

  vsub {{ tex \sigma_{x} }} :: 'VS_' ::=
    | [ x1 / x1' ] ,, [ xn / xn' ] :: :: vsub_seq {{ tex [ [[x1]] / [[x1']] ] \cdots [ [[xn]] / [[xn']] ] }}
	| [ x1 / x2 ] :: :: sub {{ tex [ [[x1]] / [[x2]] ] }}

  T {{ tex \tau }} :: T_ ::=                              {{ com type }}
    | { x : int | ph }    ::   :: refint                  {{ com refined integer type }}
                                        {{ tex \set{ [[x]] \COL \TINT \mid [[ph]]} }}
    | T ref r             ::   :: reference               {{ com reference type }}
                                        {{ tex [[T]] \TREF^{[[r]]} }}
    | ( T )               :: S :: paren
    | T1 + T2             :: M :: sum
    | G ( x )             :: M :: lookup
	| csub T :: :: subst_context
	| vsub T :: M :: subst_var
	| T1 /\ x ph :: :: strength {{ tex [[T1]] \wedge_{[[x]]} [[ph]] }}
	| T1 = T2 :: :: eq

  ST {{ tex \tau_{ST} }} :: 'ST_' ::=
    | int :: :: simple_int {{ tex \TINT }}
	| ST ref :: :: simple_ref {{ tex [[ST]] \TREF }}
	| Gst ( x ) :: :: st_lkp

  Gst {{ tex \Gamma_{ST} }} :: 'STG_' ::=
    | empty :: :: em {{ tex \bullet }}
	| Gst , x : ST :: :: append
	| ST ( G ) :: :: lift_G {{ tex \mathit{ST}([[G]]) }}

  B {{ tex \beta }} :: B_ ::=
    | . :: :: empty {{ tex \epsilon }}
	| l : B :: :: l_cons
	| l1 : ,..., : ln : B :: :: multi_cons {{ tex [[l1]] : \cdots : [[ln]] : [[B]] }}
	| A :: :: svar
	| ll :: :: list_var
	| Trace ( Es ) :: :: trace_fun
	| csub B :: :: string_sub

  FT {{ tex \sigma }} :: FT_ ::=                          {{ com function type }}
    | A < x1 : T1 ,, xn : Tn > -> < y1 : T1' ,, yi : Ti' | T >  :: :: sig
          {{ tex \forall [[A]].\tuple{[[x1]]\COL[[T1]],\dots,[[xn]]\COL[[Tn]]}\ra\tuple{[[y1]]\COL\[[T1']],\dots,[[yi]]\COL[[Ti']] \mid [[T]]} }}
     | Th ( f ) :: :: fenvLkp

  Th {{ tex \Theta }} :: Th_ ::=
    | empty :: :: em {{ tex \bullet }}
	| f |-> FT , Th :: :: vn

  G {{ tex \Gamma }} :: G_ ::=  {{ com type environment }}
    | empty               ::   :: em   {{ tex \bullet }}
    | G , x : T           ::   :: vn
	| G \ x :: :: sub {{ tex [[G]] \setminus [[x]] }}
	| G , x1 : T1 ,, xn : Tn :: :: append {{ tex [[G]],[[x1]]\COL[[T1]],\ldots,[[xn]]\COL[[Tn]] }}
	| x1 : T1 ,, xn : Tn :: :: mk {{ tex [[x1]]\COL[[T1]],\ldots,[[xn]]\COL[[Tn]] }}
	| G [ x : T ] :: :: type_in
	| G [ x1 <- T1 ] :: :: type_update
	| G [ x1 <- T1 ] ,, [ x2 <- T2 ] :: :: ty_update_2 {{ tex [[G]] \left[ [[x1]][[<-]][[T1]] \right]\cdots[ [[x2]][[<-]][[T2]]] }}
	| [ B / A ] G :: :: cxtSubst
	| ( G ) :: :: paren
	| G1 = G2 :: :: tyenvDef

  terminals :: 'terminals_' ::=
    | ;                   ::   :: seq        {{ tex \SEQ }}
    | -->                 ::   :: red        {{ tex \longrightarrow }}
    |  ->                 ::   :: arrow      {{ tex \rightarrow }}
    | |-                  ::   :: turnstile  {{ tex \vdash }}
    | |-e                  ::   :: e_turnstile  {{ tex \vdash_{E} }}
    | |=                  ::   :: models     {{ tex \models }}
    | in                  ::   :: in         {{ tex \in }}
    | <:                  ::   :: sub        {{ tex \leq }}
    | ==>                 ::   :: impl       {{ tex \implies }}
	| <=>                 ::   :: bimpl      {{ tex \Leftrightarrow }}
    | =>                  ::   :: darrow     {{ tex \Rightarrow }}
    | |->                 ::   :: mapsto     {{ tex \mapsto }}
    | []                  ::   :: hole       {{ tex \HOLE }}
	| '|'                 ::   :: bar {{ tex \mid }}
	| <- :: :: destrUp {{ tex \hookleftarrow }}
	| !|= :: :: notModel {{ tex \not\models }}
	| forall :: :: forall {{ tex \forall }}
	| /\ :: :: and {{ tex \wedge }}

  logical_frag :: '' ::=
    | ph :: :: phi
    | [ T ] x :: :: denote_type {{ tex \sem{[[T]]}_{[[x]]} }}
	| [ G ] :: :: sem_tyenv  {{ tex \sem{[[G]]} }}
	| logical_frag1 /\ logical_frag2 :: :: conj
	| logical_frag1 ==> logical_frag2 :: :: logical_entailment
	| logical_frag1 <=> logical_frag2 :: :: logical_equiv

  logic_judgment :: '' ::=
	| |= logical_frag :: :: models
	| G |= logical_frag :: :: tyenv_model
	| R |= logical_frag :: :: env_model
	| R !|= logical_frag :: :: env_not_model

  FVF :: 'FV_' ::=
  	| FPV ( T ) :: :: fpv_t
	| FPV ( ph ) :: :: fpv_p
	| FPCV ( ph ) :: :: fpcv_p
	| FPCV ( T ) :: :: fpcv_tx
    | FV ( e ) :: :: fv

  functions :: 'F_' ::=
	| CV ( B ) :: :: cv
	| Cons ( H , R , G ) :: :: Cons
	| SAT ( H , R , G ) :: :: SAT
	| own ( H , Rv , T ) :: :: own
	| F ( a ) :: :: total_own_app

   omap :: 'OM_' ::=
    | { a |-> r } :: :: omap

  judgment :: 'j_' ::=
    | G |- T1 <: T2       ::   :: sub
	| B |- T => G :: :: wftenv {{ tex [[B]] [[|-]]_{WF} [[T]] [[=>]] [[G]] }}
    | G1 <: G2            ::   :: subG
    | Th | G1 | B |- e : T => G2   ::   :: exp
    | C1 --> D C2         ::   :: red        {{ tex [[C1]] [[-->]]_[[D]] [[C2]] }}
	| B |- G :: :: tyenvwf {{ tex [[B]] [[|-]]_{WF} [[ G ]] }}
	| G | B |- T :: :: twf {{ tex [[G]] [[|]] [[B]] [[|-]]_{WF} [[T]] }}
	| Gst | B |- ph :: :: phwf {{ tex [[Gst]] [[|]] [[B]] [[|-]]_{WF} [[ph]] }}
	| T1 = T2 :: :: teq
	| ST1 = ST2 :: :: steq
	| Th |- d :: :: fun_typ
	| |- P :: :: prog_typ
	| Th |- D :: :: f_typing
	| |- D C :: :: ctxt_type {{ tex \vdash_C^D [[ C ]] }}
	| Th | [] : T => G | B |-e E : T' => G' :: :: ctxt_typing
	| Th | [] : T => G | B |-e CE : T' => G' :: :: ectxt_typing
	| |- Th :: :: funenvWf
	| |- FT :: :: ftWf

  bind :: 'Bin_' ::=
    | x :: :: pvar
	| A :: :: cvar
	| a  :: :: addr
	| f :: :: fname

  MF :: 'MF_' ::=
    | G :: :: tyenv
	| R :: :: env
	| Gst :: :: stTenv
	| H :: :: heap
	| Th :: :: funenv

  VS :: 'VS_' ::=
    | VS1 U VS2 :: :: union {{ tex [[VS1]] \cup [[VS2]] }}
	| { bind } :: :: singleton {{ tex \set{[[bind]]} }}
	| { bind1 ,, bindn } :: :: count {{ tex \set{[[bind1]],\ldots,[[bindn]]} }}
	| FVF :: :: free_var_fun
	| dom MF :: :: dom_mf {{ tex dom([[MF]]) }}

  formula :: formula_ ::=
    | judgment :: :: judge
	| functions :: :: func
	| logic_judgment :: :: lj
    | r1 >= r2 :: :: own_ge {{ tex [[r1]] \ge [[r2]] }}
    | r1 > r2 :: :: own_gt {{ tex [[r1]] > [[r2]] }}
	| r1 = r2 :: :: own_eq
  | C1 != C2 :: :: conf_ineq
	| formula1 ==> formula2 :: :: meta_entail
	| formula ( x in dom ( G ) ) :: :: quantified {{ tex [[formula]]\,\,(x \in dom([[G]])) }}
	| Th ( f ) = FT :: :: fun_typ_lkp
	| bind fresh in MF :: :: notinEnv {{ tex [[bind]] \not\in dom([[MF]]) }}
	| bind in MF :: :: inMap {{ tex [[bind]] \in dom([[MF]]) }}
	| bind not in MF :: :: notInMap {{ tex [[bind]] \not\in dom([[MF]]) }}
	| bind in VS :: :: inFv {{ tex [[bind]] \in [[VS]] }}
	| bind not in VS :: :: notInFv {{ tex [[bind]] \not\in [[VS]] }}
	| VS1 sub VS2 :: :: subset {{ tex [[VS1]] \subseteq [[VS2]] }}
	| Rv1 = Rv2 :: :: rvEq
	| Rv1 != Rv2 :: :: rvNotEq {{ tex [[Rv1]] \neq [[Rv2]] }}
	| d in D :: :: funDef {{ tex [[d]] \in [[D]] }}
	| formula1 ... formulan :: :: dots
	| csub1 = csub2 :: :: sigdef
	| B1 = B2 :: :: equiv_ctxt
	| formula1 /\ formula2 :: :: meta_conj
	| forall formula1 . formula2 :: :: uq
	| ( formula ) :: :: parenF
	| e1 = e2 :: :: termDef
	| Gst1 = Gst2 :: :: stEnvEq
	| csub1 = csub2 :: :: csubEq
	| vsub1 = vsub2 :: :: vsubEq
	| T1 ~ T2 :: :: tEqual {{ tex [[T1]] \approx [[T2]] }}
