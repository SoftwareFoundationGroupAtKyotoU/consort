metavar termvar, x, y, z ::=
  {{ tex \mathit{[[termvar]]} }} {{ com  term variable  }}

metavar funvar, f, g ::=
  {{ tex \mathit{[[funvar]]} }} {{ com  function name }}

indexvar index, i, n, p, q ::=   {{ com index }}

metavar a ::= {{ com addresses }}

metavar pfun ::= {{ com predicate symbol }} {{ tex \phi }}

grammar

  e :: 'e_' ::=                                         {{ com exp }}
    | x                   ::   :: Var                     {{ com variable }}
    | let x = rhs in e      ::   :: Let {{ tex \LET [[x]] = [[rhs]] \IN [[e]] }}
    | ifz x then e1 else e2 ::   :: Ifz {{ tex \IFZERO [[x]] \THEN [[e1]] \ELSE [[e2]] }}
    | x := y ; e          ::   :: Assign {{ tex [[x]] \WRITE [[y]] \SEQ [[e]] }}
    | alias ( x = y ) ; e ::   :: Alias  {{ tex \ALIAS([[x]] = [[y]]) \SEQ [[e]] }}
    | assert ( ph ) ; e  ::   :: Assert {{ tex \ASSERT([[ph]]) \SEQ [[e]] }}
    | e ; e'              ::   :: Seq    {{ tex [[e]] \SEQ [[e']] }}
    | vsub e :: :: subst_mult {{ tex [[vsub]] [[e]] }}
    | ( e )               :: S :: paren
    | CE [ x ]  :: M:: ret
    | E [ e ] :: M:: ctxt
    | e1 = e2 :: :: eq
	| etc :: :: etc {{ tex \ldots }}

  return_hole :: 'RH_' ::=
    | [] l :: :: LabeledHole {{ tex \HOLE^[[l]] }}

  rhs :: 'rhs_' ::= 
    | mkref y :: :: MkRef {{ tex \MKREF [[y]] }}
	| * y :: :: Deref {{ tex * [[y]] }}
	| x :: :: Var {{ com variable }}
	| v :: :: Val {{ com value }}
	| return_hole :: :: Return
	| f l ( arg_list ) :: :: Call {{ com function call }} {{ tex [[f]]^[[l]]([[arg_list]]) }}

  arg_list :: 'alist_' ::=
    | y1 ,, yn :: :: Abbrv {{ tex [[y1]],\ldots,[[yn]] }}
	| y1 , ... , yn :: :: Explicit
  
  A {{ tex \alpha }} :: 'A_' ::=

  v :: 'v_' ::=                                         {{ com  value }}
    | nn                   ::   :: Nat     {{ com  natural number }}    {{ tex n }}
	| 0 :: :: Zero {{ com zero }}
	| 1 :: :: One {{ com one }}
	| a :: :: address

  fun_body :: FB_ ::=
    | ( x1 , ... , xi ) e :: :: f_body

  d :: d_ ::=
    | f |-> fun_body  ::  :: def

  D :: D_ ::=
    | { d1 , ... , di }     ::   :: set

  P :: P_ ::=                              {{ com programs }}
    | < D , e >            ::   :: prog    {{ tex \tuple{[[D]], [[e]]} }}

  r {{ tex r }} :: 'O_' ::=
    | q :: :: const_owner {{ tex [0,1] \in \mathbb{Q} }}
	| r1 + r2 :: :: add_owner
	| 0 :: :: dead_owner
	| 1 :: :: excl_owner
	| F ( a ) :: :: omap_lkp
	| float :: :: float

  top {{ tex \top }} :: t ::=
    | Top :: :: top

  float :: 'F_' ::=
    | 0 . DL :: :: zero_point

  DL :: 'DL_' ::=
    | digit :: :: end
	| digit DL :: :: seq

  concr_int :: I_ ::=
    | DL :: :: I

   
  l {{ tex \ell}} :: 'L' ::=
    | DL :: :: conr

  digit :: 'D_' ::=
    | 0 :: :: zero
	| 1 :: :: one
	| 2 :: :: two
	| 3 :: :: three
	| 4 :: :: four
	| 5 :: :: five
	| 6 :: :: six
	| 7 :: :: seven
	| 8 :: :: eight
	| 9 :: :: nine

  C {{ tex \mathbf{C} }} :: C_ ::=    {{ com configuration }}
    | < H , R , Es , e >         ::   :: Quad {{ tex \tuple{[[H]], [[R]], [[Es]], [[e]]} }}
    | AssertFail                ::   :: AFail {{ tex \mathbf{AssertFail} }}
	| AliasFail :: :: AliasFail {{ tex \mathbf{AliasFail} }}

  R :: R_ ::= {{ com env or register file }}
    | empty :: :: em {{ tex \emptyset }}
	| R { x |-> Rv } :: :: fresh
    | R1 = R2 :: :: tyenvDef

  H :: H_ ::= {{ com heap }}
    | empty :: :: em {{ tex \emptyset }}
	| H { a |-> Rv } :: :: update
	| H { a <- Rv } :: :: destrUpdate
	| H1 = H2 :: :: inlineDef

  Rv {{ tex v }} :: Rv_ ::= {{ com runtime value forms }}
    | a :: :: addr
	| R ( x ) :: :: var
    | R ( y ) :: :: var_y
	| H ( Rv ) :: :: lkp
	| v :: :: const
	| concr_int :: :: z
	| M ( x ) :: :: model_lkp

  E :: E_ ::=    {{ com evaluation context }}
    | []                ::   :: hole
    | E ; e :: :: seq {{ tex [[E]]\SEQ[[e]] }}
    | ( E ) :: :: paren
    | E = E' :: :: eq

  CE {{ tex E_c }} :: E_ ::=
    | E [ let x = return_hole in e ] :: :: stack {{ tex [[E]][\LET [[x]] = [[return_hole]] \IN [[ e ]] ]}}

  Es {{ tex \overrightarrow{E} }} :: Es_ ::=                  {{ com  stack }}
    | .                  ::   :: empty {{ tex \cdot }}
    | CE : Es             ::   :: cons
    | En-1 : Es             ::    :: cons_new

  ineq :: 'IE_' ::=
    | = :: :: eq
	| != :: :: ineq

  plhs {{ tex \mathcal{C} }} :: 'PLhs_' ::=
    | A :: :: var
	| ll A :: :: param_pref
	| csub plhs :: :: sub
	| ll :: :: concr

  prhs :: 'PRhs_' ::=
    | ll ? :: :: prefix

  prefix_query :: 'PQ_' ::=
    | plhs ineq prhs :: :: query

  ll {{ tex \overrightarrow{\ell} }} :: 'LL_' ::=
    | . :: :: empty {{ tex \epsilon }}
	| l :: :: singleton
	| l : ll :: :: cons
	| l1 .. ln :: :: inline

  B {{ tex \mathcal{L}^{\alpha} }} :: B_ ::=
    | . :: :: empty {{ tex \epsilon }}
	| l : B :: :: l_cons
	| l1 : ,..., : ln : B :: :: multi_cons {{ tex [[l1]] : \cdots : [[ln]] : [[B]] }}
	| ll :: :: concrete
	| A :: :: svar
	| Trace ( Es ) :: :: trace_fun
	| csub B :: :: string_sub

  ph {{ tex \varphi }} :: 'P_' ::= {{ com refinement predicates }}
    | pfun ( lvar1 , .. , lvarn ) :: :: pred_sym {{ com predicate in underlying logic }}
	| ph1 /\ ph2 :: :: pred_conj {{ tex [[ph1]] \wedge [[ph2]] }} {{ com conjunction }}
	| lvar rel_op V2 :: :: pred_const {{ com equality }}
	| Top :: :: pred_top {{ tex \top }}
	| ph1 ==> ph2 :: :: entail
	| [ V1 / lvar ] ph :: :: subst_var
	| vsub ph :: :: sub_v
	| [ R ; V1 / lvar ] ph :: :: subst_env
	| csub ph :: :: subst_ctxt
	| prefix_query :: :: prefix_query
	| ( ph ) :: :: paren
	| x = T y :: :: typed_eq {{ tex [[x]] =_{[[T]]} [[y]] }}
	| Bot :: :: bot {{ tex \bot }}

  lvar {{ tex V }} :: 'LV_' ::=
  	| nu :: :: nu {{ tex \nu }}
    | x :: :: var
    | n :: :: var_n

  V :: 'V_' ::=
    | x :: :: var
	| v :: :: val
	| Rv :: :: rv

  csub {{ tex \sigma_{\alpha} }} :: 'C_' ::=
  	| [ B / A ] :: M :: subst_ctxt
	| csub1 csub2 :: M :: subst_concat

  vsub {{ tex \sigma_{x} }} :: 'VS_' ::=
    | [ x1 / x1' ] ,, [ xn / xn' ] :: :: vsub_seq {{ tex [ [[x1]] / [[x1']] ] \cdots [ [[xn]] / [[xn']] ] }}
	| [ x1 / x2 ] :: :: sub {{ tex [ [[x1]] / [[x2]] ] }}

  T {{ tex \tau }} :: T_ ::=                              {{ com type }}
    | { x : int | ph }    ::   :: refint                  {{ com refined integer type }}
                                        {{ tex \set{ [[x]] \COL \TINT \mid [[ph]]} }}
    | T ref r             ::   :: reference               {{ com reference type }}
                                        {{ tex [[T]] \TREF^{[[r]]} }}
    | ( T )               :: S :: paren
    | T1 + T2             :: M :: sum
    | G ( x )             :: M :: lookup
	| csub T :: :: subst_context
	| vsub T :: M :: subst_var
	| T1 /\ x ph :: :: strength {{ tex [[T1]] \wedge_{[[x]]} [[ph]] }}
	| T1 = T2 :: :: eq
    | Tn+1 :: ::tn1 {{ tex \tau_{n+1} }}
	| top :: :: top_type

  ST {{ tex \tau_{ST} }} :: 'ST_' ::=
    | int :: :: simple_int {{ tex \TINT }}
	| ST ref :: :: simple_ref {{ tex [[ST]] \TREF }}
	| Gst ( x ) :: :: st_lkp

  Gst {{ tex \Gamma_{ST} }} :: 'STG_' ::=
    | empty :: :: em {{ tex \bullet }}
	| Gst , x : ST :: :: append
	| ST ( G ) :: :: lift_G {{ tex \mathit{ST}([[G]]) }}

  tyarg_list :: 'AL_' ::=
    | x1 : T1 , .. , xn : Tn :: :: list

  FT {{ tex \sigma }} :: FT_ ::=                          {{ com function type }}
    | A < x1 : T1 ,, xn : Tn > -> < y1 : T1' ,, yi : Ti' | T >  :: :: sig
          {{ tex \forall [[A]].\tuple{[[x1]]\COL[[T1]],\dots,[[xn]]\COL[[Tn]]}\ra\tuple{[[y1]]\COL\[[T1']],\dots,[[yi]]\COL[[Ti']] \mid [[T]]} }}
     | A < tyarg_list1 > -> < tyarg_list2 | T > :: :: concr_sig {{ tex \forall [[A]].\tuple{[[tyarg_list1]]}\ra\tuple{[[tyarg_list2]]\mid[[T]]} }}
     | Th ( f ) :: :: fenvLkp

  Th {{ tex \Theta }} :: Th_ ::=
    | empty :: :: em {{ tex \bullet }}
	| f |-> FT , Th :: :: vn

  G {{ tex \Gamma }} :: G_ ::=  {{ com type environment }}
    | empty               ::   :: em   {{ tex \bullet }}
    | G , x : T           ::   :: vn
	| G \ x :: :: sub {{ tex [[G]] \setminus [[x]] }}
	| G , x1 : T1 ,, xn : Tn :: :: append {{ tex [[G]],[[x1]]\COL[[T1]],\ldots,[[xn]]\COL[[Tn]] }}
	| x1 : T1 ,, xn : Tn :: :: mk {{ tex [[x1]]\COL[[T1]],\ldots,[[xn]]\COL[[Tn]] }}
	| x : T :: :: singleton {{ tex [[x]]\COL[[T]] }}
	| G [ x : T ] :: :: type_in
	| G [ x1 <- T1 ] :: :: type_update
	| G [ x1 <- T1 ] ,, [ x2 <- T2 ] :: :: ty_update_2 {{ tex [[G]] \left[ [[x1]][[<-]][[T1]] \right]\cdots[ [[x2]][[<-]][[T2]]] }}
	| [ B / A ] G :: :: cxtSubst
	| ( G ) :: :: paren
	| G1 = G2 :: :: tyenvDef
    | Gn+1 :: ::gn1 {{ tex \tenv_{n+1} }}

  rel_op :: Rel ::=
    | <= :: :: ge
	| < :: :: lt
	| = :: :: eq
	| != :: :: neq
	| >= :: :: geq
    | > :: :: gt

  terminals :: 'terminals_' ::=
    | ;                   ::   :: seq        {{ tex \SEQ }}
    | -->                 ::   :: red        {{ tex \longrightarrow }}
	| -->*                ::   :: trans_red {{ tex \longrightarrow^* }}
    |  ->                 ::   :: arrow      {{ tex \rightarrow }}
    | |-                  ::   :: turnstile  {{ tex \vdash }}
    | |-e                  ::   :: e_turnstile  {{ tex \vdash_{E} }}
    | |-D                  ::   :: D_turnstile {{ tex \vdash_C^D }}
    | |=                  ::   :: models     {{ tex \models }}
    | in                  ::   :: in         {{ tex \in }}
    | <:                  ::   :: sub        {{ tex \leq }}
    | ==>                 ::   :: impl       {{ tex \implies }}
	| <=>                 ::   :: bimpl      {{ tex \Leftrightarrow }}
    | =>                  ::   :: darrow     {{ tex \Rightarrow }}
    | |->                 ::   :: mapsto     {{ tex \mapsto }}
    | []                  ::   :: hole       {{ tex \HOLE }}
	| '|'                 ::   :: bar {{ tex \mid }}
	| INT                 ::   :: int {{ tex \mathbb{Z} }}
	| ifz                 ::   :: ifz
	| SAT                 ::   :: sat_pred
	| SATv                ::   :: satv_pred
	| <- :: :: destrUp {{ tex \hookleftarrow }}
	| !|= :: :: notModel {{ tex \not\models }}
	| forall :: :: forall {{ tex \forall }}
	| /\ :: :: and {{ tex \wedge }}
	| \/ :: :: or {{ tex \vee }}
	| M :: :: model {{ tex \mathcal{M} }}
	| '|<' :: :: sum {{ tex \Sigma }}
	| <= :: :: leq {{ tex \le }}
	| >= :: :: geq {{ tex \ge }}
	| != :: :: neq {{ tex \neq }}
	| = :: :: eq
	| < :: :: lt
	| > :: :: gt
	| Top :: :: top {{ tex \top }}
	| ~ :: :: squiggle {{ tex \approx }}

  reduction :: '' ::=
    | --> :: :: step
	| -->* :: :: step_tr
	| ! reduction :: :: cant_step {{ tex \not[[reduction]] }}

  logical_frag :: '' ::=
    | ph :: :: phi
    | [ T ] x :: :: denote_type {{ tex \sem{[[T]]}_{[[x]]} }}
	| [ G ] :: :: sem_tyenv  {{ tex \sem{[[G]]} }}
	| logical_frag1 /\ logical_frag2 :: :: conj
	| ! logical_frag :: :: not {{ tex \neg [[logical_frag]]}}
	| ( logical_frag ) :: :: paren
	| logical_frag1 \/ logical_frag2 :: :: disj
	| logical_frag1 ==> logical_frag2 :: :: logical_entailment
	| logical_frag1 <=> logical_frag2 :: :: logical_equiv

  logic_judgment :: '' ::=
	| |= logical_frag :: :: models
	| G |= logical_frag :: :: tyenv_model
	| R |= logical_frag :: :: env_model
	| R !|= logical_frag :: :: env_not_model
	| M |= logical_frag :: :: logical_model

  FVF :: 'FV_' ::=
  	| FPV ( T ) :: :: fpv_t
	| FPV ( ph ) :: :: fpv_p
	| FPCV ( ph ) :: :: fpcv_p
	| FPCV ( T ) :: :: fpcv_tx
    | FV ( e ) :: :: fv

  functions :: 'F_' ::=
	| CV ( B ) :: :: cv
	| Cons ( H , R , G ) :: :: Cons
	| SAT ( H , R , G ) :: :: SAT
	| SATv ( H , R , Rv , T ) :: :: satv {{ tex \mathit{SAT}_v([[H]],[[R]],[[Rv]],[[T]]) }}
	| F :: :: omap

   F :: 'OM_' ::=
    | { a |-> r } :: :: omap
	| F1 + F2 :: :: omap_add
	| own ( H , Rv , T ) :: :: own_fn
	| empty :: :: empty {{ tex \emptyset }}
	| |< { x in VS } F :: :: sum {{ tex [[|<]]_{[[x]]\in[[VS]]}\,[[F]] }}

  model :: 'M_' ::=
    | M :: :: m {{ tex \mathcal{M} }}

  judgment :: 'j_' ::=
    | G |- T1 <: T2       ::   :: sub
	| B |- T => G :: :: wftenv {{ tex [[B]] [[|-]]_{WF} [[T]] [[=>]] [[G]] }}
    | G1 <: G2            ::   :: subG
    | Th | G1 | B |- e : T => G2   ::   :: exp
    | C1 reduction D C2         ::   :: red        {{ tex [[C1]] [[reduction]]_[[D]] [[C2]] }}
	
	| B |- G :: :: tyenvwf {{ tex [[B]] [[|-]]_{WF} [[ G ]] }}
	| G | B |- T :: :: twf {{ tex [[G]] [[|]] [[B]] [[|-]]_{WF} [[T]] }}
	| Gst | B |- ph :: :: phwf {{ tex [[Gst]] [[|]] [[B]] [[|-]]_{WF} [[ph]] }}
	| T1 = T2 :: :: teq
	| ST1 = ST2 :: :: steq
	| Th |- d :: :: fun_typ
	| |- P :: :: prog_typ
	| Th |- D :: :: f_typing
	| |- D C :: :: ctxt_type {{ tex \vdash_C^D [[ C ]] }}
	| Th | [] : T => G | B |-e E : T' => G' :: :: ctxt_typing
	| Th | [] : T => G | B |-e CE : T' => G' :: :: ectxt_typing
	| |- Th :: :: funenvWf
	| |- FT :: :: ftWf

  bind :: 'Bin_' ::=
    | x :: :: pvar
	| A :: :: cvar
	| a  :: :: addr
	| f :: :: fname
	| v :: :: value

  MF :: 'MF_' ::=
    | G :: :: tyenv
	| R :: :: env
	| Gst :: :: stTenv
	| H :: :: heap
	| Th :: :: funenv
	| F :: :: ownership_map

  VS :: 'VS_' ::=
    | VS1 U VS2 :: :: union {{ tex [[VS1]] \cup [[VS2]] }}
	| { bind } :: :: singleton {{ tex \set{[[bind]]} }}
	| { bind1 ,, bindn } :: :: count {{ tex \set{[[bind1]],\ldots,[[bindn]]} }}
	| { bind1 , ... , bindn } :: :: concr
	| FVF :: :: free_var_fun
	| dom MF :: :: dom_mf {{ tex \textit{dom}([[MF]]) }}
	| VS1 '\' VS2 :: :: minus {{ tex [[VS1]] \setminus [[VS2]] }}

  EqT :: 'EqT_' ::= {{ com equatable terms }}
    | e :: :: expt
	| Gst :: :: simple_g
	| G :: :: gamma
	| B :: :: ctxt_string
	| Rv :: :: runtime_value
	| VS :: :: value_set
	| functions :: :: func
	| csub  :: :: context_sub
	| vsub :: :: value_sub
	| C :: :: config
	| termvar :: :: var
	| H :: :: heap
	| E :: :: ctxt
	| r :: :: own

  formula :: formula_ ::=
    | logical_frag1 = logical_frag2 :: :: eq_form
    | logical_frag :: :: frag
    | judgment :: :: judge
	| functions :: :: func
	| logic_judgment :: :: lj
    | r1 rel_op r2 :: :: own_ge {{ tex [[r1]] [[rel_op]] [[r2]] }}
	| formula1 <=> formula2 :: :: meta_biimpl
	| formula1 ==> formula2 :: :: meta_entail
	| formula ( x in dom ( G ) ) :: :: quantified {{ tex [[formula]]\,\,(x \in dom([[G]])) }}
	| Th ( f ) = FT :: :: fun_typ_lkp
	| bind fresh in MF :: :: notinEnv {{ tex [[bind]] \not\in dom([[MF]]) }}
	| bind in MF :: :: inMap {{ tex [[bind]] \in dom([[MF]]) }}
	| bind not in MF :: :: notInMap {{ tex [[bind]] \not\in dom([[MF]]) }}
	| bind in VS :: :: inFv {{ tex [[bind]] \in [[VS]] }}
	| bind not in VS :: :: notInFv {{ tex [[bind]] \not\in [[VS]] }}
	| VS1 sub VS2 :: :: subset {{ tex [[VS1]] \subseteq [[VS2]] }}
	| Rv is INT :: :: in_int {{ tex [[Rv]] \in [[INT]] }}
	| d in D :: :: funDef {{ tex [[d]] \in [[D]] }}
	| formula1 ... formulan :: :: dots
	| EqT1 = EqT2 :: :: equate
	| EqT1 = EqT2 ... = EqT3 :: :: eq_list 
	| EqT1 != EqT2 :: :: ineq {{ tex [[EqT1]] \neq [[EqT2]] }}
	| r1 <= r2 .. <= r3 :: :: rel_list
	| formula1 /\ formula2 :: :: meta_conj
	| forall formula1 . formula2 :: :: uq
	| ( formula ) :: :: parenF
	| T1 ~ T2 :: :: tEqual
	| H1 ~ a H2 :: :: h_mod_equiv {{ tex [[H1]] [[~]]_[[a]] [[H2]] }}
	| R1 < R2 :: :: reg_weak {{ tex [[R1]] \sqsubseteq [[R2]] }}

