% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.20 of 2017/10/04
%
\documentclass[runningheads]{llncs}
%
\usepackage{bcprules}\typicallabel{T-Hoge}
\usepackage{bcpproof}
\usepackage{graphicx,color}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
% \renewcommand\UrlFont{\color{blue}\rmfamily}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{parcolumns}
\usepackage{cases}
\usepackage[capitalize,nameinlink,noabbrev]{cleveref}
\usepackage{listings}% http://ctan.org/pkg/listings
\lstset{
  basicstyle=\ttfamily,
  mathescape
}

\input{local}
% \input{../effgrad/def/ott/coe}
\input{./lang}

\begin{document}
%
\title{Context- and Flow-Sensitive Refinement Types for Imperative Programs}
%
%\titlerunning{Abbreviated paper title}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
\author{Ren Siqi \and John Toman \and Kohei Suenaga \and Atsushi Igarashi \and Naoki Kobayashi}
%
\authorrunning{Ren Siqi et al.}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{}
%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}

\keywords{}
\end{abstract}
%
%
%
\input{intro}
\input{preliminaries}
\input{typesystem}
\input{impl}
\input{experiments}
\input{related_work}
\input{conclusion}

\section{Simple setting without indirection of pointers and without subtyping}

\newcommand\val{v}

\subsection{Language}

This section describes a simple imperative  language that contains memory cells for ownership access.
For language extensions and type systems, see the following sections dealing with other language structures.
The grammar of the language is as follows.


\[
  \begin{array}{rcl}
  [[d]] &::=& [[f |-> (x1,...,xn)e ]] \\
  [[e]] &::= &
               [[ x ]] \mid
               [[ let x = y in e]] \mid
               [[ let x = v in e ]] \mid
               [[ ifz x then e1 else e2 ]] \\
        &\mid& [[ let x = mkref y in e ]] \mid
               [[ let x = *y in e ]] \mid
               [[ let x = f l (y1 ,, yn) in e ]] \\
        &\mid& [[ x := y ; e ]] \mid
               [[ alias(x = y); e ]] \mid
               [[ assert(ph); e ]] \mid
               [[ e1;e2 ]] \\
    [[v]] &::=& [[nn]] \\
    [[P]] &::=& [[<{d1,...,dn}, e>]] \\
    [[l]] &\in& \textbf{Labels}\\
  \end{array}
\]

\(\varphi\) stands for a logical formula over integers and paths $\pps$).
We assume a set of \emph{variables}, which is ranged over by $x,y,z,\dots$, and a set of \emph{locations}, which is ranged over by $a,b,c,\dots$.


We now introduce the grammar of the imperative language.
We use an ML-like syntax with mutable references, assertions, and must-alias annotations.
We highlight some distinctive features as belows.

Like ML, the variable bindings introduced by let-expression are immutable.
Modeling a mutable variable declaration \texttt{int x = 1} in a language like C is achieved with

\[
  [[ let y = 1 in (let x = mkref y in etc) ]]
\]
in our language.

We do not allow general expressions as right hand side with let bindings.
The simplest right-hand forms are a variable $[[y]]$, or an integer.
Also, we have let bindings to $[[mkref y]]$ which creates a reference cell with value $[[y]]$, $[[*y]]$ which is to access the contents of $[[y]]$ and
function calls $[[f l (x1,,xn)]]$, where $[[x1,,xn]]$ are distinct variables and $l$ is label.
$[[ifz]]$ judges whether $[[x]]$ equals to zero and choose the corresponding branch.

Our grammar requires that all side-effecting, result free statements, $[[ assert(ph); e ]]$, $[[alias(x = y);e]]$,
and assignment $[[x := y;e]]$ are followed by a continuation expression. This requirement does not reduce the expressiveness
of the language, and obviates including a unit type.
The expression $[[e1 ; e2]]$ is a sequence execution of $[[e1]]$ and $[[e2]]$.
A program is a pair of $[[<{d1,...,dn}, e>]]$, where $[[ {d1,...,dn} ]]$ is a set of function definitions.
The definition of function maps a function name to a tuple of argument names that are bound within the function body $[[e]]$;
additionally functions are not higher order.

The expression $[[assert(ph) ; e]]$ executes $[[e]]$ if the predicate $[[ph]]$ holds, and aborts the program otherwise.
We introduce $[[alias(x = y); e]]$ as a specialized type of assertion for asserting a must aliasing relationship between two references $x$ and $y$.
Our type system uses these must-alias annotations to accurately resolve aliases.

\paragraph{Operational Semantics}
We now introduce the operational semantics for our system.
A runtime state is represented by a configuration $[[<H, R,Es,e>]]$, which consists of a heap,
register file, stack, and currently reducing expression.
Secondly, while the final configuration component is an expression,
the rewritting rules are defined in terms of $[[ E[e] ]]$, which is a context $[[E]]$ and redex $[[e]]$, as is standard.
Our operational semantics are mostly standard.
We have highlight some import points as the following paragraphs.

First we introduce return contexts $[[ E[let y = [] l in e] ]]$.
This return context represents a pending function call. The hole indicates the return value of the callee should be bound to $[[y]]$
within the expression $[[e]]$. Our call-stack is a sequence of these return contexts, with the first such return context indicating the
most recent function call.
We write $[[ E[let y = [] l in e] ]][x]$ to denote substituting the variable $x$ into the hole in $[[ let y=[] l in e]]$.
The set of evaluation contexts and return contexts are defined by Figure.$\ref{fig:eval-context-grammar}$.
The semantics of a calls are given in $\rn{R-Call}$.
For a function call $[[ let x = f l (y1,,yn) in e ]]$, where $f$ is defined as $[[(x1,..., xn)e']]$,
we first push the return context $[[ E[let y = [] l in e] ]]$ onto the stack $[[Es]]$.
We then substitute the formal arguments for parameters in $e'$, denoted by $[[ [y1/x1],,[yn/xn]e' ]]$.
The result of this substitution becomes the currently reducing expression.
Function returns are handled by $\rn{R-Var}$.
Our semantics return values by name; when the currently executing function fully reduces to a single variable $x$,
we substitue $x$ into the return context on the top of the stack.

In the rules $\rn{R-Assert}$ we write $[[R |= ph]]$ to mean that for
any model $[[M]]$ in our underlying theory such that
$[[ forall x in R.R(x) is INT ==> M(x) = R(x) ]]$ $[[ M |= ph ]]$ holds.
We introduce $[[AliasFail]]$ and $[[AssertFail]]$ as two special configurations.
$[[AssertFail]]$ will be thrown if the precondition $[[R |= ph]]$ doesn't hold in the current state.
$[[AliasFail]]$ will be thrown when two references do not alias in $\rn{R-AliasFail}$.

When the expression is a let-binding, in order to better handle conflicts
with recursive functions and duplicates variable names in our single register file,
we refresh the bound variable $[[x]]$ in a let expression to $[[x']]$.
Take expression $[[let x=y in e]]$ as an example;
we substitute a fresh variable $[[x']]$ for $[[x]]$ in $[[e]]$, then bind $[[x']]$ to the value
of variable $[[y]]$.
Finally, notice that although $\rn{R-MkRef}$ allocates new memory, our language does not reclaim memory.
We consider garbage collection an orthogonal concern and do not treat it in our formalism.

\begin{definition}
  Context strings $[[B]]$ are defined as follows:
  \[
    \begin{array}{rcl}
      [[ B ]] & ::= & [[ . ]] \mid [[ l ]] : [[ B ]] \mid [[A]]
    \end{array}
  \]
  $[[A]]$ is a context string variable. Let $[[CV(B)]]$ be $\set{[[A]]}$ for
  context strings whose final element is $[[A]]$ and $\emptyset$ otherwise.
\end{definition}

\begin{definition}
  $\sem{[[T]]}_y$ is defined as follows:
  \[
    \begin{array}{rcl}
      \sem{[[{x:int | ph}]]}_y &=& [[ [y/x]ph ]]\\
      \sem{[[{x:int | ph} ref r]]} &=& [[ Top ]]
    \end{array}
  \]
\end{definition}

\begin{definition}
  The refinement predicates $[[ph]]$ are defined as follows:
  \[
    \begin{array}{rcl}
      [[ph]] & ::= & [[ph1 ==> ph2]] \mid
                     [[ ph1 /\ ph2 ]] \mid
                     [[ pfun(x1,..,xn) ]] \mid
                     [[ lvar = V' ]] \mid [[ lvar != V' ]] \\
             & \mid & [[ B1 = B2? ]] \\
      [[ V ]] & ::= & [[ x ]] \mid [[ v ]]
    \end{array}
  \]
  $[[pfun]]$ is a predicate symbol with an interpretation in the
  theory used by the underlying solver. The predicate $[[ B1 = B2? ]]$ is a prefix
  query which checks whether $[[B2]]$ is a prefix of $[[B1]]$. We write $[[FPV(ph)]]$ for
  the free variables occuring in $[[ph]]$, and write $[[FPCV(ph)]]$ for the free context
  variables that appear in $[[ph]]$.
  Formally, $\mathbf{FPV}$ is defined as
  \begin{align*}
    [[FPV(ph1 /\ ph2)]] & = [[FPV(ph1)]] \cup [[FPV(ph2)]] \\
    [[FPV(ph1 ==> ph2)]] & = [[FPV(ph1)]] \cup [[FPV(ph2)]] \\
    [[FPV(pfun(x1,..,xn))]] & = \set{[[x1]],\ldots,[[xn]]} \\
    [[FPV(B1 = B2?)]] & = \emptyset \\\
    [[FPV(lvar = V')]] & = \begin{cases}
      \emptyset & [[lvar]] \equiv  [[v]] \\
      \set{x} & [[lvar]] \equiv [[x]]
    \end{cases} \cup \begin{cases}
      \emptyset & [[V']] \equiv  [[v]] \\
      \set{x} & [[V']] \equiv [[x]]
    \end{cases} \\\
    [[FPV(lvar != V')]] & = [[FPV(lvar = V')]]
  \end{align*}
  Through abuse of notation we will also write $[[FPV(T)]]$ to indicate the free variables
  in the refinement of $[[T]]$, i.e.:
  \begin{align*}
    [[FPV(T' ref r)]] & = [[FPV(T')]] \\
    [[FPV({x:int|ph})]] & = [[FPV(ph)]] \setminus \set{[[x]]}
  \end{align*}
  and $[[FPCV(T)]]$ to indicate free variables that appear in the refinement of $[[T]]$.
\end{definition}

\begin{figure}[t]
  \leavevmode
  \infrule[WF-Env]{
    [[ forall x in G. G | B |- G(x) ]]
  }{
    [[B |- G]]
  }
  \infrule[WF-Int]{
    [[ST(G), x:int | B |- ph]]
  }{
    [[G | B |- { x:int|ph} ]]
  }
  \infrule[WF-Ref]{
    [[G | B |- T]]
  }{
    [[G | B |- T ref r ]]
  }
  \infrule[WF-Phi]{
    [[FPV(ph)]] \subseteq \set{x \mid [[x in Gst /\ Gst(x) = int]]} \andalso
    [[FPCV(ph)]] \subseteq [[CV(B)]]
  }{
    [[Gst | B |- ph]]
  }
  \infrule[WF-Result]{
    [[G | B |- T]] \andalso
    [[B |- G]]
  }{
    [[ B |- T => G ]]
  }
  \infrule[WF-FunType]{
    [[ A |- x1:T1,,xn:Tn ]] \\ [[ A |- T => x1:T1',,xn:Tn' ]]
  }{
    [[ |- A <x1:T1,,xn:Tn> -> <x1:T1',,xn:Tn'|T> ]]
  }
  \infrule[WF-FunEnv]{
    [[ forall f in Th.|- Th(f)]]
  }{
    [[ |- Th ]]
  }
  \caption{Well-formedness of types and environments}
  \label{fig:type-wf}
\end{figure}

\begin{definition}[Well-formedness of types]
  We define simple types $[[ST]]$ and environments $[[Gst]]$ by:
  \[
    \begin{array}{rcl}
      [[ST]] & ::= & [[int]] \mid [[ int ref ]]  \\
      [[Gst]] & ::= & [[empty]] \mid [[Gst,x:ST]]
    \end{array}
  \]
  Let $[[ST(G)]]$ be the obvious transformation of $[[G]]$ into $[[Gst]]$.
  The well-typedness of types and type environments are shown in \cref{fig:type-wf}.
\end{definition}

\begin{definition}
  $[[ [G] ]]$ is defined as follows:
  \[
    \begin{array}{rcl}
      [[ [empty] ]] &=& [[ Top ]]\\
      [[ [G,x: T] ]] &=& [[ [G] /\ [T] x ]] \\
    \end{array}
  \]
\end{definition}

\begin{definition}
  We write $[[G |= ph]]$ if $[[ |= [G] ==> ph]]$ is valid.
\end{definition}

\paragraph{Operations on types.}

\begin{figure}[t]
  \leavevmode
  \infax[Tadd-Int]{
    [[{x:int|ph1} + {x:int|ph2} = {x:int|ph1 /\ ph2}]]
  }
  \infrule[Tadd-Ref1]{
    [[r1]] \ne 0 \andalso
    [[r2]] \ne 0
  }{
    [[T1 ref r1 + T2 ref r2 = (T1 + T2) ref r1 + r2]]
  }
  \infrule[Tadd-Ref2]{
    [[r]] > 0
  }{
    [[ T1 ref 0 + T2 ref r = T2 ref r]]
  }
  \infax[Tadd-Ref3]{
    [[T1 ref 0 + T2 ref 0 = { x: int | Top } ref 0]]
  }
  \caption{Rules for $[[ T1 + T2 ]]$.}
  \label{fig:addition}
\end{figure}

\begin{figure}
  \leavevmode
  \infrule[TEq-Ref]{
    [[T1 ~ T2]] \andalso [[r1]] = [[r2]]
  }{
    [[T1 ref r1 ~ T2 ref r2]]
  }

  \infrule[TEq-Int]{
    [[|= ph1 <=> ph2]]
  }{
    [[ {x:int | ph1} ~ {y:int | ph2} ]]
  }
  \caption{Rules for type equality}
  \label{fig:equality}
\end{figure}

\begin{definition}
  $[[ T1 + T2 ]]$ is the least commutative partial operation that satisfies the rules in Figure~\ref{fig:addition}.
\end{definition}

\begin{definition}
  We define equalilty modulo logical
  equivalence (or just ``equality'') between two types, written as $[[ T1 ~ T2 ]]$,
  as the least binary relation closed under the rules shown \cref{fig:equality}.
\end{definition}


\begin{definition}
  The typed equality proposition $[[ x = T y ]]$ is defined as
  \[
    [[ x = T y ]] \equiv \begin{cases}
      [[ x = y ]] & [[ T = {z:int|ph} ]] \\
      [[ Top ]] & o.w.
      \end{cases}
  \]
\end{definition}
\begin{definition}
  $[[T /\ y ph]]$ is the strengthening operation defined as:
  \[
    [[ T /\ y ph' ]] = \begin{cases}
      [[ { z: int | [z/x]ph /\ [z/y]ph' }]] & [[ T = { x: int | ph } /\ z not in FPV(ph') /\ z not in FPV(ph) ]] \\
      [[ T ]] & o.w.
    \end{cases}
  \]
\end{definition}

\begin{definition}{Context Substitution}
  Define context substitution operation $[[ [B/A] ]]$ over predicates $[[ph]]$, types $[[T]]$, and type environments $[[G]]$, as:

  \begin{align*}
    [[ [B/A](ph1 /\ ph2) ]] & = [[ [B/A]ph1 /\ [B/A]ph2 ]] \\
    [[ [B/A](ph1 ==> ph2) ]] & = [[ [B/A]ph1 ==> [B/A]ph2 ]] \\
    [[ [B/A]pfun(x1,..,xn) ]] & = [[ pfun(x1,..,xn) ]] \\
    [[ [B/A](lvar = V') ]] & = [[ lvar = V' ]] \\
    [[ [B/A](lvar != V') ]] & = [[ lvar != V' ]] \\
    [[ [B/A](B' = B''?) ]] & = [[ [B/A]B' = [B/A]B''? ]] \\
    [[ [B/A](T ref r) ]] & = [[([B/A] T) ref r]] \\
    [[ [B/A]{x:int|ph} ]] & = [[{x:int|[B/A]ph}]] \\
    [[ [B/A](G,x: T) ]] & = [[ ([B/A]G), x : [B/A]T ]] \\
    [[ [B/A]empty ]] & = [[ empty ]] \\
  \end{align*}
\end{definition}

\paragraph{Subtyping.}

\begin{figure}[t]
\leavevmode
\infrule[Sub-Int]{
  [[G |= ph1 ==> ph2]]
  }{
   [[G |- {x:int|ph1} <: {y:int|ph2}]]
  }
  \infrule[Sub-Ref]{
    [[r1 >= r2]]
    \andalso
    [[r2 > 0 ==> G |- T1 <: T2 ]]
  }{
    [[ G |- T1 ref r1 <: T2 ref r2 ]]
  }
  \infrule[Sub-TyEnv]{
    [[ forall x in G'.G|- G(x) <: G'(x) ]]
  }{
    [[ G <: G' ]]
  }
  \caption{Rules for subtyping.}
  \label{fig:subtyping}
\end{figure}

\paragraph{Type judgment.}

\AI{\rn{T-Let} loses information that $x$ is equal to $y$ (unlike \rn{T-LetInt}).}

\begin{figure}[t]
  \leavevmode
  \infrule[T-Var]{
  }{
    [[ Th | G [ x : T1 + T2] | B |- x : T1 => G[ x <- T2 ] ]]
  }
  \infrule[T-Let]{
    [[ Th | G [ y <- T1 /\ y y = T1 x  ], x : (T2 /\ x x = T2 y) | B |- e : T => G']] \andalso
    [[B |- T => G' \ x]]
  }{
    [[ Th | G[y: T1 + T2] | B |- let x = y in e : T => G' \ x]]
  }
  \infrule[T-LetInt]{
    [[ Th | G, x:{x : int | x = nn } | B |- e : T => G']] \andalso
    [[B |- T => G' \ x]]
  }{
    [[ Th | G | B |- e : T => G' \ x]]
  }
  \infrule[T-If]{
    [[ Th | G[x <- {y:int | ph /\ y = 0 }] | B |- e1 : T => G' ]] \\
    [[ Th | G[x <- {y:int | ph /\ y != 0}] | B |- e2 : T => G' ]]
  }{
    [[ Th | G[x : {y:int|ph}] | B |- ifz y then e1 else e2 : T => G' ]]
  }
  \infrule[T-MkRef]{
    [[ Th | G[y <- T1],x : (T2 /\ x x = T2 y) ref 1 | B |- e : T => G']] \andalso
    [[ B |- T => G' \ x ]]
  }{
    [[ Th | G[y : T1 + T2] | B |- let x = mkref y in e : T => G' \ x ]]
  }
  \infrule[T-Deref]{
    [[r > 0]] \andalso
    [[ Th | G[y <- (T1 /\ y y = T1 x) ref r], x : T2 | B |- e : T => G']] \andalso
    [[ B |- T => G' \ x ]]
  }{
    [[ Th | G[y: (T1 + T2) ref r] | B |- let x = *y in e : T => G' \ x ]]
  }
  \infrule[T-Call]{
    [[ Th(f) = A < x1 : T1 ,, xn : Tn > -> <x1: T1' ,, xn : Tn' | T > ]] \\
    [[csub = [l:B/A] ]] \andalso [[ vsub = [y1/x1] ,, [yn/xn] ]] \\
    [[ Th | G[yi <- csub vsub Ti'], x : csub vsub T | B |- e : T' => G' ]] \\
    [[ B |- T' => G' \ x]]
  }{
    [[ Th | G[yi: csub vsub Ti] | B |- let x = f l (y1,,yn) in e : T' => G' \ x]]
  }
  \infrule[T-Assign]{
    (\text{The shapes of $[[T']]$ and $[[T2]]$ are similar}) \\
    [[ Th | G[x <- T1][y <- T2 /\ y y = T2 x ref r] | B |- e : T => G']] \\
  }{
    [[ Th | G[x: T1 + T2][y : T' ref 1] | B |- y := x; e : T => G']]
  }
  \infrule[T-Alias]{
    [[(T1 ref r1 + T2 ref r2) ~ (T1' ref r1' + T2' ref r2')]] \\
    [[ Th | G[x <- T1' ref r1'][y <- T2' ref r2'] | B |- e : T => G']]
  }{
    [[ Th | G[x : T1 ref r1][y: T2 ref r2] | B |- alias(x = y); e : T => G' ]]
  }
  \infrule[T-Seq]{
    [[ Th | G | B |- e1 : T' => G' ]] \andalso
    [[ Th | G' | B |- e2 : T'' => G'' ]]
  }{
    [[ Th | G | B |- e1 ; e2 : T'' => G'' ]]
  }
  \infrule[T-Assert]{
    [[ G |= ph ]] \andalso
    [[ Th | G | B |- e : T => G' ]]
  }{
    [[ Th | G | B |- assert(ph); e : T => G']]
  }
  \infrule[T-Sub]{
    [[ G <: G' ]] \andalso
    [[ Th | G' | B |- e : T => G'' ]] \andalso
    [[ x not in G ]] \andalso
    [[ G'', x:T <: G''',x:T' ]]
  }{
    [[ Th | G | B |- e : T' => G''' ]]
  }
  \caption{Expression typing rules.}
  \label{fig:typingRules}
\end{figure}
\begin{figure}
  \infrule[T-FunDef]{
    [[ Th (f) = A <x1 : T1 ,, xn : Tn > -> < x1: T1' ,, xn : Tn' | T> ]] \\
    [[ Th | x1:T1 ,, xn:Tn | A |- e : T => x1: T1' ,, xn : Tn' ]]
  }{
    [[ Th |- f |-> (x1,..,xn) e ]]
  }
  \infrule[T-Funs]{
    \forall [[f |-> (x1, .., xn) e in D]].[[ Th |- f |-> (x1,..,xn) e ]]
  }{
    [[ Th |-  D ]]
  }
  \infrule[T-Prog]{
    [[ Th |- D ]] \andalso
    [[ Th | empty | . |- e : T => G ]]
  }{
    [[ |- < D, e > ]]
  }
\caption{Program typing rules}
\label{fig:progTyping}
\end{figure}

\AI{\rn{T-Let} discards all the refinement on \(x\).  Probably we should propagate it to $\tenv'$.}

\AI{\rn{T-Let} and \rn{T-LetInt} can be merged.}

\AI{\rn{T-Call} requires actual arguments to be variables introduced at the end of the type environment.  This is not a restriction because one can introduce let-expressions before a function call and alias-expressions after the call.}

\AI{$\varepsilon$ in \rn{T-Prog} stands for the empty string.}

In \cref{fig:typingRules} $[[ G[x: T] ]]$ denotes an environment
$[[G]]$ such that $[[G(x) = T]]$. $[[ G[x <- T] ]]$ denotes the functional update of the type
of $[[x]]$ to $[[T]]$ in $[[G]]$.



\subsection{Examples}
For examples, consider the following programs, written in an ML-like language.
The righthand side shows the types assigned to each variable before execution of
each line.
\begin{parcolumns}{2}
\colchunk[1]{%
\begin{verbatim}
[1]
  let x = mkref 1 in
  let y = *x in
    assert(y>0)
\end{verbatim}
}
\colchunk[2]{%
\newline
\newline
  $\emptyset$ \newline
  $x \COL \set{r \COL \TINT \mid r = 1} \TREF^1$ \newline
  $x \COL \set{r \COL \TINT \mid r = 1} \TREF^1, y \COL \set{r \COL \TINT \mid r = 1}$ \newline
}
\colplacechunks
\end{parcolumns}

\begin{parcolumns}{2}
\colchunk[1]{%
\begin{verbatim}
[2]
  let x = mkref 1 in
  let y = *x in
    assert(y<0)
\end{verbatim}
}
\colchunk[2]{%
\newline
\newline
  $\emptyset$ \newline
  $x \COL \set{r \COL \TINT \mid r = 1} \TREF^1$ \newline
  $x \COL \set{r \COL \TINT \mid r = 1} \TREF^1, y \COL \set{r \COL \TINT \mid r = 1}$ \newline
}
\colplacechunks
\end{parcolumns}

In example[1] and example[2], from typing rule for T-MkRef, the ownership for varible $x$ will be 1.
As for dereference, $y$ will hold the same value as $x$.The only difference in the programs is the
assert statements, from the types of varible $y$, it's clear that the example[1] will return true,
and the example[2] will be false, since $y \COL \set{r \COL \TINT \mid r = 1} \models y > 0$.

\begin{parcolumns}{2}
\colchunk[1]{%
\begin{verbatim}
[3]
  let x = mkref 1 in
  let y = x in
  let z = *y in
    assert(z>0)
\end{verbatim}
}
\colchunk[2]{%
\newline
\newline
  $\emptyset$ \newline
  $x \COL \set{r \COL \TINT \mid r = 1} \TREF^1$ \newline
  $x \COL \set{r \COL \TINT \mid r = 1} \TREF^0, y \COL \set{r \COL \TINT \mid r = 1} \TREF^1$ \newline
  $x \COL \set{r \COL \TINT \mid r = 1} \TREF^0, y \COL \set{r \COL \TINT \mid r = 1} \TREF^1, z \COL \set{r \COL \TINT \mid r = 1}$ \newline
}
\colplacechunks
\end{parcolumns}

In example[3], from T-Let $x$ will transfer the ownership of the reference cell to $y$, so that the
owership of $y$ will be 1 and then can be dereferenced to $z$ with the return value, the result of
the assertion is true, since $z \COL \set{r \COL \TINT \mid r = 1} \models z>0$

\begin{parcolumns}{2}
\colchunk[1]{%
\begin{verbatim}
[4]
  let x = mkref 1 in
  let y = x in
    y := -1;
    let z = *y in
      assert(z>0)
\end{verbatim}
}
\colchunk[2]{%
\newline
\newline
  $\emptyset$ \newline
  $x \COL \set{r \COL \TINT \mid r = 1} \TREF^1$ \newline
  $x \COL \set{r \COL \TINT \mid r = 1} \TREF^0, y \COL \set{r \COL \TINT \mid r = 1} \TREF^1$ \newline
  $x \COL \set{r \COL \TINT \mid r = 1} \TREF^0, y \COL \set{r \COL \TINT \mid r = -1} \TREF^1$ \newline
  $x \COL \set{r \COL \TINT \mid r = 1} \TREF^0,y \COL \set{r \COL \TINT \mid r = -1} \TREF^1, z \COL \set{r \COL \TINT \mid r = -1}$ \newline
}
\colplacechunks
\end{parcolumns}

In example[4], it contains update the value of $y$ to $-1$. From T-Assign it only changes the value of $y$.
And the result should be false obviously, because $z \COL \set{r \COL \TINT \mid r = -1} \not\models z>0$.
The refinement type $\set{r \COL \TINT \mid r = 1}$ of $x$ after the command $y := -1$ does not reflect the actual value of $*x$.
This is OK in our type system because the ownership of the reference $x$ is $0$; the refinement attached to this reference type is not reliable.

\begin{parcolumns}{2}
\colchunk[1]{%
\begin{lstlisting}
[5]
  let x = mkref 1 in
  let y = x in
  let $z_1$ = *y in
  let $z_2$ = *x in
    assert($z_1$>0 && $z_2$>0)
\end{lstlisting}
}
\colchunk[2]{%
\newline
\newline
  $\emptyset$ \newline
  $x \COL \set{r \COL \TINT \mid r = 1} \TREF^1$ \newline
  $x \COL \set{r \COL \TINT \mid r = 1} \TREF^{0.5}, y \COL \set{r \COL \TINT \mid r = 1} \TREF^{0.5}$ \newline
  $x \COL \set{r \COL \TINT \mid r = 1} \TREF^{0.5},y \COL \set{r \COL \TINT \mid r = 1} \TREF^{0.5}, z_1 \COL \set{r \COL \TINT \mid r = 1}$ \newline
  $x \COL \set{r \COL \TINT \mid r = 1} \TREF^{0.5},y \COL \set{r \COL \TINT \mid r = 1} \TREF^{0.5},z_1 \COL \set{r \COL \TINT \mid r = 1},z_2 \COL \set{r \COL \TINT \mid r = 1}$ \newline
}
\colplacechunks
\end{parcolumns}

In example[5], dereferencing doesn't change the ownership of each variable, and the result
of assertion is true, because $z_1 \COL \set{r \COL \TINT \mid r = 1},z_2 \COL \set{r \COL \TINT \mid r = 1}\models z_1, z_2>0$.

\begin{parcolumns}{2}
\colchunk[1]{%
\begin{lstlisting}
[6]
  let x = mkref 1 in
  let y = x in
  let $z_1$ = *y in
  let $z_2$ = *x in
    x := 0;
    let $z_3$ = *x in
      assert($z_3$=0)

\end{lstlisting}
}
\colchunk[2]{%
\newline
\newline
  $\emptyset$ \newline
  $x \COL \set{r \COL \TINT \mid r = 1} \TREF^{1}$ \newline
  $x \COL \set{r \COL \TINT \mid r = 1} \TREF^{r_1}, y \COL \set{r \COL \TINT \mid r = 1} \TREF^{1-r_1} \mbox{where $1 > r_1 > 0$}$ \newline
  $z_1 \COL \set{r \COL \TINT \mid r = 1}$ \newline
  $z_2 \COL \set{r \COL \TINT \mid r = 1}, r_1 = 1 \mbox{ which contradicts to $1 > r_1 > 0$}$ \newline
  safe but cannot be typed
}
\colplacechunks
\end{parcolumns}

In example[6], after dereferencing $x$ to $z_2$ the ownership of $x$ will become 0, which means that
it can't be updated in our type system. But we can add statement \textbf{alias}(x=y)
to shuffle the ownerships between $x$ and $y$, then the program will be typable as belows. And the assert
statement will give true result, since $z_3 \COL \set{r \COL \TINT \mid r = 0}\models z_3 = 0$.

\begin{parcolumns}{2}
\colchunk[1]{%
\begin{lstlisting}
[6 typable]
  let x = mkref 1 in
  let y = x in
  let $z_1$ = *y in
  let $z_2$ = *x in
    alias(x=y)
    x := 0;
    let $z_3$ = *x in
      assert($z_3$=0)
\end{lstlisting}
}
\colchunk[2]{%
\newline
\newline
  $\emptyset$ \newline
  $x \COL \set{r \COL \TINT \mid r = 1} \TREF^1$ \newline
  $x \COL \set{r \COL \TINT \mid r = 1} \TREF^{0.5}, y \COL \set{r \COL \TINT \mid r = 1} \TREF^{0.5}$ \newline
  $x \COL \set{r \COL \TINT \mid r = 1} \TREF^{0.5},y \COL \set{r \COL \TINT \mid r = 1} \TREF^{0.5}, \dots$ \newline
  $x \COL \set{r \COL \TINT \mid r = 1} \TREF^{0.5}, y \COL \set{r \COL \TINT \mid r = 1} \TREF^{0.5}, \dots$ \newline
  $x \COL \set{r \COL \TINT \mid r = 1} \TREF^{1}, y \COL \set{r \COL \TINT \mid r = 1} \TREF^{0},\dots$ \newline
  $x \COL \set{r \COL \TINT \mid r = 0} \TREF^1, y \COL \set{r \COL \TINT \mid r = 1}\TREF^{0},\dots$ \newline
  $x \COL \set{r \COL \TINT \mid r = 0} \TREF^1, y \COL \set{r \COL \TINT \mid r = 1}\TREF^{0},z_3 \COL \set{r \COL \TINT \mid r = 0}$ \newline
}
\colplacechunks
\end{parcolumns}

In order to derive example for Context-Sensitiveness, we first focus on examples for function. Here are examples for “push/pull” instructions.
We can see that function $\bf{push}$ is just assign an integer $x$ to variable $p$. $\bf{pull}$ is to pop the integer stored in $p$. Here we write
$\sigma \COL\COL= \forall \beta.<\dots>\ra <\dots\mid\tau>$ to contain the return values.

\begin{parcolumns}{2}
\colchunk[1]{%
\begin{verbatim}
[7 push]
  def push(p, x) =
    p := x;
\end{verbatim}
}
\colchunk[2]{%
\newline
\newline
  $\bf{push} \COL \newline
  \forall \beta. p\COL \set{n \COL \TINT \mid T}\TREF^1, x\COL \set{n \COL \TINT \mid \frac{(\beta[0]=l_1\Rightarrow n=0)\land}{(\beta[0]\neq l_1\Rightarrow n>0))}} \ra \newline
  p\COL \set{n \COL \TINT \mid n=x_{pre}}\TREF^1, x\COL \set{n \COL \TINT \mid x_{pre}=x}$ \newline
}
\colplacechunks
\end{parcolumns}

\begin{parcolumns}{2}
\colchunk[1]{%
\begin{verbatim}
[8 pull]
  def pull(p) =
    *p;
\end{verbatim}
}
\colchunk[2]{%
\newline
\newline
  $\bf{pull} \COL \newline
  \forall \beta. p\COL \set{n \COL \TINT \mid \frac{(\beta[0]=l_6\Rightarrow n>0)\land}{(\beta[0]\neq l_6\Rightarrow n\geq 0))}}\TREF^1\ra \newline
  p\COL \set{n \COL \TINT \mid p_{pre}=p}\TREF^1\mid \set{n \COL \TINT \mid \frac{(\beta[0]=l_6\Rightarrow n>0)\land}{(\beta[0]\neq l_6\Rightarrow n\geq 0))}}$ \newline
}
\colplacechunks
\end{parcolumns}


After writing the types changing for each function, now we can take an example for explaining context-sensitiveness of our type-system.
In the example[9], using the types changes in the above, we can write the types before executing for each statement.
For every function $\bf{push/pull}$, we also give labels $l_1,\dots,l_6$ to distinguish the context-flow.
It's obvious that the result of assertion should be true, since $x \COL \set{n \COL \TINT \mid n > 0}\models x > 0$.

\begin{parcolumns}{2}
\colchunk[1]{%
\begin{lstlisting}
[9 Context-Sensitiveness]
let p = mkref _ in
let x = mkref _ in
  push$^{l_1}$(p, 0)
  if b then
    x := pull$^{l_2}$(p)
    push$^{l_3}$(p, *x+1)
  else
    x := pull$^{l_4}$(p)
    push$^{l_5}$(p, *x+2)
  x := pull$^{l_6}$(p)
  assert(*x > 0)
\end{lstlisting}
}
\colchunk[2]{%
\newline
\newline
\newline
\newline
  $p\COL \set{n \COL \TINT \mid T}\TREF^1, x\COL \set{n \COL \TINT \mid T}\TREF^1$ \newline
  $p\COL \set{n \COL \TINT \mid n=0}\TREF^1, x\COL \set{n \COL \TINT \mid T}\TREF^1$ \newline\newline
  $p\COL \set{n \COL \TINT \mid n=0}\TREF^1, x\COL \set{n \COL \TINT \mid n\geq 0}\TREF^1$ \newline
  $p\COL \set{n \COL \TINT \mid n>0}\TREF^1, x\COL \set{n \COL \TINT \mid n\geq 0}\TREF^1$ \newline
  $p\COL \set{n \COL \TINT \mid n=0}\TREF^1, x\COL \set{n \COL \TINT \mid T}\TREF^1$ \newline
  $p\COL \set{n \COL \TINT \mid n=0}\TREF^1, x\COL \set{n \COL \TINT \mid n\geq 0}\TREF^1$ \newline
  $p\COL \set{n \COL \TINT \mid n>0}\TREF^1, x\COL \set{n \COL \TINT \mid n\geq 0}\TREF^1$ \newline
  $p\COL \set{n \COL \TINT \mid n>0}\TREF^1, x\COL \set{n \COL \TINT \mid n>0}\TREF^1$ \newline

}
\colplacechunks
\end{parcolumns}

\paragraph{2-CFA Call Sensitivity}

Consider the following program:
\begin{lstlisting}
f(x, b):
  if b then
    f$^{\ell_3}$(x + 1, false)
  else
    g$^{\ell_4}$(x)
g(x): x + 1

let $r_1$ = f$^{\ell_1}$(0, true) in
let $r_2$ = g$^{\ell_2}$(0) in
assert ($r_1 + r_2 \geq 3$);
\end{lstlisting}

This program is clearly correct, as \lstinline{f} will recurse exactly once before execution
flows through to the else branch and the call to \lstinline{g}.

The type system can verify this example if we give f and g the following types:
\begin{align*}
  f: \forall \alpha.\langle&x: \{ n : int \mid (\alpha = \ell_3? \produces n \geq 1) \wedge n \geq 0 \} \\
                           &b: \{ n: bool \mid (\alpha = \ell_3? \produces n = 0) \wedge (\alpha \neq \ell_3? \produces n = 1) \}\rangle \\
                           & \ra \{ n : int \mid n > 1 \} \\
  g: \forall \beta.\langle&x: \{ n : int \mid (\beta = \ell_4\ell_3? \produces n \geq 1) \wedge n \geq 0 \}\rangle \\
                           & \ra \{ n: int \mid n = n_{pre} + 1\}
\end{align*}
(Here we abbreviate $\tuple{x_1:\typ_1,\ldots,x_n:\typ_n} \ra \tuple{x_1:\typ_1,\ldots,x_n:\typ_n\mid \typ}$ as $\tuple{x_1:\typ_1,\ldots,x_n:\typ_n} \ra \typ$ when the types of the arguments
do not change.)

The key step in the typing derivation is at the call to g within the body of $f$. We reach the
call in the type environment:

\begin{align*}
  x: & \{ n : int \mid (\alpha = \ell_3? \produces n \geq 1) \wedge n \geq 0 \} \\
  b: & \{ n: bool \mid (\alpha = \ell_3? \produces n = 0) \wedge (\alpha \neq \ell_3? \produces n = 1) \wedge n = 0 \}
\end{align*}
Notice that we have propagated the path condition induced by the if
statement to the type of $b$.

We then apply the rule T-Call. Performing substitution on the path variable in the type
of g indicates that the argument $x$ must have type:

\[
  [\ell_4\alpha/\beta]\{ n : int \mid (\beta = \ell_4\ell_3? \produces n \geq 1) \wedge n \geq 0 \} = \{ n : int \mid (\ell_4\alpha = \ell_4\ell_3?)\} \produces n \geq 1) \wedge n \geq 0 \}
\]

$x$ indeed has this type. Simplifying the result type of $g$ we have that the overall expression has type:

\[
  \{ n : int \mid (\alpha = \ell_3? \produces n \geq 2) \wedge n \geq 1 \}
\]

It remains to verify that this type satisfies the result type of $f$, i.e.,
$\{ n : int \mid n > 1 \}$. Applying the rule T-Sub, it suffices to
show that:

\begin{align*}
  \models \big( & (\alpha = \ell_3? \produces b = 0) \wedge (\alpha \neq \ell_3? \produces b = 1) \wedge b = 0\big) \produces \\
  & \big((\alpha  = \ell_3? \produces n \geq 2) \wedge n \geq 1\big) \produces n > 1
\end{align*}

In the above, we have omitted the constraint generated from the type of $x$ in the environment
as it is irrelevant. The automated theorem prover Z3 discharges the above implication,
indicating the above subtyping relationship is valid.

It is instructive to also consider the typing of the recursive call in
the true branch of $f$'s body. Per the rule T-Call, substituting
$\ell_3\alpha$ for $\alpha$ in the argument types of $f$ indicates that
\lstinline{x + 1} must have type:
\[
  \{ n : int \mid (\ell_3\alpha = \ell_3? \produces n \geq 1) \wedge n \geq 0 \}
\]
and \lstinline{false} (i.e., \lstinline{0}) must have type:
\[
  \{ n : bool | (\ell_3\alpha = \ell_3? \produces n = 0) \wedge (\ell_3\alpha \neq \ell_3? \produces n = 1) \}
\]
The latter type simplifies to $\{ n : bool \mid n = 0 \}$ which the constant \lstinline{0} has
(tehnically an application of the subtyping rule is required, but it is straightforward).
We must also verify that:
\[
  \tenv \p \{ n : int \mid (\alpha = \ell_3? \produces n \geq 2) \wedge n \geq 1 \} \subt \{ n : int \mid (\ell_3\alpha = \ell_3? \produces n \geq 1) \wedge n \geq 0 \}
\]
It is easy to verify this relationship holds.

\paragraph{\large{\bf{example to explain context stack in the type system}}}
$\newline$

Suppose $\langle H, R,\overrightarrow{E}, l_4 \rangle$ represent heap(memory), register(environment), a sequence of context, program respectively.
Here, $\overrightarrow{E} = E_3:E_2:E_1$, which $E_3$ is the newest context and $E_1$ is the oldest one.
The context flow will go as belows, and $l_3$ is the newest program to call and $l_1$ is obvious the oldest one.
It needs to satisfy the condition $\cup_i \textit{dom}(\tenv_i)= \textit{dom}(R)$.

$\newline\tenv_4, l_3 l_2 l_1 \vdash l_4:\tau_4 \Rightarrow \tenv_4'\newline$
$\tenv_3, []:\tenv_4 \Rightarrow \tenv_4'\mid \tau_4, l_2 l_1 \vdash E_3:\tau_3 \Rightarrow \tenv_3'\newline$
$\tenv_2, []:\tenv_3 \Rightarrow \tenv_3'\mid\tau_3, l_1 \vdash E_2:\tau_2 \Rightarrow \tenv_2'\newline$
$\tenv_1, []:\tenv_2 \Rightarrow \tenv_2'\mid\tau_2, \varepsilon \vdash E_1:\tau_1 \Rightarrow \tenv_1'\newline$

To have a better understanding, we can now assume a function $\funenv(f) = \langle x\COL\set{z\mid T}\TREF^1\rangle \ra \langle x\COL\set{z\mid z>0}\TREF^1\rangle$.
We give a varible $a$ to this function, it will have $a\COL\set{z\mid T}\TREF^1 \Rightarrow a\COL\set{z\mid z>0}\TREF^1 \LET y=f(a) \IN\dots$.
That is $\overrightarrow{E}\COL \LET y=[ ] \IN\dots, D(f)[a/x]$.





\section{TODO}

\begin{itemize}
\item Running example.
\item Context-Sensitiveness example. (Look at the JayHorn paper and Naoki's note.)
\item Some missing definitions, especially $\Gamma \models \varphi$.  (This can be done by reading previous work about refinement-type based static verification.  Ask Atsushi or Naoki which paper to look at.)
\item Soundness statement.
\item Extension to "general" references: e.g., $\set{r : \TINT \mid \varphi} \TREF^1 \TREF^1 \TREF^1$ or $\mu\alpha. \set{r : \TINT \mid \varphi} \TREF^1$.
\item Inference (constraint generation) algorithm.
\item Experiments?
\end{itemize}

\newcommand\EXTEND[1]{\{{#1}\}}


\begin{figure}
\[
  \begin{array}{rcl}
    [[ E ]] & ::= & [[ E'; e ]] \mid [[ [] ]] \\
    [[ CE ]] & ::= & [[ E[let y = [] l in e] ]]
  \end{array}
\]
\caption{Grammar of evaluation and return contexts}
\label{fig:eval-context-grammar}
\end{figure}


\begin{figure}
  \leavevmode
  \infrule[TE-Seq]{
    [[ Th | [] : T => G | B |-e E : T' => G' ]] \andalso
    [[ Th | G' | B |- e : T'' => G'' ]]
  }{
    [[ Th | [] : T => G | B |-e E; e : T'' => G'' ]]
  }
  \infrule[TE-Hole]{}{
    [[ Th | [] : T => G | B |-e [] : T => G ]]
  }
  \infrule[TE-Stack]{
    [[ Th | [] : T' => G' | B |-e E : T'' => G'']] \\
    [[ Th | G, x : T | B |- e : T' => G0 ]] \\
    [[ G' = G0 \ x ]] \andalso [[ B |- T' => G0 \ x ]]
  }{
    [[ Th | [] : T => G | B |-e E[let x = [] l in e] : T'' => G'' ]]
  }

  \begin{align*}
    [[ (E; e)[e'] ]] & = [[ E[e']; e ]] \\
    [[ [][e'] ]] & = e' \\
    [[ E[let y = [] l in e][x] ]] & = [[ E[let y = x in e] ]]
  \end{align*}
\caption{Context typing and substitution}
\label{fig:context-typing}
\end{figure}

\begin{figure}
  \leavevmode
  \infrule[]{
    [[ll = Trace(Es)]] \andalso [[ Th |- D ]] \andalso \forall j \in \set{0..n-1}.\seq{\ell_j} = tail^{n-j+1}([[ll]]) \\
    [[ Cons(H, R, G) ]] \andalso
    \forall i\in\set{1..n}.[[ Th | [] : Ti => Gi | lli-1 |-e Ei-1 : Ti-1 => Gi-1 ]] \\
    [[ Th | [] : T => G' | ll |-e En : Tn => Gn ]] \\
    [[ Th | G | ll |- e : T => G' ]]
  }{
    [[ |- D <H,R,Es,En[e]> ]]
  }

  \begin{align*}
    [[Trace(.) = .]] && [[Trace(E[let x = [] l in e] : Es) = l : Trace(Es)]])
  \end{align*}

  \begin{align*}
    [[Cons(H,R,G)]] = & [[SAT(H,R,G)]] \wedge [[forall a in H.F(a)]] \leq 1 \\
    [[SAT(H,R,G)]] = & [[ forall x in G.x in R /\ SATv(H,R,R(x),G(x)) ]] \\
    [[SATv(H,R,Rv,T)]] = & \begin{cases}
      [[Rv is INT /\ [R ; Rv / y]ph ]] & [[ T = {y:int|ph} ]] \\
      [[r > 0 ==> a in H /\ SATv(H,R,H(a),T')]] & [[ T = T' ref r /\ Rv = a ]]
    \end{cases} \\
    [[ [empty; v / x]ph ]] & = [[ [v/x]ph ]] \\
    [[ [R { y |-> nn }; v / x]ph ]] & =  [[ [nn/y] [R ; v / x]ph ]] \\
    [[ [R { y |-> a }; v / x]ph ]] & =  [[ [R ; v / x]ph ]] \\
    F = &  \Sigma_{[[ x in G ]]}\,[[own(H,R(x),G(x))]] \\
    [[own(H,v,T)]] &  = \begin{cases}
      [[ { a |-> r } + own(H,H(a),T') ]] & [[v = a /\ a in H /\ T = T' ref r ]] \\
      \emptyset & o.w.
    \end{cases} \\
  \end{align*}
\caption{Machine state typing}
\label{fig:state-typing}
\end{figure}

%edit by shiki
\begin{figure}[t]
  \leavevmode
  \infrule[R-Var]{
  }{
    [[ <H, R, CE : Es, x> --> D <H, R, Es, CE[x]> ]]
   }
   \infrule[R-Seq]{
   }{
     [[ <H, R, CE : Es, E[x; e]> --> D <H, R, Es, E[e]> ]]
  }
  \infrule[R-Let]{
    [[ x' fresh in R ]]
  }{
    [[<H, R, Es, E[let x = y in e]> --> D <H, R { x' |-> R(y)}, Es, E[ [x'/x]e]> ]]
  }
  \infrule[R-LetInt]{
    [[ x' fresh in R ]]
  }{
    [[ <H,R,Es,E[let x = nn in e]> --> D <H,R { x' |-> nn},Es, E[ [x'/x]e]>]]
  }
  \infrule[R-IfTrue]{
    [[ R(x) = 0 ]]
  }{
    [[ <H, R, Es, E[ifz x then e1 else e2]> --> D <H, R, Es, E[e1]> ]]
  }
  \infrule[R-IfFalse]{
    [[ R(x) != 0 ]]
  }{
    [[ <H, R, Es, E[ifz x then e1 else e2]> --> D <H, R, Es, E[e2]> ]]
  }
  \infrule[R-MkRef]{
    [[ a fresh in H ]] \andalso [[ x' fresh in R ]]
  }{
    [[ <H, R, Es, E[let x = mkref y in e]> --> D <H { a |-> R(y) }, R { x' |-> a }, Es, E[ [x'/x]e]> ]]
  }
  \infrule[R-Deref]{
    [[ R(y) = a ]] \andalso [[ H(a) = v ]] \andalso [[ x' fresh in R ]]
  }{
    [[ <H, R, Es, E[let x = *y in e]> --> D <H, R { x' |-> v }, Es, E[ [x'/x]e]> ]]
  }
  \infrule[R-Call]{
    [[ f |-> (x1,..,xn) e in D ]]
  }{
    [[ <H, R, Es, E[let x = f l (y1,,yn) in e']> --> D <H, R, E[let x = [] l in e'] : Es, [y1/x1] ,, [yn/xn] e> ]]
  }
  \infrule[R-Assign]{
    [[ R(x) = a ]] \andalso [[ a in H ]]
  }{
    [[ <H, R, Es, E[x:=y;e]> --> D <H { a <- R(y) }, R, Es, E[e]> ]]
  }
  \infrule[R-Alias]{
    R(x) = R(y)
  }{
    [[ <H, R, Es, E[alias(x = y); e]> --> D <H, R, Es, E[e]> ]]
  }
  \infrule[R-AliasFail]{
    [[R(x) != R(y)]]
  }{
    [[ <H, R, Es, E[alias(x = y); e]> --> D AliasFail ]]
  }
  \infrule[R-Assert]{
    [[ R |= ph ]]
  }{
    [[ <H, R, Es, E[assert(ph); e]> --> D <H, R, Es, E[e]> ]]
  }
  \infrule[R-AssertFail]{
    [[ R !|= ph ]]
  }{
    [[ <H, R, Es, E[assert(ph); e]> --> D AssertFail ]]
  }
\caption{Transition Rules.}
\label{fig:transitionRules}
\end{figure}



\bibliographystyle{plain}
\bibliography{main.bib}
\input{appendix}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
