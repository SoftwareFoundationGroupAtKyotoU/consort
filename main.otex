% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.20 of 2017/10/04
%
\documentclass[runningheads]{llncs}
%
\usepackage{bcprules}\typicallabel{T-Hoge}
\usepackage{bcpproof}
\usepackage{graphicx,color}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
% \renewcommand\UrlFont{\color{blue}\rmfamily}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{parcolumns}
\usepackage{cases}
\usepackage[capitalize,nameinlink,noabbrev]{cleveref}
\usepackage{listings}% http://ctan.org/pkg/listings
\lstset{
  basicstyle=\ttfamily,
  mathescape
}

\input{local}
% \input{../effgrad/def/ott/coe}
\input{./lang}


\newcommand{\AI}[1]{\textcolor{blue}{[AI: #1]\marginpar{$\longleftarrow$}}}

\begin{document}
%
\title{Context- and Flow-Sensitive Refinement Types for Imperative Programs}
%
%\titlerunning{Abbreviated paper title}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
\author{Ren Siqi \and Kohei Suenaga \and Atsushi Igarashi \and Naoki Kobayashi}
%
\authorrunning{Ren Siqi et al.}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{}
%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}

\keywords{}
\end{abstract}
%
%
%

\section{Simple setting without indirection of pointers and without subtyping}

\newcommand\val{v}

\subsection{Language}

\[
  \begin{array}{rcl}
  [[d]] &::=& [[f |-> (x1,...,xn)e ]] \\
  [[e]] &::= &
              [[ x ]] \mid
              [[ let x = y in e]] \mid
              \LET x = \val \IN \expr \mid
              \IFZERO x \THEN \expr_1 \ELSE \expr_2  \\ &\mid&
              \LET x = \MKREF y \IN \expr \mid
              \LET x = *y \IN \expr \mid
              \LET x = f^\ell(x_1,\dots,x_n) \IN \expr \\ &\mid&
              x \WRITE y \SEQ \expr \mid
              \ALIAS(x = y) \SEQ \expr \mid
              \ASSERT(\varphi) \SEQ \expr \mid \expr_1 \SEQ \expr_2 \\
    [[v]] &::=& [[nn]] \\
    [[P]] &::=& [[<{d1,...,dn}, e>]] \\
    [[l]] &\in& \textbf{Labels}\\
  \end{array}
\]

\(\varphi\) stands for a logical formula over integers and paths $\pps$).
We assume a set of \emph{variables}, which is ranged over by $x,y,z,\dots$, and a set of \emph{locations}, which is ranged over by $a,b,c,\dots$.

\subsection{Type system}
\begin{definition}
  Context strings $[[B]]$ are defined as follows:
  \[
    \begin{array}{rcl}
      [[ B ]] & ::= & [[ . ]] \mid [[ l ]] : [[ B ]] \mid [[A]]
    \end{array}
  \]
  $[[A]]$ is a context string variable. Let $[[CV(B)]]$ be $\set{[[A]]}$ for
  context strings whose final element is $[[A]]$ and $\emptyset$ otherwise.
\end{definition}

\begin{definition}
  $\sem{[[T]]}_y$ is defined as follows:
  \[
    \begin{array}{rcl}
      \sem{[[{x:int | ph}]]}_y &=& [[ [y/x]ph ]]\\
      \sem{[[{x:int | ph} ref r]]} &=& [[ Top ]]
    \end{array}
  \]
\end{definition}

\begin{definition}
  The refinement predicates $[[ph]]$ are defined as follows:
  \[
    \begin{array}{rcl}
      [[ph]] & ::= & [[ph1 ==> ph2]] \mid
                     [[ ph1 /\ ph2 ]] \mid
                     [[ pfun(x1,..,xn) ]] \mid
                     [[ lvar = V' ]] \mid [[ lvar != V' ]] \\
             & \mid & [[ B1 = B2? ]] \\
      [[ V ]] & ::= & [[ x ]] \mid [[ v ]]
    \end{array}
  \]
  $[[pfun]]$ is a predicate symbol with an interpretation in the
  theory used by the underlying solver. The predicate $[[ B1 = B2? ]]$ is a prefix
  query which checks whether $[[B2]]$ is a prefix of $[[B1]]$. We write $[[FPV(ph)]]$ for
  the free variables occuring in $[[ph]]$, and write $[[FPCV(ph)]]$ for the free context
  variables that appear in $[[ph]]$.
  Formally, $\mathbf{FPV}$ is defined as
  \begin{align*}
    [[FPV(ph1 /\ ph2)]] & = [[FPV(ph1)]] \cup [[FPV(ph2)]] \\
    [[FPV(ph1 ==> ph2)]] & = [[FPV(ph1)]] \cup [[FPV(ph2)]] \\
    [[FPV(pfun(x1,..,xn))]] & = \set{[[x1]],\ldots,[[xn]]} \\
    [[FPV(B1 = B2?)]] & = \emptyset \\\
    [[FPV(lvar = V')]] & = \begin{cases}
      \emptyset & [[lvar]] \equiv  [[v]] \\
      \set{x} & [[lvar]] \equiv [[x]]
    \end{cases} \cup \begin{cases}
      \emptyset & [[V']] \equiv  [[v]] \\
      \set{x} & [[V']] \equiv [[x]]
    \end{cases} \\\
    [[FPV(lvar != V')]] & = [[FPV(lvar = V')]]
  \end{align*}
  Through abuse of notation we will also write $[[FPV(T)]]$ to indicate the free variables
  in the refinement of $[[T]]$, i.e.:
  \begin{align*}
    [[FPV(T' ref r)]] & = [[FPV(T')]] \\
    [[FPV({x:int|ph})]] & = [[FPV(ph)]] \setminus \set{[[x]]}
  \end{align*}
  and $[[FPCV(T)]]$ to indicate free variables that appear in the refinement of $[[T]]$.
\end{definition}

\begin{figure}[t]
  \leavevmode
  \infrule[WF-Env]{
    [[ forall x in G. G | B |- G(x) ]]
  }{
    [[B |- G]]
  }
  \infrule[WF-Int]{
    [[ST(G), x:int | B |- ph]]
  }{
    [[G | B |- { x:int|ph} ]]
  }
  \infrule[WF-Ref]{
    [[G | B |- T]]
  }{
    [[G | B |- T ref r ]]
  }
  \infrule[WF-Phi]{
    [[FPV(ph)]] \subseteq \set{x \mid [[x in Gst /\ Gst(x) = int]]} \andalso
    [[FPCV(ph)]] \subseteq [[CV(B)]]
  }{
    [[Gst | B |- ph]]
  }
  \infrule[WF-Result]{
    [[G | B |- T]] \andalso
    [[B |- G]]
  }{
    [[ B |- T => G ]]
  }
  \infrule[WF-FunType]{
    [[ A |- x1:T1,,xn:Tn ]] \\ [[ A |- T => x1:T1',,xn:Tn' ]]
  }{
    [[ |- A <x1:T1,,xn:Tn> -> <x1:T1',,xn:Tn'|T> ]]
  }
  \infrule[WF-FunEnv]{
    [[ forall f in Th.|- Th(f)]]
  }{
    [[ |- Th ]]
  }
  \caption{Well-formedness of types and environments}
  \label{fig:type-wf}
\end{figure}

\begin{definition}[Well-formedness of types]
  We define simple types $[[ST]]$ and environments $[[Gst]]$ by:
  \[
    \begin{array}{rcl}
      [[ST]] & ::= & [[int]] \mid [[ int ref ]]  \\
      [[Gst]] & ::= & [[empty]] \mid [[Gst,x:ST]]
    \end{array}
  \]
  Let $[[ST(G)]]$ be the obvious transformation of $[[G]]$ into $[[Gst]]$.
  The well-typedness of types and type environments are shown in \cref{fig:type-wf}.
\end{definition}

\begin{definition}
  $\sem{[[G]]}$ is defined as follows:
  \[
    \begin{array}{rcl}
      \sem{[[empty]]} &=& [[ Top ]]\\
      [[G,x: T]] &=& \sem{[[G]]} \land \sem{[[T]]}_x \\
    \end{array}
  \]
\end{definition}

\begin{definition}
  We write $\Gamma \models \varphi$ if $\models \sem{\Gamma} \implies \varphi$ is valid.
\end{definition}

\paragraph{Operations on types.}

\begin{figure}[t]
  \leavevmode
  \infax[Tadd-Int]{
    [[{x:int|ph1} + {x:int|ph2} = {x:int|ph1 /\ ph2}]]
  }
  \infrule[Tadd-Ref1]{
    [[r1]] \ne 0 \andalso
    [[r2]] \ne 0
  }{
    [[T1 ref r1 + T2 ref r2 = (T1 + T2) ref r1 + r2]]
  }
  \infrule[Tadd-Ref2]{
    [[r]] > 0
  }{
    [[ T1 ref 0 + T2 ref r = T2 ref r]]
  }
  \infax[Tadd-Ref3]{
    [[T1 ref 0 + T2 ref 0 = { x: int | Top } ref 0]]
  }
  \caption{Rules for $\typ_1 \addt \typ_2$.}
  \label{fig:addition}
\end{figure}

\begin{figure}
  \leavevmode
  \infrule[TEq-Ref]{
    [[T1 ~ T2]] \andalso [[r1]] = [[r2]]
  }{
    [[T1 ref r1 ~ T2 ref r2]]
  }

  \infrule[TEq-Int]{
    [[|= ph1 <=> ph2]]
  }{
    [[ {x:int | ph1} ~ {y:int | ph2} ]]
  }
  \caption{Rules for type equality}
  \label{fig:equality}
\end{figure}

\begin{definition}
  $[[ T1 + T2 ]]$ is the least commutative partial operation that satisfies the rules in Figure~\ref{fig:addition}.
  \AI{Rules for unit and int types.}
\end{definition}

\begin{definition}
  We define equalilty modulo logical
  equivalence (or just ``equality'') between two types, written as $[[ T1 ~ T2 ]]$,
  as the least binary relation closed under the rules shown \cref{fig:equality}.
\end{definition}


\begin{definition}
  The typed equality proposition $[[ x = T y ]]$ is defined as
  \[
    [[ x = T y ]] \equiv \begin{cases}
      [[ x = y ]] & [[ T = {z:int|ph} ]] \\
      [[ Top ]] & o.w.
      \end{cases}
  \]
\end{definition}
\begin{definition}
  $[[T /\ y ph]]$ is the strengthening operation defined as:
  \[
    [[ T /\ y ph' ]] = \begin{cases}
      [[ { z: int | [z/x]ph /\ [z/y]ph' }]] & [[ T = { x: int | ph } /\ z not in FPV(ph') /\ z not in FPV(ph) ]] \\
      [[ T ]] & o.w.
    \end{cases}
  \]
\end{definition}

\begin{definition}{Context Substitution}
  Define context substitution operation $[[ [B/A] ]]$ over predicates $[[ph]]$, types $[[T]]$, and type environments $[[G]]$, as:

  \begin{align*}
    [[ [B/A](ph1 /\ ph2) ]] & = [[ [B/A]ph1 /\ [B/A]ph2 ]] \\
    [[ [B/A](ph1 ==> ph2) ]] & = [[ [B/A]ph1 ==> [B/A]ph2 ]] \\
    [[ [B/A]pfun(x1,..,xn) ]] & = [[ pfun(x1,..,xn) ]] \\
    [[ [B/A](lvar = V') ]] & = [[ lvar = V' ]] \\
    [[ [B/A](lvar != V') ]] & = [[ lvar != V' ]] \\
    [[ [B/A](B' = B''?) ]] & = [[ [B/A]B' = [B/A]B''? ]] \\
    [[ [B/A](T ref r) ]] & = [[([B/A] T) ref r]] \\
    [[ [B/A]{x:int|ph} ]] & = [[{x:int|[B/A]ph}]] \\
    [[ [B/A](G,x: T) ]] & = [[ ([B/A]G), x : [B/A]T ]] \\
    [[ [B/A]empty ]] & = [[ empty ]] \\
  \end{align*}
\end{definition}

\paragraph{Subtyping.}

\begin{figure}[t]
\leavevmode
\infrule[Sub-Int]{
  [[G |= ph1 ==> ph2]]
  }{
   [[G |- {x:int|ph1} <: {y:int|ph2}]]
  }
  \infrule[Sub-Ref]{
    [[r1 >= r2]]
    \andalso
    [[r2 > 0 ==> G |- T1 <: T2 ]]
  }{
    [[ G |- T1 ref r1 <: T2 ref r2 ]]
  }
  \infrule[Sub-TyEnv]{
    [[ forall x in G'.G|- G(x) <: G'(x) ]]
  }{
    [[ G <: G' ]]
  }
  \caption{Rules for subtyping.}
  \label{fig:subtyping}
\end{figure}

\paragraph{Type judgment.}

\AI{\rn{T-Let} loses information that $x$ is equal to $y$ (unlike \rn{T-LetInt}).}

\begin{figure}[t]
  \leavevmode
  \infrule[T-Var]{
  }{
    [[ Th | G [ x : T1 + T2] | B |- x : T1 => G[ x <- T2 ] ]]
  }
  \infrule[T-Let]{
    [[ Th | G [ y <- T1 /\ y y = T1 x  ], x : (T2 /\ x x = T2 y) | B |- e : T => G']] \andalso
    [[B |- T => G' \ x]]
  }{
    [[ Th | G[y: T1 + T2] | B |- let x = y in e : T => G' \ x]]
  }
  \infrule[T-LetInt]{
    [[ Th | G, x:{x : int | x = nn } | B |- e : T => G']] \andalso
    [[B |- T => G' \ x]]
  }{
    [[ Th | G | B |- e : T => G' \ x]]
  }
  \infrule[T-If]{
    [[ Th | G[x <- {y:int | ph /\ y = 0 }] | B |- e1 : T => G' ]] \\
    [[ Th | G[x <- {y:int | ph /\ y != 0}] | B |- e2 : T => G' ]]
  }{
    [[ Th | G[x : {y:int|ph}] | B |- ifz y then e1 else e2 : T => G' ]]
  }
  \infrule[T-MkRef]{
    [[ Th | G[y <- T1],x : (T2 /\ x x = T2 y) ref 1 | B |- e : T => G']] \andalso
    [[ B |- T => G' \ x ]]
  }{
    [[ Th | G[y : T1 + T2] | B |- let x = mkref y in e : T => G' \ x ]]
  }
  \infrule[T-Deref]{
    [[r > 0]] \andalso
    [[ Th | G[y <- (T1 /\ y y = T1 x) ref r], x : T2 | B |- e : T => G']] \andalso
    [[ B |- T => G' \ x ]]
  }{
    [[ Th | G[y: (T1 + T2) ref r] | B |- let x = *y in e : T => G' \ x ]]
  }
  \infrule[T-Call]{
    [[ Th(f) = A < x1 : T1 ,, xn : Tn > -> <x1: T1' ,, xn : Tn' | T > ]] \\
    [[csub = [l:B/A] ]] \andalso [[ vsub = [y1/x1] ,, [yn/xn] ]] \\
    [[ Th | G[yi <- csub vsub Ti'], x : csub vsub T | B |- e : T' => G' ]] \\
    [[ B |- T' => G' \ x]]
  }{
    [[ Th | G[yi: csub vsub Ti] | B |- let x = f l (y1,,yn) in e : T' => G' \ x]]
  }
  \infrule[T-Assign]{
    (\text{The shapes of $[[T']]$ and $[[T2]]$ are similar}) \\
    [[ Th | G[x <- T1][y <- T2 /\ y y = T2 x ref r] | B |- e : T => G']] \\
  }{
    [[ Th | G[x: T1 + T2][y : T' ref 1] | B |- y := x; e : T => G']]
  }
  \infrule[T-Alias]{
    [[(T1 ref r1 + T2 ref r2) ~ (T1' ref r1' + T2' ref r2')]] \\
    [[ Th | G[x <- T1' ref r1'][y <- T2' ref r2'] | B |- e : T => G']]
  }{
    [[ Th | G[x : T1 ref r1][y: T2 ref r2] | B |- alias(x = y); e : T => G' ]]
  }
  \infrule[T-Seq]{
    [[ Th | G | B |- e1 : T' => G' ]] \andalso
    [[ Th | G' | B |- e2 : T'' => G'' ]]
  }{
    [[ Th | G | B |- e1 ; e2 : T'' => G'' ]]
  }
  \infrule[T-Assert]{
    [[ G |= ph ]] \andalso
    [[ Th | G | B |- e : T => G' ]]
  }{
    [[ Th | G | B |- assert(ph); e : T => G']]
  }
  \infrule[T-Sub]{
    [[ G <: G' ]] \andalso
    [[ Th | G' | B |- e : T => G'' ]] \andalso
    [[ x not in G ]] \andalso
    [[ G'', x:T <: G''',x:T' ]]
  }{
    [[ Th | G | B |- e : T' => G''' ]]
  }
  \caption{Expression typing rules.}
  \label{fig:typingRules}
\end{figure}
\begin{figure}
  \infrule[T-FunDef]{
    [[ Th (f) = A <x1 : T1 ,, xn : Tn > -> < x1: T1' ,, xn : Tn' | T> ]] \\
    [[ Th | x1:T1 ,, xn:Tn | A |- e : T => x1: T1' ,, xn : Tn' ]]
  }{
    [[ Th |- f |-> (x1,..,xn) e ]]
  }
  \infrule[T-Funs]{
    \forall [[f |-> (x1, .., xn) e in D]].[[ Th |- f |-> (x1,..,xn) e ]]
  }{
    [[ Th |-  D ]]
  }
  \infrule[T-Prog]{
    [[ Th |- D ]] \andalso
    [[ Th | empty | . |- e : T => G ]]
  }{
    [[ |- < D, e > ]]
  }
\caption{Program typing rules}
\label{fig:progTyping}
\end{figure}

\AI{\rn{T-Let} discards all the refinement on \(x\).  Probably we should propagate it to $\tenv'$.}

\AI{\rn{T-Let} and \rn{T-LetInt} can be merged.}

\AI{\rn{T-Call} requires actual arguments to be variables introduced at the end of the type environment.  This is not a restriction because one can introduce let-expressions before a function call and alias-expressions after the call.}

\AI{$\varepsilon$ in \rn{T-Prog} stands for the empty string.}

In \cref{fig:typingRules} $[[ G[x: T] ]]$ denotes an environment
$[[G]]$ such that $[[G(x) = T]]$. $[[ G[x <- T] ]]$ denotes the functional update of the type
of $[[x]]$ to $[[T]]$ in $[[G]]$.

%edit by shiki
\subsection{Transition rules}
For each language expression occurs, we accomplish writing the rules for transition. In order to deal with function, we introduce the stack in the system. Here, $\langle H, R,\overrightarrow{E}, E \rangle$ represent heap(memory),
register(environment), a sequence of return contexts, program respectively.
It's obvious when $e$ is an integer $n$, when it's a variable $x$, in order to better handle with recursive types,
we refresh every variable $x$ to $x'$ after executing expression.
Define a named local expression $\LET x=y \IN e$, which $x$ can then be used later on in the function instead of $y$, so that the
register of $x$ update to the $R(y)$.
The expression $x:=y$ only update the register of $x$ to $y$.
The same changes happen when $\LET x=n \IN e$, the only difference is that now we use an integer instead of a variable.
It becomes a little bit complex when dealing with reference, in transition rule for $\LET x=*y \IN e$, we update the register of $x$ to $H(R(y))$,
which means the memory address of the variable $y$.
If you want to $\MKREF$, first it should satisfies that the variable $y$ doesn't used in memory before, after executing, heap
turns to $H(y\ra v)$, here $v$ represents a new memory cell.
We divide the expression $\IFZERO x\THEN e_1 \ELSE e_2$ into two parts, $e_1$ will be given if $x\ra 0$ in the initial register,
otherwise we will get $e_2$.
When handling with $\ALIAS$ and $\ASSERT$, we introduce $\bf{AliasFail}$ and $\bf{AssertFail}$ to the rules. They will be thrown if the memory cell or
the environment can't hold for some states.
The expression about function definition, we replace it by the function body itself and we also need to remember to bind $x$ to
the result of $[\tilde{y}/\tilde{x}]e'$ and then calculate $e$, which is written by $\LET x=[] \IN e$.

In the rules $\rn{R-Assert}$ we write $[[R |= ph]]$ to mean that for
any model $[[M]]$ in our underlying theory such that
$[[ forall x in R.M(x) = R(x) ]]$ $[[ M |= ph ]]$ holds.

\begin{figure}
\[
  \begin{array}{rcl}
    [[ E ]] & ::= & [[ E'; e ]] \mid [[ [] ]] \\
    [[ CE ]] & ::= & [[ E[let y = [] l in e] ]]
  \end{array}
\]
\label{fig:eval-context-grammar}
\caption{Grammar of evaluation and return contexts}
\end{figure}

\subsection{Examples}
For examples, consider the following programs, written in an ML-like language.
The righthand side shows the types assigned to each variable before execution of
each line.
\begin{parcolumns}{2}
\colchunk[1]{%
\begin{verbatim}
[1]
  let x = mkref 1 in
  let y = *x in
    assert(y>0)
\end{verbatim}
}
\colchunk[2]{%
\newline
\newline
  $\emptyset$ \newline
  $x \COL \set{r \COL \TINT \mid r = 1} \TREF^1$ \newline
  $x \COL \set{r \COL \TINT \mid r = 1} \TREF^1, y \COL \set{r \COL \TINT \mid r = 1}$ \newline
}
\colplacechunks
\end{parcolumns}

\begin{parcolumns}{2}
\colchunk[1]{%
\begin{verbatim}
[2]
  let x = mkref 1 in
  let y = *x in
    assert(y<0)
\end{verbatim}
}
\colchunk[2]{%
\newline
\newline
  $\emptyset$ \newline
  $x \COL \set{r \COL \TINT \mid r = 1} \TREF^1$ \newline
  $x \COL \set{r \COL \TINT \mid r = 1} \TREF^1, y \COL \set{r \COL \TINT \mid r = 1}$ \newline
}
\colplacechunks
\end{parcolumns}

In example[1] and example[2], from typing rule for T-MkRef, the ownership for varible $x$ will be 1.
As for dereference, $y$ will hold the same value as $x$.The only difference in the programs is the
assert statements, from the types of varible $y$, it's clear that the example[1] will return true,
and the example[2] will be false, since $y \COL \set{r \COL \TINT \mid r = 1} \models y > 0$.

\begin{parcolumns}{2}
\colchunk[1]{%
\begin{verbatim}
[3]
  let x = mkref 1 in
  let y = x in
  let z = *y in
    assert(z>0)
\end{verbatim}
}
\colchunk[2]{%
\newline
\newline
  $\emptyset$ \newline
  $x \COL \set{r \COL \TINT \mid r = 1} \TREF^1$ \newline
  $x \COL \set{r \COL \TINT \mid r = 1} \TREF^0, y \COL \set{r \COL \TINT \mid r = 1} \TREF^1$ \newline
  $x \COL \set{r \COL \TINT \mid r = 1} \TREF^0, y \COL \set{r \COL \TINT \mid r = 1} \TREF^1, z \COL \set{r \COL \TINT \mid r = 1}$ \newline
}
\colplacechunks
\end{parcolumns}

In example[3], from T-Let $x$ will transfer the ownership of the reference cell to $y$, so that the
owership of $y$ will be 1 and then can be dereferenced to $z$ with the return value, the result of
the assertion is true, since $z \COL \set{r \COL \TINT \mid r = 1} \models z>0$

\begin{parcolumns}{2}
\colchunk[1]{%
\begin{verbatim}
[4]
  let x = mkref 1 in
  let y = x in
    y := -1;
    let z = *y in
      assert(z>0)
\end{verbatim}
}
\colchunk[2]{%
\newline
\newline
  $\emptyset$ \newline
  $x \COL \set{r \COL \TINT \mid r = 1} \TREF^1$ \newline
  $x \COL \set{r \COL \TINT \mid r = 1} \TREF^0, y \COL \set{r \COL \TINT \mid r = 1} \TREF^1$ \newline
  $x \COL \set{r \COL \TINT \mid r = 1} \TREF^0, y \COL \set{r \COL \TINT \mid r = -1} \TREF^1$ \newline
  $x \COL \set{r \COL \TINT \mid r = 1} \TREF^0,y \COL \set{r \COL \TINT \mid r = -1} \TREF^1, z \COL \set{r \COL \TINT \mid r = -1}$ \newline
}
\colplacechunks
\end{parcolumns}

In example[4], it contains update the value of $y$ to $-1$. From T-Assign it only changes the value of $y$.
And the result should be false obviously, because $z \COL \set{r \COL \TINT \mid r = -1} \not\models z>0$.
The refinement type $\set{r \COL \TINT \mid r = 1}$ of $x$ after the command $y := -1$ does not reflect the actual value of $*x$.
This is OK in our type system because the ownership of the reference $x$ is $0$; the refinement attached to this reference type is not reliable.

\begin{parcolumns}{2}
\colchunk[1]{%
\begin{lstlisting}
[5]
  let x = mkref 1 in
  let y = x in
  let $z_1$ = *y in
  let $z_2$ = *x in
    assert($z_1$>0 && $z_2$>0)
\end{lstlisting}
}
\colchunk[2]{%
\newline
\newline
  $\emptyset$ \newline
  $x \COL \set{r \COL \TINT \mid r = 1} \TREF^1$ \newline
  $x \COL \set{r \COL \TINT \mid r = 1} \TREF^{0.5}, y \COL \set{r \COL \TINT \mid r = 1} \TREF^{0.5}$ \newline
  $x \COL \set{r \COL \TINT \mid r = 1} \TREF^{0.5},y \COL \set{r \COL \TINT \mid r = 1} \TREF^{0.5}, z_1 \COL \set{r \COL \TINT \mid r = 1}$ \newline
  $x \COL \set{r \COL \TINT \mid r = 1} \TREF^{0.5},y \COL \set{r \COL \TINT \mid r = 1} \TREF^{0.5},z_1 \COL \set{r \COL \TINT \mid r = 1},z_2 \COL \set{r \COL \TINT \mid r = 1}$ \newline
}
\colplacechunks
\end{parcolumns}

In example[5], dereferencing doesn't change the ownership of each variable, and the result
of assertion is true, because $z_1 \COL \set{r \COL \TINT \mid r = 1},z_2 \COL \set{r \COL \TINT \mid r = 1}\models z_1, z_2>0$.

\begin{parcolumns}{2}
\colchunk[1]{%
\begin{lstlisting}
[6]
  let x = mkref 1 in
  let y = x in
  let $z_1$ = *y in
  let $z_2$ = *x in
    x := 0;
    let $z_3$ = *x in
      assert($z_3$=0)

\end{lstlisting}
}
\colchunk[2]{%
\newline
\newline
  $\emptyset$ \newline
  $x \COL \set{r \COL \TINT \mid r = 1} \TREF^{1}$ \newline
  $x \COL \set{r \COL \TINT \mid r = 1} \TREF^{r_1}, y \COL \set{r \COL \TINT \mid r = 1} \TREF^{1-r_1} \mbox{where $1 > r_1 > 0$}$ \newline
  $z_1 \COL \set{r \COL \TINT \mid r = 1}$ \newline
  $z_2 \COL \set{r \COL \TINT \mid r = 1}, r_1 = 1 \mbox{ which contradicts to $1 > r_1 > 0$}$ \newline
  safe but cannot be typed
}
\colplacechunks
\end{parcolumns}

In example[6], after dereferencing $x$ to $z_2$ the ownership of $x$ will become 0, which means that
it can't be updated in our type system. But we can add statement \textbf{alias}(x=y)
to shuffle the ownerships between $x$ and $y$, then the program will be typable as belows. And the assert
statement will give true result, since $z_3 \COL \set{r \COL \TINT \mid r = 0}\models z_3 = 0$.

\begin{parcolumns}{2}
\colchunk[1]{%
\begin{lstlisting}
[6 typable]
  let x = mkref 1 in
  let y = x in
  let $z_1$ = *y in
  let $z_2$ = *x in
    alias(x=y)
    x := 0;
    let $z_3$ = *x in
      assert($z_3$=0)
\end{lstlisting}
}
\colchunk[2]{%
\newline
\newline
  $\emptyset$ \newline
  $x \COL \set{r \COL \TINT \mid r = 1} \TREF^1$ \newline
  $x \COL \set{r \COL \TINT \mid r = 1} \TREF^{0.5}, y \COL \set{r \COL \TINT \mid r = 1} \TREF^{0.5}$ \newline
  $x \COL \set{r \COL \TINT \mid r = 1} \TREF^{0.5},y \COL \set{r \COL \TINT \mid r = 1} \TREF^{0.5}, \dots$ \newline
  $x \COL \set{r \COL \TINT \mid r = 1} \TREF^{0.5}, y \COL \set{r \COL \TINT \mid r = 1} \TREF^{0.5}, \dots$ \newline
  $x \COL \set{r \COL \TINT \mid r = 1} \TREF^{1}, y \COL \set{r \COL \TINT \mid r = 1} \TREF^{0},\dots$ \newline
  $x \COL \set{r \COL \TINT \mid r = 0} \TREF^1, y \COL \set{r \COL \TINT \mid r = 1}\TREF^{0},\dots$ \newline
  $x \COL \set{r \COL \TINT \mid r = 0} \TREF^1, y \COL \set{r \COL \TINT \mid r = 1}\TREF^{0},z_3 \COL \set{r \COL \TINT \mid r = 0}$ \newline
}
\colplacechunks
\end{parcolumns}

In order to derive example for Context-Sensitiveness, we first focus on examples for function. Here are examples for “push/pull” instructions.
We can see that function $\bf{push}$ is just assign an integer $x$ to variable $p$. $\bf{pull}$ is to pop the integer stored in $p$. Here we write
$\sigma \COL\COL= \forall \beta.<\dots>\ra <\dots\mid\tau>$ to contain the return values.

\begin{parcolumns}{2}
\colchunk[1]{%
\begin{verbatim}
[7 push]
  def push(p, x) =
    p := x;
\end{verbatim}
}
\colchunk[2]{%
\newline
\newline
  $\bf{push} \COL \newline
  \forall \beta. p\COL \set{n \COL \TINT \mid T}\TREF^1, x\COL \set{n \COL \TINT \mid \frac{(\beta[0]=l_1\Rightarrow n=0)\land}{(\beta[0]\neq l_1\Rightarrow n>0))}} \ra \newline
  p\COL \set{n \COL \TINT \mid n=x_{pre}}\TREF^1, x\COL \set{n \COL \TINT \mid x_{pre}=x}$ \newline
}
\colplacechunks
\end{parcolumns}

\begin{parcolumns}{2}
\colchunk[1]{%
\begin{verbatim}
[8 pull]
  def pull(p) =
    *p;
\end{verbatim}
}
\colchunk[2]{%
\newline
\newline
  $\bf{pull} \COL \newline
  \forall \beta. p\COL \set{n \COL \TINT \mid \frac{(\beta[0]=l_6\Rightarrow n>0)\land}{(\beta[0]\neq l_6\Rightarrow n\geq 0))}}\TREF^1\ra \newline
  p\COL \set{n \COL \TINT \mid p_{pre}=p}\TREF^1\mid \set{n \COL \TINT \mid \frac{(\beta[0]=l_6\Rightarrow n>0)\land}{(\beta[0]\neq l_6\Rightarrow n\geq 0))}}$ \newline
}
\colplacechunks
\end{parcolumns}


After writing the types changing for each function, now we can take an example for explaining context-sensitiveness of our type-system.
In the example[9], using the types changes in the above, we can write the types before executing for each statement.
For every function $\bf{push/pull}$, we also give labels $l_1,\dots,l_6$ to distinguish the context-flow.
It's obvious that the result of assertion should be true, since $x \COL \set{n \COL \TINT \mid n > 0}\models x > 0$.

\begin{parcolumns}{2}
\colchunk[1]{%
\begin{lstlisting}
[9 Context-Sensitiveness]
let p = mkref _ in
let x = mkref _ in
  push$^{l_1}$(p, 0)
  if b then
    x := pull$^{l_2}$(p)
    push$^{l_3}$(p, *x+1)
  else
    x := pull$^{l_4}$(p)
    push$^{l_5}$(p, *x+2)
  x := pull$^{l_6}$(p)
  assert(*x > 0)
\end{lstlisting}
}
\colchunk[2]{%
\newline
\newline
\newline
\newline
  $p\COL \set{n \COL \TINT \mid T}\TREF^1, x\COL \set{n \COL \TINT \mid T}\TREF^1$ \newline
  $p\COL \set{n \COL \TINT \mid n=0}\TREF^1, x\COL \set{n \COL \TINT \mid T}\TREF^1$ \newline\newline
  $p\COL \set{n \COL \TINT \mid n=0}\TREF^1, x\COL \set{n \COL \TINT \mid n\geq 0}\TREF^1$ \newline
  $p\COL \set{n \COL \TINT \mid n>0}\TREF^1, x\COL \set{n \COL \TINT \mid n\geq 0}\TREF^1$ \newline
  $p\COL \set{n \COL \TINT \mid n=0}\TREF^1, x\COL \set{n \COL \TINT \mid T}\TREF^1$ \newline
  $p\COL \set{n \COL \TINT \mid n=0}\TREF^1, x\COL \set{n \COL \TINT \mid n\geq 0}\TREF^1$ \newline
  $p\COL \set{n \COL \TINT \mid n>0}\TREF^1, x\COL \set{n \COL \TINT \mid n\geq 0}\TREF^1$ \newline
  $p\COL \set{n \COL \TINT \mid n>0}\TREF^1, x\COL \set{n \COL \TINT \mid n>0}\TREF^1$ \newline

}
\colplacechunks
\end{parcolumns}

\paragraph{2-CFA Call Sensitivity}

Consider the following program:
\begin{lstlisting}
f(x, b):
  if b then
    f$^{\ell_3}$(x + 1, false)
  else
    g$^{\ell_4}$(x)
g(x): x + 1

let $r_1$ = f$^{\ell_1}$(0, true) in
let $r_2$ = g$^{\ell_2}$(0) in
assert ($r_1 + r_2 \geq 3$);
\end{lstlisting}

This program is clearly correct, as \lstinline{f} will recurse exactly once before execution
flows through to the else branch and the call to \lstinline{g}.

The type system can verify this example if we give f and g the following types:
\begin{align*}
  f: \forall \alpha.\langle&x: \{ n : int \mid (\alpha = \ell_3? \produces n \geq 1) \wedge n \geq 0 \} \\
                           &b: \{ n: bool \mid (\alpha = \ell_3? \produces n = 0) \wedge (\alpha \neq \ell_3? \produces n = 1) \}\rangle \\
                           & \ra \{ n : int \mid n > 1 \} \\
  g: \forall \beta.\langle&x: \{ n : int \mid (\beta = \ell_4\ell_3? \produces n \geq 1) \wedge n \geq 0 \}\rangle \\
                           & \ra \{ n: int \mid n = n_{pre} + 1\}
\end{align*}
(Here we abbreviate $\tuple{x_1:\typ_1,\ldots,x_n:\typ_n} \ra \tuple{x_1:\typ_1,\ldots,x_n:\typ_n\mid \typ}$ as $\tuple{x_1:\typ_1,\ldots,x_n:\typ_n} \ra \typ$ when the types of the arguments
do not change.)

The key step in the typing derivation is at the call to g within the body of $f$. We reach the
call in the type environment:

\begin{align*}
  x: & \{ n : int \mid (\alpha = \ell_3? \produces n \geq 1) \wedge n \geq 0 \} \\
  b: & \{ n: bool \mid (\alpha = \ell_3? \produces n = 0) \wedge (\alpha \neq \ell_3? \produces n = 1) \wedge n = 0 \}
\end{align*}
Notice that we have propagated the path condition induced by the if
statement to the type of $b$.

We then apply the rule T-Call. Performing substitution on the path variable in the type
of g indicates that the argument $x$ must have type:

\[
  [\ell_4\alpha/\beta]\{ n : int \mid (\beta = \ell_4\ell_3? \produces n \geq 1) \wedge n \geq 0 \} = \{ n : int \mid (\ell_4\alpha = \ell_4\ell_3?)\} \produces n \geq 1) \wedge n \geq 0 \}
\]

$x$ indeed has this type. Simplifying the result type of $g$ we have that the overall expression has type:

\[
  \{ n : int \mid (\alpha = \ell_3? \produces n \geq 2) \wedge n \geq 1 \}
\]

It remains to verify that this type satisfies the result type of $f$, i.e.,
$\{ n : int \mid n > 1 \}$. Applying the rule T-Sub, it suffices to
show that:

\begin{align*}
  \models \big( & (\alpha = \ell_3? \produces b = 0) \wedge (\alpha \neq \ell_3? \produces b = 1) \wedge b = 0\big) \produces \\
  & \big((\alpha  = \ell_3? \produces n \geq 2) \wedge n \geq 1\big) \produces n > 1
\end{align*}

In the above, we have omitted the constraint generated from the type of $x$ in the environment
as it is irrelevant. The automated theorem prover Z3 discharges the above implication,
indicating the above subtyping relationship is valid.

It is instructive to also consider the typing of the recursive call in
the true branch of $f$'s body. Per the rule T-Call, substituting
$\ell_3\alpha$ for $\alpha$ in the argument types of $f$ indicates that
\lstinline{x + 1} must have type:
\[
  \{ n : int \mid (\ell_3\alpha = \ell_3? \produces n \geq 1) \wedge n \geq 0 \}
\]
and \lstinline{false} (i.e., \lstinline{0}) must have type:
\[
  \{ n : bool | (\ell_3\alpha = \ell_3? \produces n = 0) \wedge (\ell_3\alpha \neq \ell_3? \produces n = 1) \}
\]
The latter type simplifies to $\{ n : bool \mid n = 0 \}$ which the constant \lstinline{0} has
(tehnically an application of the subtyping rule is required, but it is straightforward).
We must also verify that:
\[
  \tenv \p \{ n : int \mid (\alpha = \ell_3? \produces n \geq 2) \wedge n \geq 1 \} \subt \{ n : int \mid (\ell_3\alpha = \ell_3? \produces n \geq 1) \wedge n \geq 0 \}
\]
It is easy to verify this relationship holds.

\paragraph{\large{\bf{example to explain context stack in the type system}}}
$\newline$

Suppose $\langle H, R,\overrightarrow{E}, l_4 \rangle$ represent heap(memory), register(environment), a sequence of context, program respectively.
Here, $\overrightarrow{E} = E_3:E_2:E_1$, which $E_3$ is the newest context and $E_1$ is the oldest one.
The context flow will go as belows, and $l_3$ is the newest program to call and $l_1$ is obvious the oldest one.
It needs to satisfy the condition $\cup_i \textit{dom}(\tenv_i)= \textit{dom}(R)$.

$\newline\tenv_4, l_3 l_2 l_1 \vdash l_4:\tau_4 \Rightarrow \tenv_4'\newline$
$\tenv_3, []:\tenv_4 \Rightarrow \tenv_4'\mid \tau_4, l_2 l_1 \vdash E_3:\tau_3 \Rightarrow \tenv_3'\newline$
$\tenv_2, []:\tenv_3 \Rightarrow \tenv_3'\mid\tau_3, l_1 \vdash E_2:\tau_2 \Rightarrow \tenv_2'\newline$
$\tenv_1, []:\tenv_2 \Rightarrow \tenv_2'\mid\tau_2, \varepsilon \vdash E_1:\tau_1 \Rightarrow \tenv_1'\newline$

To have a better understanding, we can now assume a function $\funenv(f) = \langle x\COL\set{z\mid T}\TREF^1\rangle \ra \langle x\COL\set{z\mid z>0}\TREF^1\rangle$.
We give a varible $a$ to this function, it will have $a\COL\set{z\mid T}\TREF^1 \Rightarrow a\COL\set{z\mid z>0}\TREF^1 \LET y=f(a) \IN\dots$.
That is $\overrightarrow{E}\COL \LET y=[ ] \IN\dots, D(f)[a/x]$.




\section{Proof of Type Soundness(Theorem 1)}
To prove the safety of typing, we need to show that the total owership for each heap is always 1.
A triple $(\Gamma, H, R)$ is consistent, written as $[[Cons(H,R,G)]]$, and defined as $\bf{Fig.5}$.
$\newline\bf{Theorem.}$
$\forall D, e, \bf{C}$ $\newline \vdash \langle D, e\rangle$ and $\langle \varnothing, \varnothing, \cdot, e \rangle \ra^* \bf{C}$, which imply
$\bf{C} \neq \bf{AssertFail}.\newline$
The followings are key lemmas:
\begin{lemma}
  \label{lem:initial}
  $[[ |- D <empty,empty,.,e> ]]$
\end{lemma}

\begin{lemma}
  \label{lem:preservation}
  $[[ |- D <H,R,Es,e> /\ <H,R,Es,e> --> D C ==> |- D C ]]$
\end{lemma}

\begin{lemma}
  \label{lem:assertfail}
  $[[ |- D C ==> C != AssertFail ]]$
\end{lemma}

\begin{definition}
  We will write $[[R < R']]$ to denote two register files such that:
  \begin{enumerate}
  \item $[[ dom R]] \subseteq [[ dom R' ]]$, and
  \item $[[ forall x in R.R(x) = R'(x) ]]$
  \end{enumerate}
\end{definition}

\begin{lemma}[Register Weakening]
  \label{lem:register}
  If $[[ SATv(H, R, Rv, T) ]]$, then for any $[[R']]$ such that $[[ R < R' ]]$, $[[ SATv(H, R', Rv, T) ]]$.
\end{lemma}
\begin{proof}
  By induction on the shape of $[[T]]$. If $[[ T = T' ref r ]]$, then
  the result is trivial if $[[r = 0]]$, otherwise it follows from the
  inductive hypothesis. We therefore consider the case where
  $[[ T = {y: int | ph} ]]$. Without loss of generality, we consider
  the case where $[[ dom R' ]] \setminus [[ dom R ]] = \set{x}$,
  $x \neq y$, and $R'(y) = nn$. (If $x = y$, then the added binding
  has no effect by the order of substitutions given by
  $[[ [R; Rv/y]ph ]]$. Similarly, if $R'(y) = a$, the extra binding
  also has no effect. Finally, the case where more than one binding is
  added follows from $n$ applications of the following argument).

  From $[[SATv(H,R,Rv,T)]]$, we conclude that $[[Rv is INT]]$ and that
  $[[ [R; Rv/y]ph ]]$. If $[[x not in FPV(ph)]]$ then $[[ [R; Rv/y]ph = [R';Rv/y]ph ]]$
  and the result holds trivially. Otherwise, if $[[x in FPV(ph)]]$ and $[[x not in R]]$
  from the validity of $[[ [R;Rv/y]ph ]]$, $[[ph]]$ must be true for any value of $x$,
  whence the validity of $[[ [R;Rv/y]ph ]]$ is immediate.
\end{proof}

\begin{definition}
  Two heaps $[[H]]$ and $[[H']]$ are \emph{equivalent modulo $[[a]]$}, written $[[H ~ a H']]$ if:
  \begin{enumerate}
  \item $[[dom H = dom H']]$
  \item $[[forall a' in dom H.a' != a ==> H(a) = H(a')]]$
  \end{enumerate}
\end{definition}

\begin{lemma}[Heap Ownership Preservation]
  \label{lem:heapop}
  Let $[[H]]$ and $[[H']]$ be two heaps such that $[[H ~ a H']]$ for
  some $[[a]]$. If $[[own(H,v,T)(a) = 0]]$, then
  $[[own(H,v,T) = own(H',v,T)]]$.
\end{lemma}
\begin{proof}
  By induction on the shape of $[[T]]$. If $[[T = {y:int |ph}]]$ then
  the result trivially holds. Otherwise, $[[T = T' ref r]]$. We assume
  that $[[v = a'']]$ and $[[a'' in H]]$ (otherwise the result
  trivially holds).  Otherwise consider the case where $[[a'' =
  a]]$. By definition
  $[[own(H,a,T) = {a |-> r} + own(H,H(a),T')]]$, and by the
  assumption that $[[own(H,a,T)(a) = 0]]$ we must have that
  $[[r = 0]]$. Further, by the well-formedness of types, all
  ownerships that appear in $[[T']]$ must be $[[0]]$, thus we have that
  $[[own(H,H(a),T') = own(H',H'(a), T')]]$.

  Finally, consider the case where $[[a'' != a]]$. Then from the
  definition of $[[own(H,a'',T)]]$ and our assumption that
  $[[own(H,a'',T)(a) = 0]]$, we have $[[own(H,H(a''),T')(a) = 0]]$,
  and the result holds from the inductive hypothesis.
\end{proof}

\begin{lemma}
  \label{lem:heapfor0}
  Let $[[H ~ a H']]$ for some $[[a]]$. Then if $[[own(H,v,T)(a) = 0]]$ and $[[SATv(H,R,v,T)]]$ then $[[SATv(H',R,v,T)]]$.
\end{lemma}
\begin{proof}
  By induction on the shape of $[[T]]$. The base case where
  $[[T = {y:int|ph}]]$ is trivial. We therefore consider the case
  where $[[v = a']]$ and $[[T = T' ref r]]$. If $[[a' = a]]$, then by
  our assumption that $[[own(H,a,T)(a) = 0]]$, we must have that
  $r = 0$, and $[[SATv(H',R,v,T)]]$ trivially holds. Otherwise, we
  have that $[[a' != a]]$, and by definition we must have that
  $[[own(H,H(a),T')(a) = 0]]$ hence the result follows from the
  inductive hypothesis.
\end{proof}


\begin{lemma}
  \label{lem:newaddheap}
  If we have heap $H$, such that $[[ SATv(H,R,v,T) ]]$. For any heap $H'$,
  $H' = H\{a\mapsto v'\} , a \notin dom(H)$, then we have $[[ SATv(H', R, v, T) ]]$.
\end{lemma}
\begin{proof}
  By induction on the shape of $[[ T ]]$.
  The base case where $[[T = {y:int|ph}]]$ is trivial.
  Next, we consider the case where $[[T = T' ref r]]$.
  From the definition of $\mathbf{SAT}$,
  if $r = 0$, then $[[SATv(H',R,v,T)]]$ trivially holds.
  Then it remains to show $r>0\produces v \in dom(H')\land[[ SATv(H',R, H'(v),T') ]]$.
  From $v\in dom(H)$ and $a\notin dom(H)$, we have $v\neq a$, which gives that $H'(v)=H(v)$.
  That is $[[ SATv(H',R, H(v),T') ]]$, which is true by the induction hypothesis.
\end{proof}



\begin{lemma}
  \label{lem:sattosat}
  If $[[T1 ~ T2]]$, then $[[SATv(H,R,v,T1) <=> SATv(H,R,v,T2)]]$.
\end{lemma}
\begin{proof}
  The forward case follows from straightforward induction on the shape of $[[T1]]$
  and from the observation that if $[[ph1 <=> ph2]]$ then $[[ [R;v/x]ph1 <=> [R;v/x]ph2]]$. The
  backwards case follows by symmetric reasoning by induction on the shape of $[[T2]]$.
\end{proof}

\paragraph{Proof of Lemma 2.}
\begin{proof}
  The proof is organized by cases analysis on the transition rule used of $[[e]]$, and showing that the output configuration is well typed by
  $[[ |-D ]]$, and for that we must find a $[[G'']]$ that is consistent with $[[H']]$ and $[[R']]$ and also satisfies the other conditions imposed by
  the definition of $[[ |-D ]]$. Here $[[G'']],[[H']], [[R']]$ represent the type environment, heap and register after the transition respectively.
  In order to show that the ownership invariant is preserved, we need to prove that $[[ forall ]] [[ a in H ]].[[F(a)]] \leq 1$.
  We give that $[[a in H]]$ and $F_0$ represents the $[[F(a)]]$ before transition, $F_1$ represents the $[[F(a)]]$ after transition.
  We know that $F_0\leq 1$ since the configuration is well typed before transition, and to prove $F_0=F_1$ in each case.
  \begin{rneqncase}{R-Var}{
    [[ |- D <H, R, En-1 : Es, x>]], [[<H, R, En-1 : Es, x> --> D <H, R, Es, En-1[x]> ]] \\
    [[ Th | G [ x : Tn + T'] | ll |- x : Tn => G[ x <- T' ] ]] \\
    [[ Gn = G [ x <- T' ] ]]
    }
    By the Inversion on configuration typing $[[ |- D <H, R, En-1 : Es, x>]]$ and $[[E[e] = x]] [[/\]] [[E]] = [][[/\]] [[e = x]],$
    we can obtain\newline
    $[[ Th | [] : Tn => Gn | ll |-e E : Tn => Gn ]]$\newline
    $\forall i\in\set{1..n}.[[ Th | [] : Ti => Gi | lli-1 |-e Ei-1 : Ti-1 => Gi-1 ]]$.\newline
    Also using $\cref{lem:stack-well-typed}$, we can conclude that $[[ Th | G | lln-1 |- En-1[x] : Tn-1 => Gn-1 ]].$\newline
    By $\cref{lem:stack_var}$ and $\forall i\in\set{1..n}.[[ Th | [] : Ti => Gi | lli-1 |-e Ei-1 : Ti-1 => Gi-1 ]]$, any decomposition of $[[En-1 [x] ]]$
    into a context $[[E']]$ and expression $[[e']]$ will be well-typed with respect to the types expected by the hole type of $E_{n-2}$.\newline
    It remains to show that $[[Cons(H,R,Gn=G[x : Tn + T'])]]$,
    which follows immediately from $[[Cons(H,R,G)]]$ (note that $[[Gn=G]]$).
  \end{rneqncase}
  \begin{rneqncase}{R-Deref}{
    [[ |- D <H, R, Es, E[let x = *y in e]>]]\\
    [[<H, R, Es, E[let x = *y in e]> --> D <H, R { x' |-> v }, Es, E[ [x'/x]e]> ]]\\
    [[ ll |- T => G' \ x ]] \andalso [[ H(a) = v ]] \andalso [[ R(y) = a ]]\\
    [[ Th | G[y: (T1 + T2) ref r] | ll |- let x = *y in e : T => G' \ x ]]
    }
    Using the Inversion $\cref{lem:inversion}$ of the typing rule on $\rn{T-Deref}$, we can obtain $[[ Th | G[y <- (T1 /\ y y = x) ref r], x : T2 | ll |- e : T => G'\ x ]]$.
    We give $[[G'' = G[y <- (T1 /\ y y = x') ref r], x' : T2]]$ and $[[ R'= R { x' |-> v } ]]$.\newline
    We want to show $[[ Th | G'' | ll |- [x'/x]e : T => G' \ x ]]$ and $[[Cons(H,R { x' |-> v }, G'')]]$.
    The first is easy to obtain using $\cref{lem:substitution}.$
    It remains to show $[[Cons(H,R { x' |-> v }, G'')]]$. To show that the output environment is consistent, it suffices to show that $[[ SATv(H,R',R'(x'),T2) ]]$
    and $SAT_v(H,R',H(R'(y)),\tau_1\land_y y=x)$.
    If $[[ T1 ]]$ is an integer, by the definition of the strengthening operator, the latter is equivalent to show that $[[ SATv(H,R',H(R'(y)),T1) ]]$
    and that $R'(x')=H(R'(y))=H(R(y))$, which is immediate from the definition of $\rn{R-Deref}$.
    If $[[ T1 ]]$ is not an integer, then we must only show that $[[ SATv(H,R',H(R'(y)),T1) ]]$.\newline
    We know that $[[Cons(H,R,G)]]\produces [[SAT(H,R,G)]]\produces [[y in R /\ SATv(H,R,R(y),G(y)) ]] $.
    From $\cref{lem:satadd}$ and $\cref{lem:register}$, we obtain $[[ SATv(H,R,v,T1+T2) ]] \produces[[ SATv(H,R',v,T1) ]]\land[[ SATv(H,R',v,T2) ]]$, where $[[ R' < R ]]$ and $v = H(R(y))$.
    We therefore prove that $[[ SATv(H,R',R'(x'),T2) ]]$ and $[[ SATv(H,R',H(R'(y)),T1) ]]$ are satisfied.\newline
    We must also show that the ownership invariant is preserved.\newline
    Then, it's to show $[[forall]][[a in H]].[[F(a)]] \leq 1$. Define $F_0$ and $F_1$ as follows:\newline
    $F_0=F'_0 + [[own(H,R(y),G(y))]]$\newline
    $F_1=F'_1 + [[own(H',R'(y),G''(y))]] + [[own(H',R'(x'),G''(x'))]]$\newline
    $F'_0 = \sum_{z\in\textit{dom}(\tenv)\setminus\{y\}}[[own(H,R(z),G(z))]]$\newline
    $F'_1 = \sum_{z\in\textit{dom}(\tenv'')\setminus\{y,x'\}}[[own(H',R'(z'),G''(z'))]]$\newline
    By $\cref{lem:heapop}$, $F'_0=F'_1$ holds.
    From $\cref{lem:ownadd}$, we have $[[ own(H,v,T1+T2) ]] = [[ own(H,v,T1) ]] + [[ own(H,v,T2) ]]$, where $v = H(R(y))$.
    We know that $R'(x')=H(R'(y))=H(R(y))$, so $[[ own(H,R'(x'),G''(x')) ]] =[[ own(H,R'(x'),T2) ]]$, $[[ own(H,R(y),G(y)) ]]=[[ own(H,v,T1+T2) ]]$ and $[[ own(H,R'(y),G''(y)) ]]=[[ own(H,H(R'(y)),T1) ]]$,
    so we have $[[own(H,R(y),G(y))]]=[[own(H,R'(y),G''(y))]]+ [[own(H,R'(x'),G''(x'))]]$, and conclude that $F_0=F_1$.
  \end{rneqncase}
  \begin{rneqncase}{R-Let}{
    [[ |- D <H, R, Es, E[let x = y in e]> ]]\\
    [[<H, R, Es, E[let x = y in e]> --> D <H, R { x' |-> R(y)}, Es, E[ [x'/x]e]> ]]\\
    [[ x' fresh in R ]]\\
    [[ Th | G[y: T1 + T2] | ll |- let x = y in e : T => G' \ x]]
    }
    Using the Inversion $\cref{lem:inversion}$ of the typing rule on $\rn{T-Let}$, we can obtain $[[ Th | G [ y <- T1 /\ y y = T1 x  ], x : (T2 /\ x x = T2 y) | ll |- e : T => G']]$ and
    $[[ll |- T => G' \ x]]$. We give $[[G'' = G [ y <- T1 /\ y y = T1 x'  ], x' : (T2 /\ x' x' = T2 y)]]$ and $[[ R'= R { x' |->  R(y) } ]]$.\newline
    We want to show $[[ Th | G'' | ll |- [x'/x]e : T => G' \ x ]]$ and $[[Cons(H,R { x' |->  R(y) }, G'')]]$.
    The first is easy to obtain using $\cref{lem:substitution}.$
    It remains to show $[[Cons(H,R{ x' |-> R(y) },G'')]]$. \newline
    To show that the output environment is consistent, we must show that $SAT_v(H,R',R'(x'),\tau_2\land_{x'} x'=y)$ and $SAT_v(H,R',R'(y),\tau_1\land_y y=x')$.
    By reasoning similar to that in $\rn{R-Deref}$, it suffices to show that $[[ SATv(H,R',R'(x'),T2) ]]$ and $[[ SATv(H,R',R'(y),T1) ]]$.
    We know that $[[Cons(H,R,G)]]\produces [[SAT(H,R,G)]]\produces [[y in R /\ SATv(H,R,R(y),G(y)) ]] $.
    From $\cref{lem:satadd}$ and $\cref{lem:register}$, we obtain $[[ SATv(H,R,v,T1+T2) ]] \produces[[ SATv(H,R',v,T1) ]]\land[[ SATv(H,R',v,T2) ]]$, where $[[ R' < R ]]$ and $v = R(y)$.
    We then have $[[ SATv(H,R',R'(x'),T2) ]]$ and $[[ SATv(H,R',R'(y),T1) ]]$ are satisfied.\newline
    We must also show that the ownership invariant is preserved.\newline
    Then, it's to show $[[forall]][[a in H]].[[F(a)]] \leq 1$. Define $F_0$ and $F_1$ as follows:\newline
    $F_0=F'_0 + [[own(H,R(y),G(y))]]$\newline
    $F_1=F'_1 + [[own(H',R'(y),G''(y))]] + [[own(H',R'(x'),G''(x'))]]$\newline
    $F'_0 = \sum_{z\in\textit{dom}(\tenv)\setminus\{y\}}[[own(H,R(z),G(z))]]$\newline
    $F'_1 = \sum_{z\in\textit{dom}(\tenv'')\setminus\{y,x'\}}[[own(H',R'(z'),G''(z'))]]$\newline
    By $\cref{lem:heapop}$, $F'_0=F'_1$ holds.
    That $[[own(H,R'(x'),T2)]] + [[own(H,R'(y),T1)]] = [[own(H,R(y),T1+T2)]]$ follows immediately
    from $\cref{lem:ownadd}$ and the condition $R(y)=R'(x')=R'(y)$.
    We therefore conclude that $F_0=F_1$.
  \end{rneqncase}
  \begin{rneqncase}{R-LetInt}{
    [[ |- D <H, R, Es, E[let x = nn in e]>]]\\
    [[ <H, R, Es, E[let x = nn in e]> --> D <H, R { x' |-> nn }, Es, E[ [x'/x]e]> ]]
    }
    Using the Inversion $\cref{lem:inversion}$ of the typing rule on $\rn{T-LetInt}$, we can obtain $[[ Th | G, x:{x : int | x = nn } | ll |- e : T => G']]$.
    We give that $[[ G''= G ]],x':\{x'\COL \TINT\mid x' = n\}\}$.\newline
    We want to show that $[[ Th | G'' | ll |- [x'/x]e : T => G' \ x]]$ and $[[ Cons(H, R { x' |-> nn }, G'') ]]$.
    The first one is easy to obtain using the $\cref{lem:substitution}$ and $[[ Cons(H, R { x' |-> nn }, G'') ]]$ is trivial.
  \end{rneqncase}
  \begin{rneqncase}{R-IfTrue}{
    [[ |- D <H, R, Es, E[ifz x then e1 else e2]>]]\\
    [[ <H, R, Es, E[ifz x then e1 else e2]> --> D <H, R, Es, E[e1]> ]]\\
    [[ Th | G[x : {y:int|ph}] | ll |- ifz y then e1 else e2 : T => G' ]]
    }
    Using the Inversion $\cref{lem:inversion}$ of the typing rule on $\rn{T-If}$, we can obtain $[[ Th | G[x <- {y:int | ph /\ y = 0 }] | ll |- e1 : T => G' ]]$.
    We take $[[ G'' = G[x <- {y:int | ph /\ y = 0 }] ]]$, and want to show that $[[ Cons(H, R, G'') ]]$.\newline
    We know that $[[Cons(H,R,G)]] \produces [[SAT(H,R,G)]]\produces x\in \textit{dom}(R)\land R(x)\in \mathbb{Z}\land [R;R(x)/y]\varphi$, here $\tenv(x)=\{y\COL\TINT\mid\varphi\}$.
    The refinement predicates $\varphi$ still holds in the output environment, since nothing changes in the heap and the register after transition.
    Also from precondition of $\rn{R-IfTrue}$, we have $R(x)=0$, thus $y$ satisfies the refinement that $y=0$.
    Thus $[[ [R;R(x)/y]ph ]]\land y=0$ is trivially satisfied.
  \end{rneqncase}
  \begin{rneqncase}{R-IfFalse}\newline
    Similar to the case for $\rn{R-IfTrue}$.
  \end{rneqncase}
  \begin{rneqncase}{R-MkRef}{
    [[ |- D <H, R, Es, E[let x = mkref y in e]>]]\\
    [[ <H, R, Es, E[let x = mkref y in e]> --> D <H { a |-> R(y) }, R { x' |-> a }, Es, E[ [x'/x]e]> ]]\\
    [[ Th | G[y : T1 + T2] | ll |- let x = mkref y in e : T => G' \ x ]]
    }
    Using the Inversion on the typing rule on $\rn{T-MkRef}$, we can obtain $[[ Th | G[y <- T1],x : (T2 /\ x x = y) ref 1 | ll |- e : T => G']] \land
    [[ ll |- T => G' \ x ]]$. We give $[[ G'' = G[y <- T1],x' : (T2 /\ x' x' = y) ref 1 ]]$.\newline
    By the Inversion on the transition rule $\rn{R-MkRef}$, we can obtain $a\notin \textit{dom}(H)$.\newline
    We want to show that $[[ Th | G[y <- T1],x' : (T2 /\ x' x' = y) ref 1 | ll |- [x'/x]e : T => G'\ x ]]$ and $\bf{Cons}$ $(H'= H \{ a \mapsto R(y) \},R'= R\{ x' \mapsto a \},\tenv'')$.
    The first is easy to obtain using $\cref{lem:substitution}.$\newline
    It remains to show $[[Cons(H',R',G'')]]$.
    To show that the output environment is consistent, we must show that $SAT_v(H',R',R'(x'),(\tau_2\land_{x'} x'=y )\TREF^1)$ and $[[ SATv(H',R',R'(y),T1) ]]$.
    By reasoning similar to that in $\rn{R-Deref}$, it suffices to show that $[[ SATv(H',R',R'(x'),T2 ref 1) ]]$ and $[[ SATv(H',R',R'(y),T1) ]]$.
    We know that $[[Cons(H,R,G)]]\produces [[SAT(H,R,G)]]\produces [[y in R /\ SATv(H,R,R(y),G(y)) ]] $.
    From $\cref{lem:register}$, we obtain $[[ SATv(H,R,v,T1+T2) ]] \produces[[ SATv(H,R',v,T1+T2) ]]$. By $\cref{lem:newaddheap}$, we have $[[ SATv(H',R',v,T1+T2) ]]$.
    Then by $\cref{lem:satadd}$, we have $[[ SATv(H',R',v,T1) ]]\land[[ SATv(H',R',v,T2) ]]$, where $[[ R' < R ]]$ and $v = R(y)$.
    We then have $[[ SATv(H',R',R'(x'),T2 ref 1) ]]$ and $[[ SATv(H',R',R'(y),T1) ]]$ are satisfied.\newline
    We must also show that the ownership invariant is preserved.\newline
    Then, it's to show $[[forall]][[a in H]].[[F(a)]] \leq 1$. We have:\newline
    $F_1 = \sum_{z\in\textit{dom}(\tenv'')}[[own(H',R'(z'),G''(z'))]] = \sum_{z\in\textit{dom}(\tenv)}[[own(H,R(z),G(z))]] + \{a'\mapsto 1\} = F_0 + \{a'\mapsto 1\}$,
    with $[[a' not in H]]$.\newline
    We want to show that $[[forall]][[a in H']].F_1(a) \leq 1$.\newline
    Suppose $a\neq a'$, that is $[[a in H]]$, we have $F_1(a)=F_0(a)\leq 1$ by $[[Cons(H,R,G)]].$
    Next, suppose $a=a'$; we have $F_1(a)=1$ only if $a' \notin \textit{dom}(F_0)$, where $F_0=\sum_{z\in\textit{dom}(\tenv)}[[own(H,R(z),G(z))]]$. This is immediate from $[[a' not in H]]$ by
    the definition of $[[own(H,v,T)]]$.
  \end{rneqncase}
  \begin{rneqncase}{R-Assign}{
    [[ |- D <H, R, Es, E[y:=x;e]>]]\\
    [[ <H, R, Es, E[y:=x;e]> --> D <H { a <- R(x)}, R, Es, E[e]> ]]\andalso a = R(y)\\
    [[ Th | G[x: T1 + T2][y : T' ref 1] | ll |- y := x; e : T => G']]
    }
    Using the Inversion $\cref{lem:inversion}$ of the typing rule on $\rn{T-Assign}$, we can obtain $[[ Th | G[x <- T1][y <- T2 /\ y y = T2 x ref 1] | ll |- e : T => G']]$.
    We give $[[ G'' = G[x <- T1][y <- T2 /\ y y = T2 x ref 1] ]]$.\newline
    We want to show that $\bf{Cons}$ $(H'= H \{ a \hookleftarrow R(y) \},R'= R,\tenv'').$\newline
    To show that the output environment is consistent, we must show that $SAT_v(H',R,R(y),(\tau_2\land_{y} y=x )\TREF^1)$ and $[[ SATv(H',R,R(x),T1) ]]$.
    By reasoning similar to that in $\rn{R-Deref}$, it suffices to show that $[[ SATv(H',R,R(y),T2 ref 1) ]]$ and $[[ SATv(H',R,R(x),T1) ]]$.
    We define $F_0$ and $F_1$ as below:\newline
    $F_0=F'_0 + \mathbf{own}(H, R(y), \tenv(y))+\mathbf{own}(H, R(x), \tenv(x)) = F'_0 + F''_0$\newline
    $F_1=F'_1 + \mathbf{own}(H', R(y), \tenv''(y)) + \mathbf{own}(H', R(x), \tenv''(x)) = F'_1 + F''_1$\newline
    $F'_0 = \sum_{z\in\textit{dom}(\tenv)\setminus\{y,x\}}\mathbf{own}(H,R(z),\tenv(z))$\newline
    $F'_1 = \sum_{z\in\textit{dom}(\tenv'')\setminus\{y,x\}}\mathbf{own}(H',R(z),\tenv''(z))$\newline
    From $[[Cons(H,R,G)]]$, we know that $[[a in H]], F_0(a)\leq 1$.\newline
    $F_0=F'_0 +\mathbf{own}(H, H(R(y)), \tau') + \{a\mapsto 1\} + \mathbf{own}(H, R(x), \tau_1+\tau_2)$\newline
    $F_0(a)=F'_0(a) +\mathbf{own}(H, H(R(y)), \tau')(a) + 1 + \mathbf{own}(H, R(x), \tau_1+\tau_2)(a)$\newline
    We then have $\mathbf{own}(H, R(x), \tenv(x))(a)=\mathbf{own}(H, R(x), \tau_1+\tau_2)(a)=0$.
    We know that $[[Cons(H,R,G)]]\produces [[SAT(H,R,G)]]\produces [[x in R /\ SATv(H,R,R(x),G(x)) ]] $.
    By $\cref{lem:heapfor0}$ and $\mathbf{own}(H, R(x), \tau_1+\tau_2)(a)=0$, we obtain $[[ SATv(H,R,v,T1+T2) ]] \produces[[ SATv(H',R,v,T1+T2) ]]$.
    Then by $\cref{lem:satadd}$, we have $[[ SATv(H',R,v,T1) ]]\land[[ SATv(H',R,v,T2) ]]$, where $v = R(x)$.
    We then have $[[ SATv(H',R,R(y),T2 ref 1) ]]$ and $[[ SATv(H',R,R(x),T1) ]]$ are satisfied.\newline
    We must also show that the ownership invariant is preserved.\newline
    Then, it's to show $[[a in H]].[[F(a)]] \leq 1$.
    Since $F'_0=F'_1$ holds by pointwise application of $\cref{lem:heapop}$, and $[[a in H]], F_0(a)\leq 1$, if $\forall a'\in dom(H'), F''_1(a')\leq F''_0(a')$, we can conclude that $F_1(a')\leq F_0(a')\leq 1$.\newline
    Suppose $a= a'$; \newline
    $F''_1(a)=\mathbf{own}(H', H'(R(y)), \tau_2)(a) + \mathbf{own}(H', R(x), \tau_1)(a)+1$\newline
    $F''_0(a)=\mathbf{own}(H, R(x), \tau_2+\tau_1)(a) + \mathbf{own}(H, H(R(y)), \tau')(a)+1$\newline
    We know $F_0(a')\leq 1$, that is $\mathbf{own}(H, R(x), \tau_2+\tau_1)(a) = \mathbf{own}(H, H(R(y)), \tau')(a) =0$.
    By $\cref{lem:heapop}$, we have $\mathbf{own}(H, R(x), \tau_2+\tau_1) = \mathbf{own}(H', R(x), \tau_2+\tau_1)$.
    Also by $\cref{lem:ownadd}$, we have $\mathbf{own}(H', R(x), \tau_2+\tau_1) = \mathbf{own}(H', R(x), \tau_1)+\mathbf{own}(H', R(x), \tau_2)$.
    Then we have $\mathbf{own}(H', H'(R(y)), \tau_2)(a)=\mathbf{own}(H', R(x), \tau_1)(a)=0$.
    Therefore, $F''_1(a)=\mathbf{own}(H', H'(R(y)), \tau_2)(a) + \mathbf{own}(H', R(x), \tau_1)(a)+1 = 1\leq F''_0(a')$.\newline
    Next, suppose $a\neq a'$;\newline
    $F''_1(a')=\mathbf{own}(H', H'(R(y)), \tau_2)(a') + \mathbf{own}(H', R(x), \tau_1)(a')$\newline
    $F''_0(a')=\mathbf{own}(H, R(x), \tau_2+\tau_1)(a') + \mathbf{own}(H, H(R(y)), \tau')(a')$\newline
    By reasoning similar to the case for $a= a'$, we have $F''_1(a')\leq F''_0(a')$.
    Finally, we conclude that $[[a' in H']] F_1(a')\leq 1$.
  \end{rneqncase}
  \begin{rneqncase}{R-Alias}{
    [[ |- D <H, R, Es, E[alias(x = y); e]>]]\\
    [[ <H, R, Es, E[alias(x = y); e]> --> D <H, R, Es, E[e]> ]]\\
    [[ Th | G[x : T1 ref r1][y: T2 ref r2] | ll |- alias(x = y); e : T => G']]
    }
    Using the Inversion $\cref{lem:inversion}$ of the typing rule on $\rn{T-Alias}$, we can obtain $[[ Th | G[x <- T1' ref r1'][y <- T2' ref r2'] | ll |- e : T => G']]$ and $[[(T1 ref r1 + T2 ref r2) ~ (T1' ref r1' + T2' ref r2')]]$.
    We give $[[ G'' = G[x <- T1' ref r1'][y <- T2' ref r2'] ]]$.\newline
    It remains to show $[[Cons(H, R, G'')]]$.\newline
    We suppose the refinements before transition are $\tenv(x)=\tau_1^a, \tenv(y)=\tau_2^a$.
    After transition, the type environment becomes $\tenv''(x)=\tau_1^b, \tenv''(y)=\tau_2^b$.\newline
    We know that $[[Cons(H,R,G)]]\produces [[SAT(H,R,G)]]\produces [[y in R /\ SATv(H,R,R(y),G(y)) ]] $.
    We then have $\tau_1^a+\tau_2^a= \tau^a$, by $\cref{lem:satadd}$, $SAT_v(H,R,v,\tau^a) \iff SAT_v(H,R,v,\tau_1^a)\land SAT_v(H,R,v,\tau_2^a)$, where $v = H(R(y))=H(R(x))$, since the definition of $\rn{R-Alias}$.
    Similarly, we also have $\tau_1^b+\tau_2^b= \tau^b$, by $\cref{lem:satadd}$, $SAT_v(H,R',v,\tau^b) \iff SAT_v(H,R',v,\tau_1^b)\land SAT_v(H,R',v,\tau_2^b)$, where $v = H(R(y))=H(R(x))$.
    We then have $\tau^a\approx\tau^b$, according to the rules for type equivalence.
    From $\cref{lem:sattosat}$, we have $SAT_v(H,R,v,\tau^a)\iff SAT_v(H,R',v,\tau^b)$.
    Then the type refinements after transition still satisfy the $[[Cons(H, R, G'')]]$ condition from above.\newline
    Then, it's to show $[[a in H]].[[F(a)]] \leq 1$. Here $F_0$ represents the $[[F(a)]]$ before transition, $F_1$ represents the $[[F(a)]]$ after transition.
    To prove that $F_0=F_1$ follows from:\newline
    $\mathbf{own}(H,R(x),\tau_1\TREF^{r_1}) + \mathbf{own}(H,R(y),\tau_2\TREF^{r_2}) = \mathbf{own}(H,R(x),\tau'_1\TREF^{r'_1}) + \mathbf{own}(H,R(y),\tau'_2\TREF^{r'_2})$.
    which follows immediately from the conditions $\tau_1\TREF^{r_1} + \tau_2\TREF^{r_2} = \tau'_1\TREF^{r'_1} + \tau'_2\TREF^{r'_2}$ and $R(x) = R(y)$.\newline
  \end{rneqncase}
  \begin{rneqncase}{R-AliasFail}\newline
    The result configuration $[[AliasFail]]$ is trivially well-typed.
  \end{rneqncase}
  \begin{rneqncase}{R-Assert}{
    [[ |- D <H, R, Es, E[assert(ph); e]>]]\andalso [[ G |= ph ]]\\
    [[ <H, R, Es, E[assert(ph); e]> --> D <H, R, Es, E[e]> ]]\\
    [[ Th | G | ll |- assert(ph); e : T => G']]
    }
    Using the Inversion $\cref{lem:inversion}$ of the typing rule on $\rn{T-Assert}$, we can obtain $[[ Th | G | ll |- e : T => G' ]]$.\newline
    $[[Cons(H',R',G')]]$ follows immediately from $[[Cons(H,R,G)]]$ (note that $\tenv'=\tenv, H'=H, R'=R$.)\newline
  \end{rneqncase}
  \begin{rneqncase}{R-AssertFail}{
    [[ |- D <H, R, Es, E[assert(ph); e]>]]\andalso [[ R !|= ph ]]\\
    [[ <H, R, Es, E[assert(ph); e]> --> D AssertFail ]]\\
    [[ Th | G | ll |- assert(ph); e : T => G']]
    }
    Using the Inversion $\cref{lem:inversion}$ of the typing rule on $\rn{T-Assert}$, we can obtain $[[ Th | G | ll |- e : T => G' ]]$ and $[[ G |= ph ]]$.\newline
    $[[ G |= ph ]]$ is defined as $\models \sem{[[G]]}\produces \varphi$, which means under any model $[[M]]$ that satisfy the refinements in $\tenv$, $\varphi$ will be true, that is $[[ M |= ph ]]$.
    By inversion on $[[ |- D <H, R, Es, E[assert(ph); e]>]]$, we have $[[Cons(H, R,G)]] \produces [[SAT(H,R,G)]]$, which will give
    that every concrete value in the register must satisfy the refinement predicates in the type environment.
    Thus, $\varphi$ must be satisfied under any model $[[ M ]]$ such that $[[x in R]]. [[ M(x) = R(x) ]]$.
    Thus $[[R |= ph]]$ must be true.
    But in the case for $\rn{AssertFail}$, we have precondition as $[[ R !|= ph ]]$, which is contradictory with what we have been
    derived, which shows the case is impossible.
  \end{rneqncase}
  \begin{rneqncase}{R-Call}{
    [[ |- D <H, R, Es, E[let x = f l (y1,,yn) in e']>]]\\
    [[ Th | G[yi: csub vsub Ti] | ll |- let x = f l (y1,,yn) in e' : T' => G' \ x]]\\
    [[f |-> (x1, .., xn) e in D]]
    }
    $[[ <H, R, Es, E[let x = f l (y1,,yn) in e']> --> D <H, R, E[let x = [] l in e'] : Es, [y1/x1] ,, [yn/xn] e> ]]$\newline
    Using the Inversion $\cref{lem:inversion}$ of the typing rule on $\rn{T-Call}$, we can obtain \newline
    $[[ Th(f) = A < x1 : T1 ,, xn : Tn > -> <x1: T1' ,, xn : Tn' | T > ]]$ \newline
    $[[csub = [l:ll/A] ]] \andalso [[ vsub = [y1/x1] ,, [yn/xn] ]]$ \newline
    $[[ ll |- T' => G' \ x]]$\newline
    $[[ Th | G[yi <- csub vsub Ti'], x : csub vsub T | ll |- e' : T' => G' \ x]]$\newline
    By the Inversion on configuration typing $[[ |- D <H, R, Es, E[let x = f l (y1,,yn) in e']>]]$, we can obtain \newline
    $[[ Th | [] : T' => G' \ x | ll |-e E : Tn => Gn ]].$\newline
    We want to show that: \begin{align*}
    & [[ Th | G[yi: csub vsub Ti] | l:ll |- vsub e : csub vsub T => G[yi <- csub vsub Ti'] ]] \\
    & [[ Th | [] : csub vsub T => G[yi <- csub vsub Ti'] | ll |-e E[let x = [] l in e'] : Tn => Gn ]]
    \end{align*}
    To prove these, we can look at $\cref{lem:callfunc}$.\newline
    We need to prove that $\forall i\in\set{1..n+1}.[[ Th | [] : Ti => Gi | lli-1 |-e E'i-1 : Ti-1 => Gi-1 ]]$  where $[[ E'n = E[let x = [] l in e'] ]]$ and $[[ E'i = Ei ]] (0 \leq i < n)$,
    which can be divided into proving
    $\forall i\in\set{1..n}.[[ Th | [] : Ti => Gi | lli-1 |-e E'i-1 : Ti-1 => Gi-1 ]]$ and $[[ Th | [] : Tn+1 => Gn+1 | lln |-e E'n : Tn => Gn ]]$. The first follows by inversion on $[[ |- D <H, R, Es, E[let x = f l (y1,,yn) in e']>]]$.\newline
    We define $\tenv_{n+1} = [[ G[yi <- csub vsub Ti'] ]]$ and $\tau_{n+1} = [[ csub vsub T ]]$.
    It remains to show $[[ Th | [] : Tn+1 => Gn+1 | lln |-e E'n : Tn => Gn ]]$.
    As $E'_n$ is $[[ E[let x = [] l in e'] ]]$.
    From above we obtain $[[ Th | [] : Tn+1 => Gn+1 | ll |-e E[let x = [] l in e'] : Tn => Gn ]]$.\newline
    Finally, by $\cref{lem:stack_var}$ and $[[ Th | G[yi: csub vsub Ti] | l:ll |- vsub e : Tn+1 => Gn+1 ]]$, any decomposition of $[[vsub e]]$ into a context $E'$
    and expression $e'$ will be well-typed as $\tau_{n+1}$ and $\tenv_{n+1}$, which are the return type and environment expected by the hole of return context $E'_n$.\newline
    $[[Cons(H',R',G'')]]$ follows immediately from $[[Cons(H,R,G)]]$ (note that $\tenv''=\tenv, H'=H, R'=R$).
  \end{rneqncase}
\end{proof}

\begin{lemma}
  \label{lem:ownadd}
  If $[[ Tp = T1 + T2 ]]$, then we have $\mathbf{own}(H,v,\tau_p) =  \mathbf{own}(H,v,\tau_1)+\mathbf{own}(H,v,\tau_2)$.
\end{lemma}
\begin{proof}
  By induction on the rules used to derive $[[ T1 + T2 = Tp]]$.
  \begin{rneqncase}{Tadd-Int}\newline
  We have $\mathbf{own}(H,v,\tau_p)=\mathbf{own}(H,v,\tau_1+\tau_2)$, where $[[ T1 + T2 = {x:int | ph1/\ph2} ]]$,
  $\mathbf{own}(H,v,\tau_1)$ and $\mathbf{own}(H,v,\tau_2)$, where $[[ T1= {x:int | ph1} ]], [[ T2 = {x:int | ph2} ]]$.\newline
  From the definition of ownership, we have $\mathbf{own}(H,v,\tau_p)=\mathbf{own}(H,v,\tau_1)=\mathbf{own}(H,v,\tau_2)=\emptyset$.
  It is trivial that $\mathbf{own}(H,v,\tau_p) = \mathbf{own}(H,v,\tau_1) + \mathbf{own}(H,v,\tau_2).$
  \end{rneqncase}
  \begin{rneqncase}{Tadd-Ref1}\newline
  We have $\mathbf{own}(H,v,\tau_p)=\mathbf{own}(H,v,\tau_1+\tau_2)$, where $[[ T1 + T2 = (T1' + T2') ref r1+r2 ]]$,
  $\mathbf{own}(H,v,\tau_1)$ and $\mathbf{own}(H,v,\tau_2)$, where $[[ T1 = T1' ref r1 ]]$, $[[ T2 = T2' ref r2 ]]$.\newline
  From the definition of ownership, we have $\mathbf{own}(H,v,\tau_p)=\{a\mapsto (r_1+r_2)\}+\mathbf{own}(H,H(v),\tau'_1+\tau'_2)$,
  $\mathbf{own}(H,v,\tau_1) + \mathbf{own}(H,v,\tau_2) = \{a\mapsto r_1\}+\mathbf{own}(H,H(v),\tau'_1) + \{a\mapsto r_2\}+\mathbf{own}(H,H(v),\tau'_2)$.
  By the induction hypothesis, we conclude that $\mathbf{own}(H,v,\tau_p) = \mathbf{own}(H,v,\tau_1) + \mathbf{own}(H,v,\tau_2).$
  \end{rneqncase}
  \begin{rneqncase}{Tadd-Ref2}\newline
  We have $\mathbf{own}(H,v,\tau_p)=\mathbf{own}(H,v,\tau_1+\tau_2)$, where $[[ T1 + T2 = T2' ref r ]]$,
  $\mathbf{own}(H,v,\tau_1)$ and $\mathbf{own}(H,v,\tau_2)$, where $[[ T1 = T1' ref 0 ]]$, $[[ T2 = T2' ref r ]]$.\newline
  From the well-formedness condition states that all ownerships within the type $[[ T1 = T1' ref 0 ]]$ are $0$, we have $\mathbf{own}(H,v,\tau_1)=\emptyset.$
  Also we know that $\mathbf{own}(H,v,\tau_p) = \mathbf{own}(H,v,\tau_2)$.
  It is trivial that $\mathbf{own}(H,v,\tau_p) = \mathbf{own}(H,v,\tau_1) + \mathbf{own}(H,v,\tau_2).$
  \end{rneqncase}
  \begin{rneqncase}{Tadd-Ref3}\newline
  We have $\mathbf{own}(H,v,\tau_p)=\mathbf{own}(H,v,\tau_1+\tau_2)$, where $\tau_1 + \tau_2 = [[ Top ]] \TREF^0$,
  $\mathbf{own}(H,v,\tau_1)$ and $\mathbf{own}(H,v,\tau_2)$, where $[[ T1 = T1' ref 0 ]]$, $[[ T2 = T2' ref 0 ]]$.\newline
  From the well-formedness condition states that all ownerships within the types $[[ Tp ]], [[ T1 ]]$ and $[[ T2 ]]$ are $0$, we have $\mathbf{own}(H,v,\tau_p)=\mathbf{own}(H,v,\tau_1)=\mathbf{own}(H,v,\tau_2)=\emptyset$.
  It is trivial that $\mathbf{own}(H,v,\tau_p) = \mathbf{own}(H,v,\tau_1) + \mathbf{own}(H,v,\tau_2).$
  \end{rneqncase}
\end{proof}



\begin{lemma}
  \label{lem:satadd}
  If $[[ Tp =  T1+T2 ]]$,
  we have:\newline
  $[[ SATv(H, R, Rv, Tp) ]] \iff [[ SATv(H, R, Rv, T1) ]]\land [[ SATv(H, R, Rv, T2) ]]$.
\end{lemma}
\begin{proof}
  By induction on the rules used to derive $[[ T1 + T2 ]]$.
  \begin{rneqncase}{Tadd-Int}\newline
  Forward derivation:
  We have $[[ SATv(H, R, Rv, T1+T2) ]]$, where $[[ T1 + T2 = {x:int | ph1/\ph2} ]]$,
  $[[ SATv(H, R, Rv, T1) ]]$ and $[[ SATv(H, R, Rv, T2) ]]$, where $[[ T1= {x:int | ph1} ]], [[ T2 = {x:int | ph2} ]]$.\newline
  From the definition of $\mathbf{SAT}$, we have $[[ SATv(H, R, Rv, T1) ]] \produces [[ [R; v/x]ph1 ]]$ and $[[ SATv(H, R, Rv, T2) ]] \produces [[ [R; v/x]ph2 ]]$.
  also $[[ SATv(H, R, Rv, T1+T2) ]] \produces [[ [R; v/x](ph1 /\ ph2) ]]$.
  It is immediate that for any value $v$ such that $[[ [R; v/x](ph1 /\ ph2) ]]$, we must have $[[ [R; v / y]ph1 ]]$ and $[[ [R; v / x]ph2 ]]$.
  We then conclude $[[ SATv(H, R, Rv, T1+T2) ]]\produces[[ SATv(H, R, Rv, T1) ]]\land[[ SATv(H, R, Rv, T2) ]].$
  Backward derivation is by reasoning similar to the forward derivation.
  \end{rneqncase}
  \begin{rneqncase}{Tadd-Ref1}\newline
  Forward derivation:
  From the definition of $\mathbf{SAT}$, we have $[[ SATv(H, R, Rv, T1) /\ r1 > 0 ==> a in H /\ SATv(H,R,H(a),T1')]] \land [[ T1 = T1' ref r1 /\ Rv = a ]]$,
  and $[[ SATv(H, R, Rv, T2) /\ r2 > 0 ==> a in H /\ SATv(H,R,H(a),T2')]] \land [[ T2 = T2' ref r2 /\ Rv = a ]]$.
  Also $[[ SATv(H, R, Rv, T1+T2) ]] \land (r_1+r_2) > 0 \produces[[ a in H /\ SATv(H,R,H(a),T1'+T2')]] \land [[ (T1+T2) = (T1'+T2') ref r1+r2 /\ Rv = a ]]$.
  By the induction hypothesis, we have $[[ SATv(H,R,H(a),T1'+T2') ]]\produces [[ SATv(H,R,H(a),T1') ]]\land [[ SATv(H,R,H(a),T2') ]]$.
  We then conclude $[[ SATv(H, R, Rv, T1+T2) ]]\produces[[ SATv(H, R, Rv, T1) ]]\land[[ SATv(H, R, Rv, T2) ]].$
  Backward derivation is by reasoning similar to the forward derivation.
  \end{rneqncase}
  \begin{rneqncase}{Tadd-Ref2}\newline
  Forward derivation:
  In this case, we have $[[ T1 + T2 = T2' ref r ]]$, $[[ T1 = T1' ref 0 ]]$ and $[[ T2 = T2' ref r ]]$, where $r>0$.
  From the definition of $\mathbf{SAT}$, we have $[[ SATv(H, R, Rv, T1) ]]=[[ SATv(H, R, Rv, T1' ref 0) ]]\produces 0 > 0\produces [[a in H /\ SATv(H,R,H(a),T1') /\ Rv = a ]]$.
  Then $[[ SATv(H, R, Rv, T2) ]]=[[ SATv(H, R, Rv, T1+T2) ]] \produces [[ SATv(H, R, Rv, T2' ref r) ]] \land r > 0 \produces[[ a in H /\ SATv(H,R,H(a),T2')]] \land [[ Rv = a ]]$.
  That is $[[ SATv(H, R, Rv, T1+T2) ]] \produces [[ SATv(H,R,H(a),T1') /\ SATv(H,R,H(a),T2') ]].$
  We then conclude $[[ SATv(H, R, Rv, T1+T2) ]]\produces[[ SATv(H, R, Rv, T1) ]]\land[[ SATv(H, R, Rv, T2) ]].$
  Backward derivation is by reasoning similar to the forward derivation.
  \end{rneqncase}
  \begin{rneqncase}{Tadd-Ref3}\newline
  Forward derivation:
  In this case, we have $[[ (T1+T2) ]] =[[ Top ]] \TREF^0 $, $[[ T1 = T1' ref 0 ]]$ and $[[ T2 = T2' ref 0 ]]$.
  From the definition of $\mathbf{SAT}$, as the ownerships are 0, we have $[[ SATv(H, R, Rv, T1) ]]$ and $[[ SATv(H, R, Rv, T2) ]]$ are trival true.
  We then conclude $[[ SATv(H, R, Rv, T1+T2) ]]\produces[[ SATv(H, R, Rv, T1) ]]\land[[ SATv(H, R, Rv, T2) ]].$
  Backward derivation is by reasoning similar to the forward derivation.
  \end{rneqncase}
\end{proof}



\begin{lemma} \bf{Inversion}
  \label{lem:inversion}
  \begin{rneqncase}{T-Let}\newline
  If $[[ Th | G[y: T1 + T2] | B |- let x = y in e : T => G' \ x]]$, then $[[ Th | G [ y <- T1 /\ y y = T1 x  ], x : (T2 /\ x x = T2 y) | B |- e : T => G']] \land
  [[B |- T => G' \ x]]$.
  \end{rneqncase}
  \begin{rneqncase}{T-LetInt}\newline
  If $[[ Th | G, x:{x : int | x = nn } | B |- e : T => G']] \land
  [[B |- T => G' \ x]]$, then $[[ Th | G | B |- e : T => G' \ x]]$.
  \end{rneqncase}
  \begin{rneqncase}{T-If}\newline
  If $[[ Th | G[x : {y:int|ph}] | B |- ifz y then e1 else e2 : T => G' ]]$, then $[[ Th | G[x <- {y:int | ph /\ y = 0 }] | B |- e1 : T => G' ]]$ or
  $[[ Th | G[x <- {y:int | ph /\ y != 0}] | B |- e2 : T => G' ]]$.
  \end{rneqncase}
  \begin{rneqncase}{T-MkRef}\newline
  If $[[ Th | G[y : T1 + T2] | B |- let x = mkref y in e : T => G' \ x ]]$, then $[[ Th | G[y <- T1],x : (T2 /\ x x = T2 y) ref 1 | B |- e : T => G']] \land
  [[ B |- T => G' \ x ]]$.
  \end{rneqncase}
  \begin{rneqncase}{T-Deref}\newline
  If $[[ Th | G[y: (T1 + T2) ref r] | B |- let x = *y in e : T => G' \ x ]]$, then $[[r > 0]] \land
  [[ Th | G[y <- (T1 /\ y y = T1 x) ref r], x : T2 | B |- e : T => G']] \land
  [[ B |- T => G' \ x ]]$.
  \end{rneqncase}
  \begin{rneqncase}{T-Call}\newline
  If $[[ Th | G[yi: csub vsub Ti] | B |- let x = f l (y1,,yn) in e : T' => G' \ x]]$, then $[[ Th(f) = A < x1 : T1 ,, xn : Tn > -> <x1: T1' ,, xn : Tn' | T > ]] \land\\
  [[csub = [l:B/A] ]] \land [[ vsub = [y1/x1] ,, [yn/xn] ]] \land\\
  [[ Th | G[yi <- csub vsub Ti'], x : csub vsub T | B |- e : T' => G' ]] \land\\
  [[ B |- T' => G' \ x]]$.
  \end{rneqncase}
  \begin{rneqncase}{T-Assign}\newline
  If $[[ Th | G[x: T1 + T2][y : T' ref 1] | B |- y := x; e : T => G']]$, then $(\text{The shapes of $[[T']]$ and $[[T2]]$ are similar}) \land\\
  [[ Th | G[x <- T1][y <- T2 ref r /\ y y = T1 x] | B |- e : T => G']]$.
  \end{rneqncase}
  \begin{rneqncase}{T-Alias}\newline
  If $[[ Th | G[x : T1 ref r1][y: T2 ref r2] | B |- alias(x = y); e : T => G' ]]$, then $[[(T1 ref r1 + T2 ref r2) = (T1' ref r1' + T2' ref r2')]] \land\\
  [[ Th | G[x <- T1' ref r1'][y <- T2' ref r2'] | B |- e : T => G']]$.
  \end{rneqncase}
  \begin{rneqncase}{T-Assert}\newline
  If $[[ Th | G | B |- assert(ph); e : T => G']]$, then $[[ G |= ph ]] \land
  [[ Th | G | B |- e : T => G' ]]$.
  \end{rneqncase}
\end{lemma}
\begin{proof}
  By induction of the typing relation.
\end{proof}


\begin{lemma} \bf{Substitution}
  \label{lem:substitution}
  If $\funenv \mid \tenv\mid \beta\vdash e \COL \tau  \produces \tenv'$, we can obtain
  $\funenv \mid [x'/x]\tenv \mid \beta \vdash [x'/x]e \COL [x'/x]\tau \produces [x'/x]\tenv'$.
\end{lemma}
\begin{proof}
  By straightforward induction of typing rules.
\end{proof}




\begin{lemma}\label{lem:ctxt-sub-distribute}
  $[[ T3 = T1 + T2  ==> [B/A]T3 = [B/A]T1 + [B/A]T2 ]]$
\end{lemma}
\begin{proof}
  By straightforward cases analysis on the definition of $[[ T1 + T2 ]]$.
\end{proof}

\begin{lemma}\label{lem:ctxt-sub-wf}
  For any $[[ B ]]$:
  \begin{enumerate}
  \item $[[ A |- G ==> B |- [B / A]G]]$
  \item $[[ G | A |- T ==> [B/A]G | B |- [B/A]T]]$
  \item $[[ A |- T => G ==> B |- [B/A] T => [B/A]G ]]$
  \end{enumerate}
\end{lemma}
\begin{proof}
  Observe that for any substitution $[[ [B/A] ]]$, $[[ST([B/A]G) = ST(G)]]$, whence it suffices
  to show that $[[ FPCV ( [B/A]ph ) ]] \subseteq [[CV(B)]]$ for any refinement $[[ph]]$
  appearing in of $[[T]]$ or a type in $[[G]]$.

  By the assumed well-formedness of $[[T]]$ with respect to context
  variable $[[A]]$ (resp. $[[G]]$), after substitution all free
  context variables in $[[T]]$ (resp. the types in $[[G]]$) will be
  replaced with $[[B]]$. Thus, post-substitution any free context
  variables in the refinement of $[[ [B/A] T]]$ (resp. refinements of
  types in $[[ [B/A] G]]$) will be the context variables that appear
  in $[[B]]$, trivially satisfying our requirement.
\end{proof}

\begin{lemma}
  \label{lem:ctxt-sub-subtype}
  For any $[[G]]$, $[[T1]]$, $[[T2]]$, $[[A]]$ and $[[B]]$, $[[ G |- T1 <: T2 ==> [B/A]G |- [B/A]T1 <: [B/A]T2 ]]$.
\end{lemma}
\begin{proof}
  If $[[A]]$ does not appear free in $[[T1]]$, $[[T2]]$ or $[[G]]$, then the result trivially holds. Let us then assume
  $[[A]]$ appear free. We prove the result by induction on the subtyping derivation.

  \begin{rneqncase}{Sub-Ref}{
      [[ T1 = T1' ref r1 ]] & [[ T2 = T2' ref r2 ]] \\
      [[ [B/A] T1 = ([B/A]T1') ref r2 ]] & [[ [B/A]T2 = ([B/A]T2') ref r2 ]] \\
      [[  r2 > 0 ==> G |- T1' <: T2' ]]
    }
    If $[[ r2 = 0 ]]$ then the result trivially holds. If not, we must show that $[[ [B/A]G |- [B/A]T1' <: [B/A]T2' ]]$
    which holds immediately from the induction hypothesis.
  \end{rneqncase}

  \begin{rneqncase}{Sub-Int}{
      [[ T1 = {x:int|ph1} ]] & [[ T2 = {y:int|ph2} ]] \\
      [[ [B/A]T1 = {x:int|[B/A]ph1 } ]] & [[ [B/A]T2 = {y:int|[B/A]ph2 } ]] \\
      [[ G |= ph1 ==> ph2 ]]
    }
    We must show that $[[ [B/A]G |= [B/A]ph1 ==> [B/A]ph2 ]]$, i.e. $[[ |= [ [B/A]G ] /\ [B/A]ph1 ==> [B/A]ph2 ]]$.
    From our assumption that $[[ G |= ph1 ==> ph2 ]]$ we have that $[[ |= [ G ] /\ ph1 ==> ph2 ]]$ is valid,
    whence the formula $[[ [ G ] /\ ph1 ==> ph2 ]]$ is true for any possible valuation of the free context
    variable $[[A]]$. Thus the formula $[[ [ [B/A]G ] /\ [B/A]ph1 ==> [B/A]ph2 ]]$ must also be valid.
  \end{rneqncase}
\end{proof}

\begin{lemma}
  \label{lem:ctxt-subst-well-typed}
  \begin{align*}
    & [[ Th | G | A |- e : T => G' ]] \Longrightarrow\\
    & [[ Th | [ ll / A ] G | ll |- e : [ ll / A ] T => [ ll / A ] G' ]]
  \end{align*}
\end{lemma}
\begin{proof}
  By induction on the typing derivation $[[ Th | G | A |- e : T => G' ]]$. In the following
  analysis, we will freely use the identity $[[([B/A]G) \ x = [B/A](G \ x)]]$.
  \begin{rneqncase}{T-Var}{
      [[e = x]] & [[T = T2]] \\
      [[G = G0[x : T1 + T2] ]] & [[ G' = G0[x <- T2] ]]
    }
    By application of \cref{lem:ctxt-sub-distribute}.
  \end{rneqncase}
  \begin{rneqncase}{T-LetInt}{
      [[e = let x = nn in e']] & [[ Th | G, x:{x:int|x = nn} | A |- e' : T => G'' ]] \\
      [[ G' = G'' \ x ]] &
    }
    The induction hypothesis gives
    \[
      [[ Th | [ll/A]G, x:{x:int|x=nn} | ll |- e : [ll/A]T => [ll/A]G'' ]]
    \]
    \cref{lem:ctxt-sub-wf} gives $[[ ll |- [ll/A]T => [ll/A](G'' \ x) ]]$, from which we
    conclude $[[ Th | [ll/A]G | ll |- let x = nn in e : [ll/A]T => [ll/A](G'' \ x) ]]$
    as required.
  \end{rneqncase}

  \begin{rneqncase}{T-Let}{
      & [[e = let x = y in e']] & [[ G' = G'' \ x ]] \\
      & [[ Th | G1 | A |- e' : T => G'' ]] & [[ G1 = G[y <- (T1 /\ y y = T1 x)], x:(T2 /\ x x = T2 y)]] \\
      & [[ G = G0[y: T1 + T2]  ]]
    }
    By \cref{lem:ctxt-sub-distribute},
    $[[ ([ll/A]G)(y) = [ll/A](T1 + T2) = ([ll/A]T1 + [ll/A]T2) ]]$. We must then
    show that $[[ Th | G1' | ll |- e : [ll/A]T => [ll/A]G'' ]]$
    where
    \[
      [[ G1' = ([ll/A]G)[y <- [ll/A]T1 /\ y y = x ],x:([ll/A]T2 /\ x x = y) ]]
    \]
    As $[[G1' = [ll/A]G1]]$ the induction hypothesis gives the required typing judgment.
    That $[[ll |- [ll/A]T => [ll/A]G'' ]]$ follows from \cref{lem:ctxt-sub-wf} as in the \rn{T-LetInt}
    case.
  \end{rneqncase}

  \begin{rncase}{T-If,T-Seq}
    By trivial application of the inductive hypothesis.
  \end{rncase}

  \begin{rncase}{T-MkRef,T-Deref}
    By reasoning similar to \rn{T-Let}.
  \end{rncase}

  \begin{rneqncase}{T-Call}{
      [[ vsub = [y1/x1] ,, [yn/xn] ]] \\
      [[ csub = [l:A/A'] ]] \\
      [[ Th | G1 | A |- e : T => G2 ]] \\ [[ G' = G2 \ y ]] \\
      [[ A |- T => G2 \ y  ]] \\
      [[ Th(f) = A' < x1 : T1 ,, xn : Tn > -> <x1: T1' ,, xn : Tn' | T' > ]]  \\
      [[ G1 = G[yi <- csub vsub Ti'], x : csub vsub T' ]]
    }
    We must first show that for $[[ csub' = [l:ll/A'] ]]$:
    \[
      [[  Th | G3 | ll |- e : [ll/A]T => [ll/A]G2 ]]
    \]
    where $[[ G3 = ([ll/A]G)[yi <- csub' vsub Ti'], x: csub' vsub T']]$.

    We first observe that $[[ G3 = [ll/A]G1 ]]$ (this follows from the
    equivalence of $[[ [ll/A][l:A/A'] ]]$ and
    $[[ [l:ll / A'] ]]$) whence the induction hypothesis
    gives the required typing derivation.

    We must also show that
    $\forall i \in \set{1..n}.[[([l:ll/A]G)(yi) = csub' vsub Ti]]$.
    From the assumed well-typing of the term under $[[A]]$ we have
    that $\forall i \in\set{1..n}.[[csub G(yi) = csub vsub Ti]]$. Recall
    that $[[csub']]$ is equivalent to $[[ [ll/A] csub ]]$, whence we have
    $[[ [ll/A] csub G(yi) = [ll/A] csub vsub Ti]]$ for any $[[i]]$ as
    equality is preserved by consistent substitution.

    That $[[ ll |- [ll/A]T => [ll/A](G2 \ y) ]]$ holds from application of
    \cref{lem:ctxt-sub-wf}.
  \end{rneqncase}

  \begin{rncase}{T-Assign,T-Alias}
    By the inductive hypothesis and application of \cref{lem:ctxt-sub-distribute}.
  \end{rncase}

  \begin{rneqncase}{T-Sub}{
      [[ Th | G1 | A |- e : T1 => G2 ]] & [[ G <: G1 ]] \\
      [[ G2, x : T1 <: G',x : T ]] & [[ Th | G | A |- e : T => G' ]]
    }
    By the induction hypothesis we have that: $[[ Th | [ll/A]G1 | ll |- e : [ll/A]T1 => [ll/A]G2 ]]$.
    If we show that $[[ [ll/A]G <: [ll/A]G1 ]]$ and $[[ [ll/A]G2, x : [ll/A]T1 <: [ll/A]G', x : [ll/A]T ]]$
    ($[[ x not in G ]]$)
    we will have the required result. To show the first requirement, for any $[[ x in G ]]$ we have that
    $[[ [ll/A]G |- [ll/A]G(x) <: [ll/A]G1(x) ]]$ from \cref{lem:ctxt-sub-subtype} whence we have $[[ [ll/A]G <: [ll/A]G1 ]]$.
    To show the latter requirement, we observe that $[[ [ll/A]G2, x : [ll/A]T1 ]]$ is equivalent to $[[ [ll/A](G2, x : T1) ]]$ and
    similarly for $[[G']]$ and $[[T]]$ whence we have the required subtyping relationship from the application of \cref{lem:ctxt-sub-subtype}.
  \end{rneqncase}
\end{proof}

\begin{lemma}
  \label{lem:ectxt-sub-well-typed}
  If, for some $[[G]]$,
  $[[ Th | [] : T => G' | B |-e E : T'' => G'']]$ and $[[Th | G | B |- e : T => G' ]]$
  then
  $[[ Th | G | B |- E[e] : T'' => G'' ]]$.
\end{lemma}
\begin{proof}
  By induction on the typing derivation of $[[E]]$.
  \begin{rneqncase}{TE-Seq}{
      [[ E ]] = [[ E'; e' ]] \\ [[ E[e] = E'[e]; e' ]] \\
      [[ Th | [] : T => G' | B |-e E' : T0 => G0 ]] & [[ Th | G0 | B |- e' : T'' => G'' ]]
    }
    By the induction hypothesis we have $[[ Th | G | B |- E'[e] : T0 => G0 ]]$. Combined
    with the assumption $[[ Th | G0 | B |- e' : T'' => G'' ]]$ the result holds
    via application of the proof rule \rn{T-Seq}.
  \end{rneqncase}
  \begin{rncase}{TE-Hole}
    Trivial.
  \end{rncase}
\end{proof}

\begin{lemma}
  \label{lem:stack-well-typed}
  For any $[[G0]]$ such that $[[Th | G0 | l:ll |- x: T => G]]$ and $[[ Th | [] : T => G | ll |-e E[let y = [] l in e] : T' => G' ]]$ then
  $[[ Th | G0 | ll |- E[let y = [] l in e][x] : T' => G' ]]$
\end{lemma}
\begin{proof}
  It suffices to show that $[[ Th | G0 | ll |- let y = x in e : T1 => G1]]$
  and $[[ Th | [] : T1 => G1 | ll |-e E : T' => G']]$
  whence the result will hold from \cref{lem:ectxt-sub-well-typed}.

  By inversion on
  $[[ Th | [] : T => G | ll |-e E[let y = [] l in e] : T' => G' ]]$ and
  $[[ Th | G0 | l:ll |- x : T => G]]$ we have that:
  \begin{align}
    & [[ Th | G, y: T | ll |- e : T2 => G2 ]] \\
    & [[ Th | []: T2 => G2 \ y | B |-e E : T' => G' ]] \\
    & [[ ll |- T2 => G2 \ y ]] \\
    & [[ G0(x) = T + T' ]] \\
    & [[ G = G0[x <- T'] ]]
  \end{align}
  We take $[[ G1 = G2 \ y ]]$, $[[ T2 = T1 ]]$. To show that
  $[[ Th | G0[x : T + T'] | ll |- let y = x in e : T1 => G1 ]]$ it
  remains to show that
  $[[Th | G0[x <- T' /\ x x = y],y : T /\ y y = x | ll |- e : T2 =>
  G2]]$ and that $[[ ll |- T2 => G2 \ y]]$.
  The former follows from first weakening the types of $[[x]]$ and $[[y]]$ with \rn{T-Sub}
  and from assumption (1), and the latter follows from (3).
\end{proof}

\begin{lemma}
  \label{lem:stack_var}
  For any $[[E]]$ and $[[e']]$ such that $[[E[e'] = e]]$ where
  $[[Th | G | B |- e : T => G']]$ there exists some $[[T0]]$, $[[G0]]$ such that
  $[[Th | []: T0 => G0 | B |-e E : T => G' ]]$ and
  $[[Th | G | B |- e' : T0 => G0]]$.
\end{lemma}
\begin{proof}
  By induction on the structure of $[[E]]$.
  \begin{rncase}{E-Hole}
    Trivial, by taking $[[T1 = T]]$ and $[[G' = G1]]$.
  \end{rncase}
  \begin{rncase}{E-Seq}
    Then $[[E = E'; e'']]$ and $[[E[e'] = E'[e']; e'' = e]]$, whence
    $[[e = e1; e2]]$ where $[[E'[e'] = e1]]$ and $[[e'' = e2]]$. By
    inversion on the typing derivation of $[[e]]$ we have
    $[[ Th | G | B |- e1 : T1 => G1]]$,
    $[[Th | G1 | B |- e2: T => G']]$. By the induction hypothesis
    we then have $[[ Th | G | B |- e' : T0 => G0 ]]$ and
    $[[ Th | []: T0 => G0 | B |-e E' : T1 => G1 ]]$. Exploiting the equality
    between $[[e2 = e'']]$, we use the proof rule \rn{TE-Seq}
    to conclude $[[ Th | []: T0 => G0 | B |-e E'; e'' : T => G']]$.
  \end{rncase}
\end{proof}

\begin{lemma}[Environment Weakening]
  \label{lem:tyenv-weaken}
  For any $[[G]]$ and $[[ G'' ]]$ such that $[[dom G sub dom G'']]$ and $[[ forall x in dom G.G(x) = G''(x)]]$.
  \begin{enumerate}
  \item $[[ G |- T1 <: T2 ==> G'' |- T1 <: T2 ]]$
  \item $[[G <: G' ==> G'' <: G''']]$ where $[[forall x in dom G'.G'''(x) = G'(x) /\ forall x not in dom G'.G'''(x) = G''(x)]]$.
  \item Let $[[ Th | G | B |- e : T => G' ]]$. Then $[[ Th | G'' | B |- e : T => G''']]$ where
    $[[G''' = G''[xi <- G'(xi)] ]]$ ($[[xi in G']]$).
  \end{enumerate}
\end{lemma}
\begin{proof}
  \begin{enumerate}
  \item As in the proof of \cref{lem:ctxt-sub-subtype}, at the root of
    the subtyping derivation is a logical judgment of the form
    $[[ |= [ G ] /\ ph1 ==> ph2 ]]$ which can be shown to be valid. We
    must then show that $[[ |= [ G'' ] /\ ph1 ==> ph2 ]]$ is valid. As
    $[[ [ G'' ] /\ ph1 ]]$ only strengthens the pre-condition
    $[[ [ G ] /\ ph1 ]]$, the $[[ |= [ G'' ] /\ ph1 ==> ph2 ]]$ must
    also be valid.
  \item It suffices to show that $[[G'' |- G''(x) <: G'''(x)]]$ for
    any arbitrary $[[x]]$. If $[[x in G']]$ then by we must have
    $[[ G |- G(x) = G''(x) <: G'''(x) = G'(x) ]]$, whence $[[ G'' |- G''(x) <: G'''(x) ]]$ from
    part 1.

    If $[[ x not in G' ]]$, then $[[empty |- G''(x) <: G'''(x)]]$ and the result holds
    again from part 1.
  \item By straightforward induction on the typing derivation of
    $[[ Th | G | B |- e : T => G' ]]$. The only interesting cases are
    \rn{T-Sub} and \rn{T-Assert}. \rn{T-Sub} follows from using parts
    1 and 2.  \rn{T-Assert} requires showing that
    $[[ |= [G''] ==> ph ]]$. As the source term was well typed,
    $[[ |= [G] ==> ph ]]$ is valid, and as $[[ [G''] ]]$ only
    strengthens the hypothesis $[[ [G] ]]$, $[[ |= [G''] ==> ph]]$ must
    also be valid.
  \end{enumerate}
\end{proof}

\begin{lemma}
  Let $[[ E[let x = f l (y1,,yn) in e'] ]]$ be a term in a program
  $[[ <D, e> ]]$ such that:
  \label{lem:callfunc}
  \begin{bcpcasearray}
    [[ Th | G0 | ll |- let x = f l (y1,,yn) in e' : T1 => G1 ]] &  [[ csub = [l:ll/A] ]] \\
    [[ Th | [] : T1 => G1 | ll |-e E : T2 => G2 ]] & [[ vsub = [y1/x1],,[yn/xn] ]] \\
    [[ f |-> ( x1, .. ,xn) e' in D]] & [[ Th |- f |-> (x1,..,xn) e ]] \\
  \end{bcpcasearray}

  where $[[Th(f) = A < x1 : T1 ,, xn: Tn> -> <x1: T1',,xn:Tn' | Tp >]]$.

  Then: \begin{align*}
    & [[ Th | G0 | l:ll |- vsub e : csub vsub Tp => G0[yi <- csub vsub Ti'] ]] \\
    & [[ Th | [] : csub vsub Tp => G0[yi <- csub vsub Ti] | ll |-e E[let x = [] l in e] : T2 => G2 ]]
  \end{align*}
\end{lemma}
\begin{proof}
  To prove the first part, from the well-typing of the function body, we have
  $[[ Th | x1:T1,,xn:Tn | A |- e : Tp => x1:T1',,xn:Tn' ]]$.
  By $n$ applications of the substitution lemma we have:
  $[[ Th | y1:vsub T1,,yn:vsub Tn | A |- vsub e : vsub Tp => y1:vsub T1',,yn:vsub Tn']]$.
  By \cref{lem:ctxt-subst-well-typed} we then have
  $[[ Th | y1:csub vsub T1,,yn:csub vsub Tn | l:ll |- vsub e : csub vsub Tp => y1:csub vsub T1',,yn:csub vsub Tn']]$.
  By \cref{lem:tyenv-weaken} and the well-typing of the function call we have
  $[[ Th | G0 | l:ll |- vsub e : csub vsub Tp => G0[yi <- csub vsub Ti ] ]]$ as required.

  The second part follows immeidately by inversion on the typing of
  $[[E]]$ and $[[let x = f l (y1,,yn) in e' ]]$.
\end{proof}
\section{TODO}

\begin{itemize}
\item Running example.
\item Context-Sensitiveness example. (Look at the JayHorn paper and Naoki's note.)
\item Some missing definitions, especially $\Gamma \models \varphi$.  (This can be done by reading previous work about refinement-type based static verification.  Ask Atsushi or Naoki which paper to look at.)
\item Soundness statement.
\item Extension to "general" references: e.g., $\set{r : \TINT \mid \varphi} \TREF^1 \TREF^1 \TREF^1$ or $\mu\alpha. \set{r : \TINT \mid \varphi} \TREF^1$.
\item Inference (constraint generation) algorithm.
\item Experiments?
\end{itemize}

\newcommand\DOM{\textit{dom}}
\newcommand\EXTEND[1]{\{{#1}\}}

\begin{figure}
  \leavevmode
  \infrule[TE-Seq]{
    [[ Th | [] : T => G | B |-e E : T' => G' ]] \andalso
    [[ Th | G' | B |- e : T'' => G'' ]]
  }{
    [[ Th | [] : T => G | B |-e E; e : T'' => G'' ]]
  }
  \infrule[TE-Hole]{}{
    [[ Th | [] : T => G | B |-e [] : T => G ]]
  }
  \infrule[TE-Stack]{
    [[ Th | [] : T' => G' | B |-e E : T'' => G'']] \\
    [[ Th | G, x : T | B |- e : T' => G0 ]] \\
    [[ G' = G0 \ x ]] \andalso [[ B |- T' => G0 \ x ]]
  }{
    [[ Th | [] : T => G | B |-e E[let x = [] l in e] : T'' => G'' ]]
  }

  \begin{align*}
    [[ (E; e)[e'] ]] & = [[ E[e']; e ]] \\
    [[ [][e'] ]] & = e' \\
    [[ E[let y = [] l in e][x] ]] & = [[ E[let y = x in e] ]]
  \end{align*}
\caption{Context typing and substitution}
\label{fig:context-typing}
\end{figure}

\begin{figure}
  \leavevmode
  \infrule[]{
    [[ll = Trace(Es)]] \andalso [[ Th |- D ]] \andalso \forall j \in \set{0..n-1}.\seq{\ell_j} = tail^{n-j+1}([[ll]]) \\
    [[ Cons(H, R, G) ]] \andalso
    \forall i\in\set{1..n}.[[ Th | [] : Ti => Gi | lli-1 |-e Ei-1 : Ti-1 => Gi-1 ]] \\
    [[ Th | [] : T => G' | ll |-e En : Tn => Gn ]] \\
    [[ Th | G | ll |- e : T => G' ]]
  }{
    [[ |- D <H,R,Es,En[e]> ]]
  }

  \begin{align*}
    [[Trace(.) = .]] && [[Trace(E[let x = [] l in e] : Es) = l : Trace(Es)]])
  \end{align*}

  \begin{align*}
    [[Cons(H,R,G)]] = & [[SAT(H,R,G)]] \wedge [[forall a in H.F(a)]] \leq 1 \\
    [[SAT(H,R,G)]] = & [[ forall x in G.x in R /\ SATv(H,R,R(x),G(x)) ]] \\
    [[SATv(H,R,Rv,T)]] = & \begin{cases}
      [[Rv is INT /\ [R ; Rv / y]ph ]] & [[ T = {y:int|ph} ]] \\
      [[r > 0 ==> a in H /\ SATv(H,R,H(a),T')]] & [[ T = T' ref r /\ Rv = a ]]
    \end{cases} \\
    [[ [empty; v / x]ph ]] & = [[ [v/x]ph ]] \\
    [[ [R { y |-> nn }; v / x]ph ]] & =  [[ [nn/y] [R ; v / x]ph ]] \\
    [[ [R { y |-> a }; v / x]ph ]] & =  [[ [R ; v / x]ph ]] \\
    F = &  \Sigma_{[[ x in G ]]}\,[[own(H,R(x),G(x))]] \\
    [[own(H,v,T)]] &  = \begin{cases}
      [[ { a |-> r } + own(H,H(a),T') ]] & [[v = a /\ a in H /\ T = T' ref r ]] \\
      \emptyset & o.w.
    \end{cases} \\
  \end{align*}
\caption{Machine state typing}
\label{fig:state-typing}
\end{figure}

%edit by shiki
\begin{figure}[t]
  \leavevmode
  \infrule[R-Var]{
  }{
    [[ <H, R, CE : Es, x> --> D <H, R, Es, CE[x]> ]]
   }
   \infrule[R-Seq]{
   }{
     [[ <H, R, CE : Es, E[x; e]> --> D <H, R, Es, E[e]> ]]
  }
  \infrule[R-Let]{
    [[ x' fresh in R ]]
  }{
    [[<H, R, Es, E[let x = y in e]> --> D <H, R { x' |-> R(y)}, Es, E[ [x'/x]e]> ]]
  }
  \infrule[R-LetInt]{
    [[ x' fresh in R ]]
  }{
    [[ <H,R,Es,E[let x = nn in e]> --> D <H,R { x' |-> nn},Es, E[ [x'/x]e]>]]
  }
  \infrule[R-IfTrue]{
    [[ R(x) = 0 ]]
  }{
    [[ <H, R, Es, E[ifz x then e1 else e2]> --> D <H, R, Es, E[e1]> ]]
  }
  \infrule[R-IfFalse]{
    [[ R(x) != 0 ]]
  }{
    [[ <H, R, Es, E[ifz x then e1 else e2]> --> D <H, R, Es, E[e2]> ]]
  }
  \infrule[R-MkRef]{
    [[ a fresh in H ]] \andalso [[ x' fresh in R ]]
  }{
    [[ <H, R, Es, E[let x = mkref y in e]> --> D <H { a |-> R(y) }, R { x' |-> a }, Es, E[ [x'/x]e]> ]]
  }
  \infrule[R-Deref]{
    [[ R(y) = a ]] \andalso [[ H(a) = v ]] \andalso [[ x' fresh in R ]]
  }{
    [[ <H, R, Es, E[let x = *y in e]> --> D <H, R { x' |-> v }, Es, E[ [x'/x]e]> ]]
  }
  \infrule[R-Call]{
    [[ f |-> (x1,..,xn) e in D ]]
  }{
    [[ <H, R, Es, E[let x = f l (y1,,yn) in e']> --> D <H, R, E[let x = [] l in e'] : Es, [y1/x1] ,, [yn/xn] e> ]]
  }
  \infrule[R-Assign]{
    [[ R(x) = a ]] \andalso [[ a in H ]]
  }{
    [[ <H, R, Es, E[x:=y;e]> --> D <H { a <- R(y) }, R, Es, E[e]> ]]
  }
  \infrule[R-Alias]{
    R(x) = R(y)
  }{
    [[ <H, R, Es, E[alias(x = y); e]> --> D <H, R, Es, E[e]> ]]
  }
  \infrule[R-AliasFail]{
    [[R(x) != R(y)]]
  }{
    [[ <H, R, Es, E[alias(x = y); e]> --> D AliasFail ]]
  }
  \infrule[R-Assert]{
    [[ R |= ph ]]
  }{
    [[ <H, R, Es, E[assert(ph); e]> --> D <H, R, Es, E[e]> ]]
  }
  \infrule[R-AssertFail]{
    [[ R !|= ph ]]
  }{
    [[ <H, R, Es, E[assert(ph); e]> --> D AssertFail ]]
  }
\caption{Transition Rules.}
\label{fig:transitionRules}
\end{figure}



\bibliographystyle{plain}
\bibliography{main.bib}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
