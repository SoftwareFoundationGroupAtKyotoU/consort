\section{Preliminaries}
\label{sec:prelim}
This section describes a simple imperative language with mutable references and first-order, recursive functions.

% \subsection{Notation}
% For a (meta-level, set-theoretic) function $f$ we will write $\DOM(f)$ to indicate the domain of
% the function and write
% $f \{ x \mapsto v \}$ where $x \not\in\DOM(f)$ to denote a map
% which takes all values in $\DOM(f)$ to their values in $f$ and which
% additionally takes $x$ to $v$. We will write $ f \{ x \hookleftarrow v \}$
% where $x\in\DOM(f)$ to denote a map equivalent to $f$ except that $x$ takes value $v$.
% We also write $\emptyset$ as a function with an empty domain.
% \JT{This is almost certainly not a sufficient overview. write more later.}
\AI{Notations are moved.  $f$ conflicted with the metavariable for function names and I thought it might be confusing.}

\subsection{Language}
\label{sec:language}
We assume a set of \emph{variables}, ranged over by $x,y,z,\dots$,
a set of \emph{function names}, ranged over by $f$, and
a set of labels ranged over by $[[l1]], [[l2]], \dots$.
The grammar of the language is as follows.
\[
  \begin{array}{rcl}
  [[d]] &::=& [[f |-> (x1,...,xn)e ]] \\
  [[e]] &::= &
               [[ x ]] \mid
               [[ let x = y in e]] \mid
               [[ let x = nn in e ]] \mid
               [[ ifz x then e1 else e2 ]] \\
        &\mid& [[ let x = mkref y in e ]] \mid
               [[ let x = *y in e ]] \mid
               [[ let x = f l (y1 ,, yn) in e ]] \\
        &\mid& [[ x := y ; e ]] \mid
               [[ alias(x = y); e ]] \mid
               [[ alias(x = *y); e ]] \mid
               [[ assert(ph); e ]] \mid
               [[ e1;e2 ]] \\
%    [[v]] &::=& [[nn]] \mid [[x]] \\
    [[P]] &::=& [[<{d1,...,dn}, e>]] %\\
%    [[l]] &\in& \textbf{Labels}\\
  \end{array}
\]
$[[ph]]$ stands for a formula in propositional first-order
logic over variables, integers and contexts;
we discuss these formulas later in \Cref{sec:types}.
\AI{\textbf{Labels} is removed because it is rarely used.}

Variables are introduced by function parameters or let bindings.
Like ML, the variable bindings introduced by let-expressions and parameters
are immutable.
A mutable variable declaration like \texttt{int x = 1;} in C is achieved with
\[
  [[ let y = 1 in (let x = mkref y in etc) ]]
\]
in our language. As a convenience, we assume all variable names
introduced with let bindings and function parameters are distinct.

Unlike ML (and like C or Java) we do not allow general expressions on the right hand side of
let bindings. The simplest right hand forms are a variable $[[y]]$ or an integer literal $[[nn]]$.
$[[mkref y]]$ creates a reference cell with value $[[y]]$, and
$[[*y]]$ accesses the contents of reference $[[y]]$. For simplicity,
we do not include an explicit null value.
Function calls must occur on the right hand side of a variable binding
and take the form $[[f l (x1,,xn)]]$, where $[[x1,,xn]]$ are distinct variables and $[[l]]$ is a
(unique) label.% drawn from \textbf{Labels}.
These labels are used to make our type system for context sensitive as
discussed in \Cref{sec:cs}.

The single base case for expressions is a single variable.
If the variable expression is executed in a tail position of a function
then the value of that variable is the return value of the function,
otherwise the value is ignored.

The only control-flow operation in our language are if statements.
$[[ifz]]$ checks whether the condition variable $[[x]]$ equals zero and chooses
the corresponding branch. Loops can be implemented with recursive functions and
we do not include them explicitly in our formalism.

Our grammar requires that side-effecting, result free statements, \lstinline{assert}($[[ph]]$)
\lstinline{alias}($[[x]]$ = $[[y]]$), \lstinline{alias}($[[x]] = *[[y]]$) and
assignment $[[x]] := [[y]]$ are followed by a continuation expression.
We impose this requirement for technical reasons to ease our formal
presentation; this requirement does not reduce expressiveness
as dummy continuations can be inserted as needed.
The $[[assert(ph); e]]$ form executes $[[e]]$ if the predicate
$[[ph]]$ holds in the current state and aborts the program otherwise.
$[[alias(x = y); e]]$ asserts a must-aliasing relationship $x$ and $y$.
\imp{alias} statements \KS{Statement \imp{alias}?}
are effectively \emph{annotations} that our type system exploits to gain
added precision.
$[[ x := y ; e ]]$ updates the contents of the memory cell pointed to by $[[x]]$
with the contents of $[[y]]$.
In addition to the above continuations, our language supports general sequencing with
$[[e1 ; e2]]$.

\begin{remark}
  Although we include \imp{alias} annotations in the
  source language for expository purposes, we expect that practical implementations
  may use also implicit annotations provided by a conservative must-alias analysis.
  \JT{That we mention must-alias analyses here seems to contradict our claim in
    the intro.}
  \AI{This will be resolved after we settle down the introduction.}
  \JT{What is the preference for remark vs. footnote?}
  \AI{I don't have a strong preference.  A footnote saves more space?}
\end{remark}

A program is a pair $[[<D, e>]]$, where
$[[ D = {d1,...,dn} ]]$ is a set of first-order, mutually recursive function definitions, and $[[e]]$
is the program entry point. A function definition $[[d]]$
maps the function name to a tuple of argument names $[[x1,...,xn]]$
that are
bound within the function body $[[e]]$.

\paragraph{Paper Syntax}
In the remainder of the paper, we will write programs that
are technically illegal according to our grammar, but can be
easily ``de-sugared'' into an equivalent, valid program.
For example, we will write
\begin{lstlisting}
  let x = mkref 4 in assert(*x = 4)
\end{lstlisting}
as syntactic sugar for:
\begin{lstlisting}
  let f = 4 in let x = mkref f in
  let tmp = *x in assert(tmp = 4); let dummy = 0 in dummy
\end{lstlisting}
%We have used a dummy continuation for the assert statement in the desugaring.

% \begin{figure}[t]
% \[
%   \begin{array}{rcl}
%     [[ E ]] & ::= & [[ E'; e ]] \mid [[ [] ]] \\
%     [[ CE ]] & ::= & [[ E[let y = [] l in e] ]]
%   \end{array}
% \]
% \caption{Grammar of evaluation and return contexts}
% \label{fig:eval-context-grammar}
% \end{figure}

\input{semantics}

\subsection{Operational Semantics}
\label{sec:semantics}
We now introduce the operational semantics for our language.
We assume a finite domain of heap addresses \textbf{Addr}:
we denote an arbitrary address with $[[a]]$.
A runtime state is represented by a configuration $[[<H, R,Es,e>]]$, which consist of a heap,
register file, stack, and currently reducing expression respectively.
The register file maps variables to runtime values $[[Rv]]$, which are
either integers $[[nn]]$ or addresses $[[a]]$. The heap maps a subset
of addresses to runtime values. The runtime stack represents pending
function calls as a sequence of return contexts which we
describe below.
While the final configuration component is an expression,
the rewriting rules are defined in terms of $[[ E[e] ]]$, which is
an evaluation context $[[E]]$ and redex $[[e]]$, as is standard.
The grammar for evaluation contexts and return contexts $[[CE]]$ are defined by: 
% in \Cref{fig:eval-context-grammar}.
\(
    [[ E ]]  ::=  [[ E'; e ]] \mid [[ [] ]].
  \)

Our operational semantics is given in \Cref{fig:transitionRules1,fig:transitionRules2}.
We write $[[dom H]]$ to indicate the domain of
the function and $[[H { a |-> Rv }]]$ where $a \not\in\DOM(H)$ to denote a map
which takes all values in $\DOM(H)$ to their values in $H$ and which
additionally takes $[[a]]$ to $[[Rv]]$.
We will write $ [[H { a <- Rv }]]$
where $a\in\DOM(H)$ to denote a map equivalent to $[[H]]$ except that $[[a]]$ takes value $[[Rv]]$.  Similarly for $dom R$ and $[[R{x |-> Rv}]]$.
We also write $\emptyset$ for the empty register file and heap.
%
Notice that the step relation  $[[ --> D ]]$ is parameterized
by a set of function definitions $[[D]]$; a program $[[<D, e>]]$ is executed
by stepping the initial context $[[ <empty,empty,.,e> ]]$ according
to $[[-->]]_{[[D]]}$.
The semantics are mostly standard; we highlight some important points below.

First we introduce return contexts $[[CE]]$, which
take the form $[[ E[let y = [] l in e] ]]$. A return context represents a pending
function call with label $[[l]]$, and indicates that the return value of the
callee should be bound to $[[y]]$ in $[[e]]$ within the larger exectuion context $[[E]]$.
The call stack $[[Es]]$ is a sequence of these contexts, with
the first such return context indicating the most recent function call.
The stack grows at function calls as described by rule \rn{R-Call}.
For a call $[[ E[let x = f l (y1,,yn) in e] ]]$ where
$f$ is defined as $[[(x1,..., xn)e']]$, the return context $[[ E[let y = [] l in e] ]]$ is
prepended onto the stack of the input configuration.
The substitution of formal arguments for parameters in $e'$, denoted by $[[ [y1/x1],,[yn/xn]e' ]]$,
becomes the currently reducing expression in the output configuration.
Function returns are handled by \rn{R-Var}.
Our semantics return values by name; when the currently executing function fully reduces to a single variable $x$,
$x$ is substituted into the return context on the top of the stack,
denoted by $[[ E[let y = [] l in e] ]][x]$.

In the rules \rn{R-Assert} we write $[[|= [R]ph]]$ to mean the formula
yielded by substituting the concrete values in $[[R]]$ to the variables in $[[ph]]$
is valid within some dedicable logic; in \rn{R-AssertFail} we write $[[ !|= [R]ph ]]$
when the formula is \emph{not} valid.
The substitution operation $[[ [R]ph ]]$ is defined inductively as $[[ [empty] ph = ph ]], [[ [R { x |-> nn }]ph = [R][nn/x]ph ]], [[ [R { x |-> a }] ph = [R]ph ]]$.
In the case of an assertion failure, the semantics step to a distinguished
configuration $[[AssertFail]]$. The goal of our type system to show that no
execution of a well-typed program may reach this configuration.
The \imp{alias} form checks whether the two references actually alias;
i.e., if the must alias assertion provided by the programmer is correct.
If not, our semantics step to the distinguished $[[AliasFail]]$ configuration.
Our type system does \emph{not} guarantee that $[[AliasFail]]$ are \AI{is?} unreachable;
aliasing assertions are effectively trusted annotations and are assumed to hold.

In order avoid duplicates variable names in our register file due to recursive functions,
we refresh the bound variable $[[x]]$ in a \imp{let} expression to $[[x']]$.
Take expression $[[let x=y in e]]$ as an example;
we substitute a fresh variable $[[x']]$ for $[[x]]$ in $[[e]]$, then bind $[[x']]$ to the value
of variable $[[y]]$.
We assume this refreshing of variables preserves our assumption that all variable
bindings introduced with let and function parameters are unique, i.e. $[[x']]$ does
not overlap with a variable name that occurs in the program.
\JT{Do we want to mention this at all?}
\AI{We may want to remove if we need more space.}
Finally, although $\rn{R-MkRef}$ allocates memory, our language does not
support memory reclamation.
We assume a garbage collected environment and consider memory reclamation an orthogonal concern.
\JT{Do we want
  to say that we could have explicit free and use suenaga's
  approach, but don't want to because it unnecessarily complicates
  the system?}
  

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:

%  LocalWords:  ownerships mkref redex
