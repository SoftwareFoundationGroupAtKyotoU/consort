\section{Preliminaries}
\label{sec:prelim}
This sections describes a simple imperative language with mutable memory. Unlike
our prior work on fractional ownerships, we explicitly include integers as base
values in the language definition.

\subsection{Notation}
For a function $f$ we will write $\DOM(f)$ to indicate the domain of
the function. For a function (sometimes called a map) $f$, we will write
$f \{ x \mapsto v \}$ (where $x \not\in\DOM(f)$) to denote a map
which takes all values in $\DOM(f)$ to their corresponding values in $f$ and which
additionally takes $x$ to $v$. We will write $ f \{ x \hookleftarrow v \}$
(where $x\in\DOM(f)$) to denote a new map with $f(x) = v$.
\JT{This is almost certainly not a sufficient overview. write more later.}

\subsection{Language}
The grammar of the language is as follows.
\[
  \begin{array}{rcl}
  [[d]] &::=& [[f |-> (x1,...,xn)e ]] \\
  [[e]] &::= &
               [[ x ]] \mid
               [[ let x = y in e]] \mid
               [[ let x = v in e ]] \mid
               [[ ifz x then e1 else e2 ]] \\
        &\mid& [[ let x = mkref y in e ]] \mid
               [[ let x = *y in e ]] \mid
               [[ let x = f l (y1 ,, yn) in e ]] \\
        &\mid& [[ x := y ; e ]] \mid
               [[ alias(x = y); e ]] \mid
               [[ assert(ph); e ]] \mid
               [[ e1;e2 ]] \\
    [[v]] &::=& [[nn]] \\
    [[P]] &::=& [[<{d1,...,dn}, e>]] \\
    [[l]] &\in& \textbf{Labels}\\
  \end{array}
\]
$[[ph]]$ stands for a logical formula over variables, integers and context strings;
we discuss these formulas later in %section 
\cref{sec:types}.
We assume a set of \emph{variables}, which is ranged over by $x,y,z,\dots$ and
a set of labels ranged over by $[[l1]], [[l2]], \dots$.

Variables are introduced by function parameters or let bindings.
Like ML, the variable bindings introduced by let-expression and parameters
are immutable.
Modeling a mutable variable declaration \texttt{int x = 1} in a language like C is achieved with
\[
  [[ let y = 1 in (let x = mkref y in etc) ]]
\]
in our language.

Unlike ML (and like C or Java) we do not allow general expressions as right hand side of
let bindings. The simplest right-hand forms are a variable $[[y]]$, or an integer value.
$[[mkref y]]$ creates a reference cell with value $[[y]]$, and
$[[*y]]$ accesses the contents of $[[y]]$.
Function calls must occur on the right hand side of a variable binding,
and take the form $[[f l (x1,,xn)]]$, where $[[x1,,xn]]$ are distinct variables and $[[l]]$ is
(unqiue) label drawn from \textbf{Labels}. These labels are used to make our type system context sensitive, as
discussed in \cref{sec:cs}.

The single base case for expressions is a single variable.
If the variable expression is executed in a tail position of a function
then the value of that variable is the return value of the function,
otherwise the value is ignored.

The only control-flow operation in our language are if statements.
If $[[ifz]]$ checkes whether the condition variable $[[x]]$ equals zero and chooses
the corresponding branch. Loops can be implemented with recursive functions and
we do not include them explicitly in our formalism.

Our grammar requires that side-effecting, result free statements, $[[ assert(ph); e ]]$,
$[[alias(x = y);e]]$,
and assignment $[[x := y;e]]$ are followed by a continuation expression.
\NK{This reads a bit strange. Those followd by a continuation expression are
assert($\phi$), alias($x = y$), etc., not 
$[[ assert(ph); e ]]$, $[[alias(x = y);e]]$, etc.}
This requirement does not reduce the expressiveness
of the language, and obviates including a unit type.
The $[[assert(ph); e]]$ form executes $[[e]]$ if the predicate
$[[ph]]$ holds in the current state, and aborts the program otherwise.
$[[alias(x = y); e]]$ is a specialized type of assertion for asserting
must-aliasing relationship between two references $x$ and $y$. Our
type system uses these must-alias annotations to accurately track
aliases.
$[[ x := y ; e ]]$ updates the contents of the memory cell pointed to by $[[x]]$
with the contents of $[[y]]$. For simplicity, we do not include an explicit
null value in our formalism.
In addition to the above continuations, our language supports general sequencing with
$[[e1 ; e2]]$. In the remainder of this paper we will rely on context to disambiguate
between continuations and general sequencing.

A program is a pair of $[[<{d1,...,dn}, e>]]$, where
$[[ {d1,...,dn} ]]$ is a set of function definitions, and $[[e]]$
is the program entry point. The definition
of function maps a function name to a tuple of argument names that are
bound within the function body $[[e]]$. Unlike ML, functions are not
higher order, nor do we allow pointers to functions.

\paragraph{Paper Syntax}
In the remainder of the paper, we will write programs that
are technically illegal according to our grammar, but can be
easily ``de-sugared'' into an equivalent, valid program.
For example, we will write
\begin{lstlisting}
  let x = mkref 4 in assert(*x = 4)
\end{lstlisting}
as syntactic sugar for:
\begin{lstlisting}
  let f = 4 in
  let x = mkref f in
  let tmp = *x in
  assert(tmp = 4); let dummy = 0 in dummy
\end{lstlisting}
Notice that we use a dummy continuation for the
assert statement in the desguring.

\begin{figure}[t]
\[
  \begin{array}{rcl}
    [[ E ]] & ::= & [[ E'; e ]] \mid [[ [] ]] \\
    [[ CE ]] & ::= & [[ E[let y = [] l in e] ]]
  \end{array}
\]
\caption{Grammar of evaluation and return contexts}
\label{fig:eval-context-grammar}
\end{figure}

\iffalse
\subsection{Logical Formula}
Our language defintion, semantics, or type system does not assume
any particular logic. We assume all logical formulae are built
using the standard logical connectives
using primitive relations and functions whose interpretation
given is given by some underlying
theory \theory. Although we do not fix a particular logic or theory,
we do impose the following requirements:
\begin{enumerate}
\item Any \theory-model treats the symbol $[[nn]]$ as a constant denoting the mathematical
  integer $[[nn]]$.
\item The signature for the theory must include all program variables as constants,
  and any \theory-model must assign a mathematical integer to each variable symbol
\end{enumerate}
\fi

\subsection{Operational Semantics}
\label{sec:semantics}
We now introduce the operational semantics for our language.
We assume a finite domain of heap addresses \textbf{Addr}:
we denote an arbitrary address with $[[a]]$.
A runtime state is represented by a configuration $[[<H, R,Es,e>]]$, which are a heap,
register file, stack, and currently reducing expression respectively.
The register file maps variables to runtime values, which are
either integers $[[nn]]$ or addresses $[[a]]$. The heap maps a subset
of addresses to runtime values. The runtime stack represents pending
function calls as a sequence of return contexts, which we
describe below.
While the final configuration component is an expression,
the rewritting rules are defined in terms of $[[ E[e] ]]$, which is
a context $[[E]]$ and redex $[[e]]$, as is standard.
The grammar for evaluation contexts and return contexts are defined
in \cref{fig:eval-context-grammar}.
Our operational semantics are \NK{I think the word ``semantics'' is singular.} given in \cref{fig:transitionRules}.
Notice that the step relation is parameterized
by a set of function defitions $[[D]]$; a program $[[<D, e>]]$ is executed
by stepping the initial context $[[ <empty,empty,.,e> ]]$ according
to $[[-->]]_{[[D]]}$.
The semantics are mostly standard; we highlight some import points below.

First we introduce return contexts, which
take the form $[[ E[let y = [] l in e] ]]$. A return context represents a pending
function call with label $[[l]]$, and indicates that the return value of the
callee should be bound to $[[y]]$ in $[[e]]$, within the larger exectuion context $[[E]]$.
The call stack $[[Es]]$ is a sequence of these contexts, with
the first such return context indicating the most recent function call.
For a function call $[[ E[let x = f l (y1,,yn) in e] ]]$, where $f$ is defined as $[[(x1,..., xn)e']]$,
we first push the return context $[[ E[let y = [] l in e] ]]$ onto the stack $[[Es]]$.
We then substitute the formal arguments for parameters in $e'$, denoted by $[[ [y1/x1],,[yn/xn]e' ]]$.
The result of this substitution becomes the currently reducing expression.
Function returns are handled by \rn{R-Var}.
Our semantics return values by name; when the currently executing function fully reduces to a single variable $x$, we substitue $x$ into the return context on the top of the stack,
denoted by $[[ E[let y = [] l in e] ]][x]$.

In the rules \rn{R-Assert} we write $[[|= [R]ph]]$ to mean the formula
yielded by substituting the concrete values in $[[R]]$ to the variables in $[[ph]]$
is valid within some dedicable logic; in \rn{R-AssertFail} we write $[[ !|= [R]ph ]]$
when the formula is \emph{not} valid.
The substitution operation $[[ [R]ph ]]$ is defined inductively as $[[ [empty] ph = ph ]], [[ [R { x |-> nn }]ph = [R][nn/x]ph ]], [[ [R { x |-> a }] ph = [R]ph ]]$.
In the case of an assertion failure, the semantics step to a distinguished
configuration $[[AssertFail]]$. The goal of our type system to show that no
execution of a well-typed program may reach this configuration.
The \imp{alias} form checks whether the two references actually reference;
i.e., if the must alias assertion provided by the programmer is correct.
If not, our semantics step to the distinguished $[[AliasFail]]$ configuration.
Our type system does \emph{not} guarantee that $[[AliasFail]]$ is unreachable.

When the expression is a let-binding, in order to better handle conflicts
with recursive functions and duplicates variable names in our single register file,
we refresh the bound variable $[[x]]$ in a let expression to $[[x']]$.
Take expression $[[let x=y in e]]$ as an example;
we substitute a fresh variable $[[x']]$ for $[[x]]$ in $[[e]]$, then bind $[[x']]$ to the value
of variable $[[y]]$.
Finally, notice that although $\rn{R-MkRef}$ allocates new memory, our language does not
provide any mechanism to reclaim memory.
We consider memory reclamation an orthogonal concern and
do not support it in our language or formalism.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
