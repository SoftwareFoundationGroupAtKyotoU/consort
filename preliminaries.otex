\section{Preliminaries}
\label{sec:prelim}
This sections describes a simple imperative language with mutable memory. Unlike
our prior work on fractional ownerships, we explicitly include integers as base
values in the language definition.

\subsection{Notation}
For a function $f$ we will write $\DOM(f)$ to indicate the domain of
the function. For a function (sometimes called a map) $f$, we will write
$f \{ x \mapsto v \}$ (where $x \not\in\DOM(f)$) to denote a map
which takes all values in $\DOM(f)$ to their corresponding values in $f$ and which
additionally takes $x$ to $v$. We will write $ f \{ x \hookleftarrow v \}$
(where $x\in\DOM(f)$) to denote a new map with $f(x) = v$.
\JT{This is almost certainly not a sufficient overview. write more later.}

\subsection{Language}
The grammar of the language is as follows.
\[
  \begin{array}{rcl}
  [[d]] &::=& [[f |-> (x1,...,xn)e ]] \\
  [[e]] &::= &
               [[ x ]] \mid
               [[ let x = y in e]] \mid
               [[ let x = v in e ]] \mid
               [[ ifz x then e1 else e2 ]] \\
        &\mid& [[ let x = mkref y in e ]] \mid
               [[ let x = *y in e ]] \mid
               [[ let x = f l (y1 ,, yn) in e ]] \\
        &\mid& [[ x := y ; e ]] \mid
               [[ alias(x = y); e ]] \mid
               [[ alias(x = *y); e ]] \mid
               [[ assert(ph); e ]] \mid
               [[ e1;e2 ]] \\
    [[v]] &::=& [[nn]] \\
    [[P]] &::=& [[<{d1,...,dn}, e>]] \\
    [[l]] &\in& \textbf{Labels}\\
  \end{array}
\]
$[[ph]]$ stands for a logical formula over variables, integers and context strings;
we discuss these formulas later in %section 
\cref{sec:types}.
We assume a set of \emph{variables}, which is ranged over by $x,y,z,\dots$ and
a set of labels ranged over by $[[l1]], [[l2]], \dots$.

Variables are introduced by function parameters or let bindings.
Like ML, the variable bindings introduced by let-expression and parameters
are immutable.
Modeling a mutable variable declaration \texttt{int x = 1} in a language like C is achieved with
\[
  [[ let y = 1 in (let x = mkref y in etc) ]]
\]
in our language. As a convenience, we assume all variable names
introduced with let bindings and function parameters are distinct.

Unlike ML (and like C or Java) we do not allow general expressions as right hand side of
let bindings. The simplest right-hand forms are a variable $[[y]]$, or an integer value.
$[[mkref y]]$ creates a reference cell with value $[[y]]$, and
$[[*y]]$ accesses the contents of $[[y]]$.
Function calls must occur on the right hand side of a variable binding,
and take the form $[[f l (x1,,xn)]]$, where $[[x1,,xn]]$ are distinct variables and $[[l]]$ is
(unqiue) label drawn from \textbf{Labels}. These labels are used to make our type system context sensitive, as
discussed in \cref{sec:cs}.

The single base case for expressions is a single variable.
If the variable expression is executed in a tail position of a function
then the value of that variable is the return value of the function,
otherwise the value is ignored.

The only control-flow operation in our language are if statements.
If $[[ifz]]$ checkes whether the condition variable $[[x]]$ equals zero and chooses
the corresponding branch. Loops can be implemented with recursive functions and
we do not include them explicitly in our formalism.

Our grammar requires that side-effecting, result free statements, \lstinline{assert($[[ph]]$)}
\lstinline{alias($[[x]]$ = $[[y]]$)}, \lstinline{alias($[[x]]$ = *$[[y]]$)} and
assignment \lstinline{$[[x]]$ := $[[y]]$} are followed by a continuation expression.
\AI{Commands should be typeset in italic.}
We impose this requirement for technical reasons to ease our formal
presentation; note that this requirement does not reduce the expressiveness
of the language as dummy continuations can be inserted as needed.
The $[[assert(ph); e]]$ form executes $[[e]]$ if the predicate
$[[ph]]$ holds in the current state, and aborts the program otherwise.
$[[alias(x = y); e]]$ is a specialized type of assertion for asserting
must-aliasing relationship between two references $x$ and $y$. Our
type system uses these must-alias annotations to accurately track
aliases.
$[[ x := y ; e ]]$ updates the contents of the memory cell pointed to by $[[x]]$
with the contents of $[[y]]$. For simplicity, we do not include an explicit
null value in our formalism.
In addition to the above continuations, our language supports general sequencing with
$[[e1 ; e2]]$. In the remainder of this paper we will rely on context to disambiguate
between continuations and general sequencing.

A program is a pair of $[[<{d1,...,dn}, e>]]$, where
$[[ {d1,...,dn} ]]$ is a set of function definitions, and $[[e]]$
is the program entry point. The definition
of function maps a function name to a tuple of argument names that are
bound within the function body $[[e]]$. Unlike ML, functions are not
higher order, nor do we allow pointers to functions.

\paragraph{Paper Syntax}
In the remainder of the paper, we will write programs that
are technically illegal according to our grammar, but can be
easily ``de-sugared'' into an equivalent, valid program.
For example, we will write
\begin{lstlisting}
  let x = mkref 4 in assert(*x = 4)
\end{lstlisting}
as syntactic sugar for:
\begin{lstlisting}
  let f = 4 in
  let x = mkref f in
  let tmp = *x in
  assert(tmp = 4); let dummy = 0 in dummy
\end{lstlisting}
Notice that we use a dummy continuation for the
assert statement in the desguring.

\begin{figure}[t]
\[
  \begin{array}{rcl}
    [[ E ]] & ::= & [[ E'; e ]] \mid [[ [] ]] \\
    [[ CE ]] & ::= & [[ E[let y = [] l in e] ]]
  \end{array}
\]
\caption{Grammar of evaluation and return contexts}
\label{fig:eval-context-grammar}
\end{figure}

\input{semantics}

\subsection{Operational Semantics}
\label{sec:semantics}
We now introduce the operational semantics for our language.
We assume a finite domain of heap addresses \textbf{Addr}:
we denote an arbitrary address with $[[a]]$.
A runtime state is represented by a configuration $[[<H, R,Es,e>]]$, which are a heap,
register file, stack, and currently reducing expression respectively.
\AI{A stack should be a sequence of $[[CE]]$, not $[[E]]$.}
The register file maps variables to runtime values, which are
either integers $[[nn]]$ or addresses $[[a]]$. The heap maps a subset
of addresses to runtime values. The runtime stack represents pending
function calls as a sequence of return contexts, which we
describe below.
While the final configuration component is an expression,
the rewritting rules are defined in terms of $[[ E[e] ]]$, which is
a context $[[E]]$ and redex $[[e]]$, as is standard.
The grammar for evaluation contexts and return contexts are defined
in \cref{fig:eval-context-grammar}.
Our operational semantics is given in \cref{fig:transitionRules1,fig:transitionRules2}.
Notice that the step relation is parameterized
by a set of function defitions $[[D]]$; a program $[[<D, e>]]$ is executed
by stepping the initial context $[[ <empty,empty,.,e> ]]$ according
to $[[-->]]_{[[D]]}$.
The semantics are mostly standard; we highlight some import points below.

First we introduce return contexts, which
take the form $[[ E[let y = [] l in e] ]]$. A return context represents a pending
function call with label $[[l]]$, and indicates that the return value of the
callee should be bound to $[[y]]$ in $[[e]]$, within the larger exectuion context $[[E]]$.
The call stack $[[Es]]$ is a sequence of these contexts, with
the first such return context indicating the most recent function call.
For a function call $[[ E[let x = f l (y1,,yn) in e] ]]$, where $f$ is defined as $[[(x1,..., xn)e']]$,
we first push the return context $[[ E[let y = [] l in e] ]]$ onto the stack $[[Es]]$.
We then substitute the formal arguments for parameters in $e'$, denoted by $[[ [y1/x1],,[yn/xn]e' ]]$.
The result of this substitution becomes the currently reducing expression.
Function returns are handled by \rn{R-Var}.
Our semantics return values by name; when the currently executing function fully reduces to a single variable $x$, we substitue $x$ into the return context on the top of the stack,
denoted by $[[ E[let y = [] l in e] ]][x]$.

In the rules \rn{R-Assert} we write $[[|= [R]ph]]$ to mean the formula
yielded by substituting the concrete values in $[[R]]$ to the variables in $[[ph]]$
is valid within some dedicable logic; in \rn{R-AssertFail} we write $[[ !|= [R]ph ]]$
when the formula is \emph{not} valid.
The substitution operation $[[ [R]ph ]]$ is defined inductively as $[[ [empty] ph = ph ]], [[ [R { x |-> nn }]ph = [R][nn/x]ph ]], [[ [R { x |-> a }] ph = [R]ph ]]$.
In the case of an assertion failure, the semantics step to a distinguished
configuration $[[AssertFail]]$. The goal of our type system to show that no
execution of a well-typed program may reach this configuration.
The \imp{alias} form checks whether the two references actually reference;
i.e., if the must alias assertion provided by the programmer is correct.
If not, our semantics step to the distinguished $[[AliasFail]]$ configuration.
Our type system does \emph{not} guarantee that $[[AliasFail]]$ is unreachable.

When the expression is a let-binding, in order to better handle conflicts
with recursive functions and duplicates variable names in our single register file,
we refresh the bound variable $[[x]]$ in a let expression to $[[x']]$.
Take expression $[[let x=y in e]]$ as an example;
we substitute a fresh variable $[[x']]$ for $[[x]]$ in $[[e]]$, then bind $[[x']]$ to the value
of variable $[[y]]$.
We assume this refreshing of variables preserves our assumption that all variable
bindings introduced with let and function parameters are unique, i.e. $[[x']]$ does
not overlap with a variable name that occurs in the program.
Finally, notice that although $\rn{R-MkRef}$ allocates new memory, our language does not
provide any mechanism to reclaim memory.
We consider memory reclamation an orthogonal concern and
do not support it in our language or formalism.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
