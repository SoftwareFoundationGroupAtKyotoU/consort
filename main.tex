% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.20 of 2017/10/04
%
\documentclass[runningheads]{llncs}
%
\usepackage{bcprules}\typicallabel{T-Hoge}
\usepackage{graphicx,color}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
% \renewcommand\UrlFont{\color{blue}\rmfamily}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}

\input{local}

\newcommand{\AI}[1]{\textcolor{blue}{[AI: #1]\marginpar{$\longleftarrow$}}}

\begin{document}
%
\title{Context- and Flow-Sensitive Refinement Types for Imperative Programs}
%
%\titlerunning{Abbreviated paper title}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
\author{Ren Siqi \and Kohei Suenaga \and Atsushi Igarashi \and Naoki Kobayashi}
%
\authorrunning{Ren Siqi et al.}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{}
%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}

\keywords{}
\end{abstract}
%
%
%

\section{Simple setting without indirection of pointers and without subtyping}

\subsection{Language}

\[
  \begin{array}{rcl}
  \decl &::=& \set{f \mapsto (x_1,\dots,x_n)\expr}\\
  % \expr &::=& x \mid \DEREF x \mid \intconst \mid \NULL\\
  \expr &::= &
              \intconst \mid
              x \mid
              \LET x = y \IN \expr \mid
              \LET x = \intconst \IN \expr \mid
              \IFZERO x \THEN \expr_1 \ELSE \expr_2  \\ &\mid&
              \LET x = \MKREF y \IN \expr \mid
              \LET x = *y \IN \expr \mid
              \LET x = f^\ell(e_1,\dots,e_n) \IN \expr \\ &\mid&
              x \WRITE y \SEQ \expr \mid
              \ALIAS(\expr_1 = \expr_2) \SEQ \expr_3 \mid
              \ASSERT(\varphi) \SEQ e \\
    \prog &::=& \tuple{\decl_1 \cup \dots \cup \decl_n, \expr}\\
    \pp &\in& \textbf{Labels}
  \end{array}
\]

\(\varphi\) stands for a logical formula.

\subsection{Type system}

\[
\begin{array}{rcl}
  \typ &::=& \TUNIT \mid \set{x \COL \TINT \mid \varphi} \mid \set{x \COL \TINT \mid \varphi} \TREF^{\ownership}\\
  \funtyp &::=& \tuple{x_1\COL\typ_1,\dots,x_n\COL\typ_n}\ra\tuple{x_1\COL\typ_1',\dots,x_n\COL\typ_n' \mid \typ}\\
  \ownership &\in& [0,1] \subseteq \RAT\\
  \pps &\in& \textbf{Labels}^*
\end{array}
\]
\begin{definition}
  $\sem{\typ}_y$ is defined as follows:
  \[
    \begin{array}{rcl}
      \sem{\TUNIT}_y &=& \TRUE\\
      \sem{\set{x \COL \TINT \mid \varphi}}_y &=& [y/x]\varphi\\
      \sem{\set{x \COL \TINT \mid \varphi} \TREF^{\ownership}}_y &=& \TRUE.
    \end{array}
  \]
\end{definition}

\begin{definition}
  $\sem{\Gamma}$ is defined as follows:
  \[
    \begin{array}{rcl}
      \sem{\emptyset} &=& \TRUE\\
      \sem{x\COL\typ, \Gamma} &=& \sem{\typ}_x \land \sem{\Gamma}.
    \end{array}
  \]
\end{definition}

\begin{definition}
  We write $\Gamma \models \varphi$ if $\models \sem{\Gamma} \implies \varphi$ holds.
\end{definition}

\paragraph{Operations on types.}

\begin{figure}[t]
\leavevmode
  \infrule[Tadd-Ref1]{
    \ownership_1 \ne 0 \andalso
    \ownership_2 \ne 0
  }{
    \set{x \COL \TINT \mid \varphi} \TREF^{\ownership_1} + \set{x \COL \TINT \mid \varphi} \TREF^{\ownership_2} = \set{x \COL \TINT \mid \varphi} \TREF^{\ownership_1 + \ownership_2}
  }
  \infax[Tadd-Ref2]{
    \typ_1 \TREF^0 + \typ_2 \TREF^{\ownership} = \typ_2 \TREF^{\ownership}
  }

  \caption{Rules for $\typ_1 \addt \typ_2$.}
  \label{fig:addition}
\end{figure}

\begin{definition}
  $\typ_1 + \typ_2$ is the least commutative operation that satisfies the rules in Figure~\ref{fig:addition}.
  \AI{Rules for unit and int types.}
\end{definition}

\paragraph{Subtyping.}

\AI{What is the intention of \rn{Sub-Int1}?  Since ref types do not nest, \rn{Sub-Ref} doesn't make much sense.}
  \AI{Rules for unit and int types.}
\begin{figure}[t]
\leavevmode
  \infrule[Sub-Int1]{
    \tenv \models \varphi_1 \iff \varphi_2
  }{
    \tenv \vdash \set{x \COL \TINT \mid \varphi_1} \TREF^1 \subt \set{x \COL \TINT \mid \varphi_2} \TREF^1
  }
  \infrule[Sub-Int2]{
    0 < u < 1 \andalso
    \tenv \models \varphi_1 \implies \varphi_2
  }{
    \tenv \vdash \set{x \COL \TINT \mid \varphi_1} \TREF^{u} \subt \set{x \COL \TINT \mid \varphi_2} \TREF^{u}
  }
  \infrule[Sub-Ref]{
    \ownership_1 \ge \ownership_2
    \andalso
    \ownership_2 \ge 1 \implies \tenv \vdash \typ_2 \subt \typ_1
    \andalso
    \ownership_2 > 0 \implies \tenv \vdash \typ_1 \subt \typ_2
  }{
    \tenv \vdash \typ_1 \TREF^{\ownership_1} \subt \typ_2 \TREF^{\ownership_2}
  }
  
  \caption{Rules for subtyping.}
  \label{fig:subtyping}
\end{figure}

\paragraph{Type judgment.}

\AI{\rn{T-Let} loses information that $x$ is equal to $y$ (unlike \rn{T-LetInt}).}

\begin{figure}[t]
\leavevmode
  \infrule[T-MkRef]{
    \funenv \mid \tenv, x \COL \typ_1 \TREF^1, y \COL \typ_2 \mid \beta \vdash \expr \COL \typ' \produces \tenv'
    \andalso
    x \notin \fv(\typ')
  }{
    \funenv \mid \tenv, y \COL (\typ_1 + \typ_2) \mid \beta \p \LET x = \MKREF y \IN \expr \COL \typ' \produces \tenv' \diff x
  }
  \infrule[T-Let]{
    \funenv \mid \tenv, x \COL \typ_1, y \COL \typ_2 \mid \beta \p \expr \COL \typ' \produces \tenv'
    \andalso
    x \notin \fv(\typ')
  }{
    \funenv \mid \tenv, y\COL(\typ_1+\typ_2) \mid \beta \p \LET x = y \IN \expr \COL \typ' \produces \tenv' \diff x
  }
  \infrule[T-LetInt]{
    \funenv \mid \tenv, x\COL\set{x \COL \TINT \mid x = \intconst} \mid \beta \p \expr \COL \typ' \produces \tenv'
    \andalso
    x \notin \fv(\typ')
  }{
    \funenv \mid \tenv \mid \beta \p \LET x = \intconst \IN \expr \COL \typ' \produces \tenv' \diff x
  }
  \infrule[T-Assert]{
    \Gamma \models \varphi
  }{
    \funenv \mid \Gamma \mid \beta \vdash \ASSERT(\varphi) \COL \TUNIT \produces \Gamma
  }
  \infrule[T-Call]{
    \funenv(f) = \forall \pps_1. \tuple{x_1\COL\typ_1,\dots,x_n\COL\typ_n} \ra \tuple{x_1\COL\typ_1',\dots,x_n\COL\typ_n' \mid \typ}\\
    \funenv \mid [\pp\pps_2/\pps_1](x_1\COL\typ_1',\dots,x_n\COL\typ_n',y\COL\typ) \mid \pps_2 \vdash \expr \COL \typ' \produces \tenv'
    \andalso
    y \notin \fv(\typ)
  }{
    \funenv \mid [\pp\pps_2/\pps_1](x_1\COL\typ_1,\dots,x_n\COL\typ_n) \mid \pps_2 \p \LET y = f^\pp(x_1,\dots,x_n) \IN \expr \COL \typ \produces \tenv' \diff y
  }
  \infrule[T-FunDef]{
    \funenv(f) = \forall \alpha. \tuple{x_1\COL\typ_1,\dots,x_n\COL\typ_n}\ra\tuple{x_1\COL\typ_1',\dots,x_n\COL\typ_n' \mid \typ}\\
    \funenv \mid x_1\COL\typ_1,\dots,x_n\COL\typ_n \mid \alpha \vdash \expr \COL \typ \produces x_1\COL\typ_1',\dots,x_n\COL\typ_n'\\
    \alpha \notin \fcv(\funenv)
  }{
    \funenv \vdash \set{f \mapsto (x_1,\dots,x_n)\expr}
  }
  \infrule[T-Prog]{
  }{
    \vdash \tuple{\decl_1 \cup \dots \cup \decl_n, \expr}
  }

\caption{Typing rules.}
\label{fig:typingRules}
\end{figure}

\bibliographystyle{plain}
\bibliography{main.bib}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
