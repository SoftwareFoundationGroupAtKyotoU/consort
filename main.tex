% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.20 of 2017/10/04
%
\documentclass[runningheads]{llncs}
%
\usepackage{bcprules}\typicallabel{T-Hoge}
\usepackage{graphicx,color}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
% \renewcommand\UrlFont{\color{blue}\rmfamily}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}

\input{local}

\newcommand{\AI}[1]{\textcolor{blue}{[AI: #1]\marginpar{$\longleftarrow$}}}

\begin{document}
%
\title{Context- and Flow-Sensitive Refinement Types for Imperative Programs}
%
%\titlerunning{Abbreviated paper title}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
\author{Ren Siqi \and Kohei Suenaga \and Atsushi Igarashi \and Naoki Kobayashi}
%
\authorrunning{Ren Siqi et al.}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{}
%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}

\keywords{}
\end{abstract}
%
%
%

\section{Simple setting without indirection of pointers and without subtyping}

\subsection{Language}

\[
  \begin{array}{rcl}
  \decl &::=& f \mapsto (x_1,\dots,x_n)\expr \\
  % \expr &::=& x \mid \DEREF x \mid \intconst \mid \NULL\\
  \expr &::= &
              \intconst \mid
              x \mid
              \LET x = y \IN \expr \mid
              \LET x = \intconst \IN \expr \mid
              \IFZERO x \THEN \expr_1 \ELSE \expr_2  \\ &\mid&
              \LET x = \MKREF y \IN \expr \mid
              \LET x = *y \IN \expr \mid
              \LET x = f^\ell(e_1,\dots,e_n) \IN \expr \\ &\mid&
              x \WRITE y \SEQ \expr \mid
              \ALIAS(\expr_1 = \expr_2) \SEQ \expr_3 \mid
              \ASSERT(\varphi) \SEQ \expr \\
    \prog &::=& \tuple{\set{\decl_1, \dots, \decl_n}, \expr}\\
    \pp &\in& \textbf{Labels}\\
  \pps &\in& \textbf{Labels}^*
  \end{array}
\]

\(\varphi\) stands for a logical formula over integers and paths $\pps$).

\subsection{Type system}

\[
\begin{array}{rcl}
  \typ &::=& \TUNIT \mid \set{x \COL \TINT \mid \varphi} \mid \set{x \COL \TINT \mid \varphi} \TREF^{\ownership}\\
  \funtyp &::=& \tuple{x_1\COL\typ_1,\dots,x_n\COL\typ_n}\ra\tuple{x_1\COL\typ_1',\dots,x_n\COL\typ_n' \mid \typ}\\
  \ownership &\in& [0,1] \subseteq \RAT
\end{array}
\]
\begin{definition}
  $\sem{\typ}_y$ is defined as follows:
  \[
    \begin{array}{rcl}
      \sem{\TUNIT}_y &=& \TRUE\\
      \sem{\set{x \COL \TINT \mid \varphi}}_y &=& [y/x]\varphi\\
      \sem{\set{x \COL \TINT \mid \varphi} \TREF^{\ownership}}_y &=& \TRUE.
    \end{array}
  \]
\end{definition}

\begin{definition}
  $\sem{\Gamma}$ is defined as follows:
  \[
    \begin{array}{rcl}
      \sem{\emptyset} &=& \TRUE\\
      \sem{\Gamma, x\COL\typ} &=& \sem{\Gamma} \land \sem{\typ}_x \\
      \sem{\Gamma, \varphi} & = & \sem{\Gamma} \land \varphi.
    \end{array}
  \]
\end{definition}

\begin{definition}
  We write $\Gamma \models \varphi$ if $\models \sem{\Gamma} \implies \varphi$ holds.
\end{definition}

\paragraph{Operations on types.}

\begin{figure}[t]
  \leavevmode
  \infax[Tadd-Unit]{
    \TUNIT + \TUNIT = \TUNIT
  }
  \infax[Tadd-Int]{
    \set{x \COL \TINT \mid \varphi} + \set{x \COL \TINT \mid \varphi} = \set{x \COL \TINT \mid \varphi}
    }
  \infrule[Tadd-Ref1]{
    \ownership_1 \ne 0 \andalso
    \ownership_2 \ne 0
  }{
    \set{x \COL \TINT \mid \varphi} \TREF^{\ownership_1} + \set{x \COL \TINT \mid \varphi} \TREF^{\ownership_2} = \set{x \COL \TINT \mid \varphi} \TREF^{\ownership_1 + \ownership_2}
  }
  \infrule[Tadd-Ref2]{
    r > 0
    }{
    \typ_1 \TREF^0 + \typ_2 \TREF^{\ownership} = \typ_2 \TREF^{\ownership}
  }
  \infax[Tadd-Ref3]{
    \typ_1 \TREF^0 + \typ_2 \TREF^0 = \set{x \COL \TINT \mid \textbf{true}} \TREF^0
  }

  \caption{Rules for $\typ_1 \addt \typ_2$.}
  \label{fig:addition}
\end{figure}

\begin{definition}
  $\typ_1 + \typ_2$ is the least commutative partial operation that satisfies the rules in Figure~\ref{fig:addition}.
  \AI{Rules for unit and int types.}
\end{definition}

\paragraph{Subtyping.}

\begin{figure}[t]
\leavevmode
  % \infrule[Sub-Int1]{
  %   \tenv \models \varphi_1 \iff \varphi_2
  % }{
  %   \tenv \vdash \set{x \COL \TINT \mid \varphi_1} \TREF^1 \subt \set{x \COL \TINT \mid \varphi_2} \TREF^1
  % }
  \infax[Sub-Unit]{
    \tenv \vdash \TUNIT \subt \TUNIT
  }
  \infrule[Sub-Int]{
    \tenv \models \varphi_1 \implies \varphi_2
  }{
    \tenv \vdash \set{x \COL \TINT \mid \varphi_1} \subt \set{x \COL \TINT \mid \varphi_2}
  }
  \infrule[Sub-Ref]{
    \ownership_1 \ge \ownership_2
    \andalso
    \ownership_2 \ge 1 \implies \tenv \vdash \typ_2 \subt \typ_1
    \andalso
    \ownership_2 > 0 \implies \tenv \vdash \typ_1 \subt \typ_2
  }{
    \tenv \vdash \typ_1 \TREF^{\ownership_1} \subt \typ_2 \TREF^{\ownership_2}
  }
  \infrule[Sub-TyEnv]{
    \tenv \vdash \tenv(x) \subt \tenv'(x) \quad (x \in dom(\tenv')) \\
    \models \sem{\tenv} \implies \sem{\tenv'}
  }{
    \tenv \subt \tenv'
  }
  \caption{Rules for subtyping.}
  \label{fig:subtyping}
\end{figure}

\paragraph{Type judgment.}

\AI{\rn{T-Let} loses information that $x$ is equal to $y$ (unlike \rn{T-LetInt}).}

\begin{figure}[t]
  \leavevmode
  \infrule[T-Int]{
  }{
    \funenv \mid \tenv
            \mid \beta \vdash n \COL \set{x \COL \TINT \mid x = \intconst} \COL \tenv
  }
  \infrule[T-Var]{
  }{
    \funenv \mid \tenv_1, x\COL(\typ_1+\typ_2),\tenv_2 \mid \beta \vdash x \COL  \typ_1 \produces \tenv_1, x\COL \typ_2, \tenv_2
  }
  \infrule[T-Let]{
    \funenv \mid \tenv_1, y \COL \typ_2, \tenv_2, x \COL \typ_1, x =_{\typ_1} y \mid \beta \p \expr \COL \typ' \produces \tenv'
    \andalso
    x \notin \fv(\typ')
  }{
    \funenv \mid \tenv_1, y\COL(\typ_1+\typ_2), \tenv_2 \mid \beta \p \LET x = y \IN \expr \COL \typ' \produces \tenv' \diff x
  }
  \infrule[T-LetInt]{
    \funenv \mid \tenv, x\COL\set{x \COL \TINT \mid x = \intconst} \mid \beta \p \expr \COL \typ' \produces \tenv'
    \andalso
    x \notin \fv(\typ')
  }{
    \funenv \mid \tenv \mid \beta \p \LET x = \intconst \IN \expr \COL \typ' \produces \tenv' \diff x
  }
  \infrule[T-If]{
    \tenv = \tenv_1, x : \set{y:\TINT \mid \varphi}, \tenv_2 \\
    \funenv \mid \tenv_1, x : \set{y:\TINT \mid \varphi \land y = 0}, \tenv_2 \mid \beta \vdash \expr_1 \COL \typ \produces \tenv' \\
    \funenv \mid \tenv_1, x : \set{y:\TINT \mid \varphi \land y \neq 0}, \tenv_2 \mid \beta \vdash \expr_2 \COL \typ \produces \tenv'
  }{
    \funenv \mid \tenv_1, x : \set{y:\TINT \mid \varphi}, \tenv_2 \mid \beta \vdash \IFZERO x \THEN \expr_1 \ELSE \expr_2 \COL \typ \produces \tenv'
  }
  \infrule[T-MkRef]{
    \funenv \mid \tenv_1, y \COL \typ_2, \tenv_2, x \COL \typ_1 \TREF^1 \mid \beta \vdash \expr \COL \typ' \produces \tenv'
    \andalso
    x \notin \fv(\typ')
  }{
    \funenv \mid \tenv_1, y \COL (\typ_1 + \typ_2), \tenv_2 \mid \beta \p \LET x = \MKREF y \IN \expr \COL \typ' \produces \tenv' \diff x
  }
  \infrule[T-Deref]{
    r > 0 \andalso
    \funenv \mid \tenv_1, y \COL \typ_1 \TREF^r, \tenv_2, x \COL \typ_2 \mid \beta \vdash \expr \COL \typ' \produces \tenv' \andalso
    x \not \in \fv(\typ')
  }{
    \funenv \mid \tenv_1, y \COL (\typ_1 + \typ_2) \TREF^r, \tenv_2 \mid \beta \vdash \LET x = *y \IN \expr \COL \typ' \produces \tenv' \diff x
  }
  \infrule[T-Call]{
    \funenv(f) = \forall \pps_1. \tuple{x_1\COL\typ_1,\dots,x_n\COL\typ_n} \ra \tuple{x_1\COL\typ_1',\dots,x_n\COL\typ_n' \mid \typ}\\
    \funenv \mid \tenv,[\pp\pps_2/\pps_1](x_1\COL\typ_1',\dots,x_n\COL\typ_n',y\COL\typ) \mid \pps_2 \vdash \expr \COL \typ' \produces \tenv'
    \andalso
    y \notin \fv(\typ)
  }{
    \funenv \mid \tenv,[\pp\pps_2/\pps_1](x_1\COL\typ_1,\dots,x_n\COL\typ_n) \mid \pps_2 \p \LET y = f^\pp(x_1,\dots,x_n) \IN \expr \COL \typ' \produces \tenv' \diff y
  }
  \infrule[T-Assign]{
    (\text{The shapes of $\typ'$ and $\typ_2$ are similar}) \\
    \funenv \mid \tenv_1,  y : \typ_2, \tenv_2, x : \typ_1 \TREF^1 \mid \beta \vdash  \expr \COL \typ \produces \tenv'
  }{
    \funenv \mid \tenv_1, y : (\typ_1+\typ_2), \tenv_2, x : \typ' \TREF^1 \mid \beta \vdash  x \WRITE y \SEQ \expr \COL \typ \produces \tenv'
  }
  \infrule[T-Alias]{
    \typ_1 \TREF^{r_1} + \typ_2 \TREF^{r_2} = \typ'_1 \TREF^{r'_1} + \typ'_2 \TREF^{r'_2}
    \\
    \funenv \mid \tenv, x : \typ'_1 \TREF^{r'_1}, y : \typ'_2 \TREF^{r'_2} \mid \beta \vdash \expr_3 \COL \tau \produces \tenv'
  }{
    \funenv \mid \tenv, x : \typ_1 \TREF^{r_1}, y : \typ_2 \TREF^{r_2} \mid \beta \vdash \ALIAS(x = y) \SEQ \expr_3 \COL \tau \produces \tenv'
  }
  \infrule[T-Assert]{
    \tenv \models \varphi \andalso
    \funenv \mid \tenv \mid \beta \vdash \expr \COL \tau \produces \tenv'
  }{
    \funenv \mid \tenv \mid \beta \vdash \ASSERT(\varphi)\SEQ \expr \COL \tau \produces \tenv'
  }
  \infrule[T-Sub]{
    \tenv \subt \tenv' \andalso
    \funenv \mid \tenv' \mid \beta \vdash \expr \COL \tau \produces \tenv'' \andalso
    \tenv'', x:\typ \subt \tenv''', x:\typ'
  }{
    \funenv \mid \tenv \mid \beta \vdash \expr \COL \typ' \produces \tenv'''
  }
  \infrule[T-FunDef]{
    \funenv(f) = \forall \alpha. \tuple{x_1\COL\typ_1,\dots,x_n\COL\typ_n}\ra\tuple{x_1\COL\typ_1',\dots,x_n\COL\typ_n' \mid \typ}\\
    \funenv \mid x_1\COL\typ_1,\dots,x_n\COL\typ_n \mid \alpha \vdash \expr \COL \typ \produces x_1\COL\typ_1',\dots,x_n\COL\typ_n'\\
    \alpha \notin \fcv(\funenv)
  }{
    \funenv \vdash f \mapsto (x_1,\dots,x_n)\expr
  }
  \infrule[T-Prog]{
    \funenv \vdash d_1 \quad \cdots \quad
    \funenv \vdash d_n \andalso
    \funenv \mid \emptyset \mid \varepsilon \vdash e : \TUNIT \produces \tenv'
  }{
    \vdash \tuple{\set{\decl_1, \dots, \decl_n}, \expr}
  }
\caption{Typing rules.}
\label{fig:typingRules}
\end{figure}

\AI{\rn{T-Let} discards all the refinement on \(x\).  Probably we should propagate it to $\tenv'$.}

\AI{\rn{T-Let} and \rn{T-LetInt} can be merged.}

\AI{Define \(x =_\typ y\).}

\AI{\rn{T-Call} requires actual arguments to be variables introduced at the end of the type environment.  This is not a restriction because one can introduce let-expressions before a function call and alias-expressions after the call.}

\AI{$\varepsilon$ in \rn{T-Prog} stands for the empty string.}

\AI{$\tenv_1, x:\typ \TREF^1, \tenv_2 \subt \tenv_1, \tenv_2, x:\typ \TREF^1$ should always hold ($\tenv_2$ cannot reference $x$).}

\section{TODO}

\begin{itemize}
\item Running example.
\item Inference (constraint generation) algorithm.
\end{itemize}

\bibliographystyle{plain}
\bibliography{main.bib}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
